





RAZVOJ MOBILNIH APLIKACIJA
PRIRU?NIK ZA 4. RAZRED GIMNAZIJE


AUTORI:
ZLATKO STAPID, IVAN ŠVOGOR i DAVOR FODREK














VARAŽDIN, 2016.




Priru?nik je izra?en u sklopu projekta „ HEUREKA – spoznajom do uspjeha“ kojeg je f inancirala Europska unija.

Projekt je financirala Europska unija u 100%-om iznosu iz Europskog socijalnog fonda kroz Operativni program „Razvoj ljudskih potencija 2007.-2013., poziv na dostavu projektnih prijedloga HR.3.1.20 Promocija kvalitete i unaprje?enje sustava odgoja i obrazovanja na srednjoškolskoj razini.
Sadržaj ove publikacije / emitiranog materijala isklju?iva je odgovornost Srednje škole Ivanec

SREDNJA ŠKOLA IVANEC – nositelj projekta
Ravnateljica: mr.sc. Lidija Kozina dipl.oec Eugena Kumi?ida 7, 42 240 Ivanec
Telefon: 042 782 344; Faks: 042 781 512
E-mail: info@ss-ivanec.hr
Web: http://www.ss-ivanec.hr/

SREDNJA ŠKOLA MATE BLAŽINE LABIN – partner na projektu
Ravnatelj: ?edomir Ružid, prof. Rudarska 4, 52 220 Labin
Telefon: 052 856 277; Faks: O52 855 329
E-mail: ssmb@ss-mblazine-labin.skole.hr Web:	http://www.ssmb.hr

Posredni?ko tijelo razine 1
Ministarstvo znanosti, obrazovanja i sporta Ulica Donje Svetice 38, 10000 Zagreb
E-mail: esf@mzos.hr
Web: http://public.mzos.hr

Posredni?ko tijelo razine 2
Agencija za odgoj i strukovno obrazovanje i obrazovanje odraslih, Organizacijska jedinica za upravljanje strukturnim instrumentima
Radni?ka cesta 37b, 10000 Zagreb E-mail: defco@asoo.hr
Web: http://www.asoo.hr/defco

Za više informacija o EU fondovima u RH:
www.mrrfeu.hr, www.strukturnifondovi.hr


Autori:	Zlatko Stapid, Ivan Švogor i Davor Fodrek
Nakladnik:	Sveu?ilište u Zagrebu, Fakultet organizacije i informatike Pavlinska 2, 42000 Varaždin
Za nakladnika: Prof.dr.sc. Neven Vr?ek, dekan ISBN 978-953-6071-54-8

CIP zapis je dostupan u ra?unalnome katalogu Nacionalne i sveu?ilišne knjižnice u Zagrebu pod brojem 000942866.

PREDGOVOR

Trenutno svjedo?imo sve ?ešdoj primjeni pametnih, ugra?enih i povezanih ure?aja, integraciji interneta stvari i interneta svega u mobilne aplikacije, primjeni virtualne, ali i proširene stvarnosti, te “oživljavanju” razli?itih predmeta koji su sada u stanju “razgovarati” s vašim mobitelom, kao što su na primjer igra?ke za djecu, sportska oprema, ali i automobili, stambeni prostori i sli?no. Spomenute tehnologije toliko su integrirane u našu svakodnevnicu da su postale neizostavnim dijelom obavljanja svakodnevnih životnih aktivnosti poput pladanja ra?una, mrežnoga pretraživanja, razmjene informacija ili razonode.
Industrija informacijsko-komunikacijskih tehnologija (IKT) trenutno je jedna od najbrže rastudih industrija u Hrvatskoj. Ova industrija, kojoj pripada i razvoj mobilnih proizvoda, od 2013. godine, a posebno tijekom 2015. godine, bilježi ubrzan oporavak u smislu broja zaposlenih i ukupnog udjela u izvozu proizvoda i usluga. Istraživanje potreba poslodavaca na lokalnoj razini tako?er je pokazalo da postoji nedostatak stru?njaka sa znanjima u navedenom podru?ju te postoji stalna potreba za kadrom sa suvremenim IT kompetencijama u podru?ju mobilnih tehnologija i razvoja softvera.
Stoga, ovaj priru?nik za fakultativni predmet Razvoj mobilnih aplikacija, ima za cilj omoguditi u?enicima 4. razreda opde gimnazije uvid u ovo izazovno podru?je te im pružiti temelje i motivirati ih za daljnje usavršavanje. Specifi?ni ciljevi priru?nika su omoguditi u?enicima usvajanje temeljnih znanja o osmišljavanju programskoga proizvoda i njegove arhitekture, objektno orijentiranom pristupu razvoja aplikacija, stjecanje vještina za rad u integriranom razvojnom okruženju, upoznavanje elemenata korisni?koga su?elja Android aplikacije kao i korištenje web servisa i biblioteka trede strane u razvoju aplikacija. Ovaj priru?nik naglasak stavlja na razvoj mobilnog softvera te ne prikazuje koncepte koji su karakteristi?ni za razvoj drugih programskih proizvoda.
Kona?no, cilj priru?nika je utvrditi temelje u domeni programske logike i razumijevanja složenih problema koje predstavlja okruženje u kojima se rabi mobilna aplikacija, kao i mogudnost samostalnoga djelovanja i rješavanja izazova u nepredvi?enim okolnostima. Poznavanjem temeljnih informati?kih koncepata kao što su programiranje, algoritmi ili strukture podataka, u?enik ne ostaje samo korisnik informacijsko-komunikacijske tehnologije ved i njezin stvaratelj.
Priru?nik je podijeljen u dvije osnovne cjeline. Prva cjelina donosi poglavlja koja se odnose na teorijske koncepte razvoja mobilnih aplikacija, a druga cjelina prikazuje cjelokupni proces razvoja mobilne aplikacije Memento vodedi u?enika kroz cjelokupni proces korak po korak.
Autori




Predgovor	A

Sadržaj priru?nika	1
1 Uvod u mobilni razvoj	5
1.1 Razrada projektne ideje	6
1.1.1 Odabir domene razvoja	6
1.1.2 Analiza navika potroša?a i promjena navika	6
1.1.3 Analiza tehnoloških trendova i novih tehnologija	7
1.1.4 Odabir segmenta ciljanih korisnika	7
1.1.5 Definiranje potencijalnih ideja	7
1.1.6 Analiza konkurentskih proizvoda	8
1.1.7 Pronalazak vodede funkcionalnosti	8
1.1.8 Kona?ni odabir projektne ideje	9
1.2 Proces razvoja mobilnih aplikacija	10
1.2.1 Faze procesa razvoja	10
1.2.2 Klasifikacija metodika razvoja	11
1.2.3 Klasifikacija pristupa razvoju	12
1.3 Scrum proces razvoja	14
1.3.1 Osnovni Scrum koncepti	15
1.3.2 Prioritetna lista funkcionalnosti	15
1.3.3 Sprint	16
1.3.4 Planiranje sprinta	17
1.3.5 Dnevni Scrum	18
1.3.6 Ažuriranje liste zadataka i grafa odra?enog posla	18
1.3.7 Sprint retrospektiva	19
1.4 Projektni tim i uloge	20
1.4.1 Voditelj proizvoda	21
1.4.2 Dizajner korisni?kog su?elja	21
1.4.3 Razvojni inženjer	22
1.4.4 Tester	23
1.4.5 Ostale uloge	23
1.5 Pitanja za provjeru znanja	26
1.6 Resursi za samostalan rad	26
2 Objektno orijentirani pristup razvoju	27
2.2 Java programski jezik	28
2.3 Tipovi podataka	29
2.3.1 Deklaracija, inicijalizacija i definicija varijabli	29
2.3.2 Numeri?ki tipovi podataka	30
2.3.3 Operacije nad numeri?kim tipovima	32
2.3.4 Evaluiranje izraza	32
2.3.5 Prelijevanje vrijednosti	33
2.3.6 Pretvorba tipova podataka	33
2.3.7 Znakovni tipovi podataka	33
2.4 Logi?ke strukture	34
2.4.1 Logika vo?ena doga?ajima	34
2.4.2 Slijed	36
2.4.3 Selekcija	37
2.4.4 Iteracija	40
2.5 Metode i svojstva	42
2.6 Objektno orijentirano programiranje	44
2.6.1 Ciljevi OOP-a	44
2.6.2 Koncept objekta i razumijevanje OOP-a	45
2.6.3 U?ahurivanje	46
2.6.4 Naslje?ivanje	47
2.6.5 Polimorfizam	49
2.6.6 Su?elje	51
2.7 Pitanja za provjeru znanja	54
2.8 Resursi za samostalan rad	54
3 Razvoj Android aplikacija	55
3.1 Integrirano razvojno okruženje	56
3.1.1 Klasifikacija razvojnih okruženja	56
3.1.2 Android Studio	57
3.1.3 Kreiranje novog projekta	59
3.2 Android SDK	61
3.2.1 Aplikacijski stog	61
3.2.2 Struktura SDK-a	62
3.2.3 Instaliranje Android API-a	63
3.3 Programska logika Android aplikacije	64
3.3.1 Android aktivnosti	65
Resursi	67
Kvalifikatori resursa	68

3.3.4 Android Manifest	69
3.3.5 Gradle	70
3.3.6 Namjera (Intent)	71
3.4 Alati Android Studija	72
3.4.1 Alati za razvoj	72
3.4.2 Alati za otkrivanje pogrešaka	74
3.4.3 Ostali važni alati	75
3.5 Pitanja za provjeru znanja	77
3.6 Resursi za samostalan rad	77
4 Rad s podacima	79
4.1 Pohrana podataka	80
4.1.1 Mogudnosti pohrane podataka	81
4.1.2 Klju?-vrijednost parovi	81
4.1.3 Korištenje parova klju?-vrijednost putem programskog kôda	81
4.1.4 Korištenje parova klju?-vrijednost prema predifinranim pravilima	83
4.2 Zapis podataka u datoteke	85
4.2.1 Primjer zapisivanja tekstualne datoteke na internu memoriju	87
4.2.2 ?itanje sadržaja datoteka	88
4.2.3 Primjer zapisivanja podataka na vanjsku memoriju	89
4.2.4 Brisanje datoteka	91
4.3 Rad sa mobilnom bazom podataka	92
4.3.1 Analiza potrebe zapisa podataka za CookBook mobilnu aplikaciju	92
4.3.2 Nativni pristup	95
4.3.3 ORM – Active Android	99
4.3.4 Kreiranje baze podataka putem Active Android biblioteke	100
4.4 Rad s web servisima	106
4.4.1 SOAP	107
4.4.2 REST	107
4.4.3 Korištenje REST servisa kod Androida	108
4.4.4 Retrofit i GSON	109
4.5 Pitanja za provjeru znanja	117
4.6 Resursi za samostalan rad	117
5 Primjer razvoja mobilne aplikacije	119
5.1 Memento	120
5.2 Kreiranje projekta	121
5.3 Izrada pogleda	124

5.3.1 Priprema dizajna glavne aktivnosti za tabove	124
5.3.2 Uvoz potrebnih ikona u projekt	127
5.3.3 Programsko dodavanje tabova i ikona	129
5.3.4 RecyclerView, prvi dio – priprema	130
5.3.5 Postavke jezika i eksternalizacija tekstova	135
5.3.6 RecyclerView, drugi dio – adapteri	138
5.4 Izrada entitetnih klasa	142
5.5 Unos i prikaz podataka – rad s dijalozima i fragmentima pogleda	148
5.6 Mobilna baza podataka	154
5.6.1 Unos, pohrana i prikaz podataka	161
5.7 Korištenje web servisa	169
5.7.1 Priprema za ispis podataka	170
5.7.2 Implementacija infrastrukture za rad sa web servisima	174
5.8 Pitanja za provjeru znanja	180
5.9 Resursi za samostalan rad	180
Rje?nik stru?nih pojmova	183
Popis kratica i akronima	187
Korištena literatura	189

1 UVOD U MOBILNI RAZVOJ

Razvoj mobilnog softvera (eng. mobile software development) ?ini složen skup aktivnosti koje provode ?lanovi projektnog tima u svrhu osmišljavanja, izrade, puštanja u rad te održavanja programskog proizvoda. Stoga, uvodno poglavlje ovog priru?nika ima za cilj predstaviti cjelokupnu sliku mobilnog razvoja kroz prikaz osnovnih pojmova kroz svaku od faza razvoja. Proces razvoja mobilnih aplikacija, promatran van konteksta poslovnog sustava, zapo?inje fazom razrade projektne ideje i definiranjem funkcionalnosti bududeg programskog proizvoda, nakon koje slijedi dizajn korisni?kog su?elja (izgleda) proizvoda, dizajn arhitekture i strukture proizvoda, izrada (programiranje), testiranje i kona?no puštanje u rad i održavanje. U ovom poglavlju ukratko su opisani svi navedeni koraci te uloge ?lanova tima.


SADRŽAJ POGLAVLJA
Razrada projektne ideje	6
Proces razvoja mobilnih aplikacija	10
Scrum proces razvoja	14
Projektni tim i uloge	20
Dodatni resursi	26


1.1 Razrada projektne ideje
Otvaranje mobilnih platformi, dostupnost materijala za samo-u?enje, jednostavna distribucija kreiranog softvera, kao i vrlo veliki broj mobilnih korisnika, kroz posljednjih 7 godina kreirali su izuzetno povoljnu klimu i uklju?ivanje velikog broja tvrtki i razvojnih inženjera u utrku za kreiranjem razli?itog mobilnog sadržaja, a u svrhu osvajanja što vedeg tržišnog udjela. Ved u prvom kvartalu 2016. godine na Google Play1 trgovini se nalazilo više od 2 milijuna2 aplikacija za Android ure?aje. Zbog toga je kvalitetna projektna ideja kao i kvalitetna razrada projektne ideje klju?na za uspjeh programskog proizvoda na ovako dinami?nom i turbulentnom tržištu.
Dva su osnovna pristupa generiranju projektne ideje - nesistematski i sistematski pristup a brojni su kriteriji koji mogu utjecati na odabir jednog ili drugog pristupa.
> nesistematski pristup se temelji na brzom definiranju projektnih zadataka bez prethodnog istraživanja i segmentacije tržišta ili pozicioniranja u tržišnu nišu. Ovakav pristup karakteristi?an je za pojedince koji „imaju genijalnu ideju“ i žele ju što prije spremiti za tržište. Naravno, korištenje nesistematskog pristupa nije preporu?ljivo, osim u slu?aju kada se projektna ideja ne generira u svrhu ostvarivanja profita ved u druge svrhe kao što su na primjer u?enje ili razvoj za vlastite potrebe.
> sistematski pristup, s druge strane, podrazumijeva provo?enje aktivnosti segmentacije tržišta i ciljanih korisnika u svrhu pronalaska tržišne niše koja još nije pokrivena i zasidena konkurentskim proizvodima. Ovaj pristup svakako ovisi i o domeni poslovanja tvrtke ili želji pojedinca da se bavi odre?enim podru?jem. Neke od tržišnih niša koje još uvijek nisu zasidene su na primjer zdravlje, ekologija, energetska u?inkovitost, poljoprivreda i sli?no. Sistematski pristup generiranju projektne ideje uklju?uje provedbu aktivnosti opisanih u sljededim poglavljima.
1.1.1 Odabir domene razvoja
Obi?no se prije samog procesa generiranja projektne ideje tvrtka ved odlu?ila za razvoj mobilne aplikacije ili mobilne igre. U ovom poglavlju, a i u ostalim poglavljima priru?nika, promatrat demo samo aktivnosti koje se odnose na razvoj mobilnih aplikacija, te razvoj mobilnih igara nede biti u našem fokusu. Ukoliko tvrtka ved nije specijalizirana za razvoj mobilnih aplikacija u specifi?nom podru?ju (domeni), onda je prva odluka koju treba donijeti upravo tržišno pozicioniranje i odabir domene razvoja. Pozicioniranje u bilo koju domenu zahtjeva posjedovanje domenskog znanja, što ovisno o ekspertizi uposlenika i suradnika tvrtke, može biti prednost ili nedostatak. Po rezultatima anketiranja3 razvojnih inženjera i tvrtki može se zaklju?iti da je izrada kvalitetnih rješenja u jednoj domeni bolja strategija od pokrivanja razli?itih domena razli?itim proizvodima. Neke od tržišnih niša koje još uvijek nisu zasidene mogu biti zdravlje, ekologija, energetska u?inkovitost, poljoprivreda i sli?no. Rezultat ove aktivnosti je definirana domena razvoja mobilnog proizvoda.
1.1.2 Analiza navika potroša?a i promjena navika
Proizvodi koji mijenjaju navike korisnika mogu naidi na otpor njihovom prihvadanju kod zna?ajnog broja populacije. S druge strane, upravo takvi proizvodi koji nude nove mogudnosti postaju privla?ni

1 https://play.google.com/
2 Izvor: Statista.com. Pristupano u lipnju 2016. na http://www.statista.com/statistics/266210/number-of- available-applications-in-the-google-play-store/
3 Izvor: Research2Guidance – App Strategy Advisory & Market Research. http://research2guidance.com/


mla?im korisnicima koji lakše prihvadaju promjene. Pravovremeno prepoznavanje novog trenda u navikama korisnika može donijeti zna?ajnu konkurentsku prednost. Ponekad je u provedbu ove aktivnosti potrebno uklju?iti i vanjske stru?njake u podru?ju marketinga ili psihologije koji su specijalizirani za ovakve analize. Rezultat ove aktivnosti daje temelje za generiranje inovativnih ideja koje služe postojedim navikama ili pak ideja koje imaju za cilj kreirati nove trendove u odabranoj domeni razvoja.
1.1.3 Analiza tehnoloških trendova i novih tehnologija
Tehnološki ciklus, to jest vrijeme od pojave, preko prihvadanja i kona?no zasidenja pojedinom tehnologijom, u posljednjih 5 godina je višestruko skraden. Iako brza tehnološka evolucija ima i nedostatke, ona donosi i brojne prednosti, a u kontekstu razvoja projektne ideje najvažnije je spomenuti, da pojava nove tehnologije „resetira“ tržište te ponovno otvara nove mogudnosti u svim domenama. Trenutno se nalazimo na po?etku životnog ciklusa više novih tehnologija od kojih valja izdvojiti proširenu stvarnost (eng. Augmented reality), Internet stvari (eng. Internet of things – IoT) i Internet svega (eng. Internet of Everything – IoE).
Proširena stvarnost predstavlja tehnološku inovaciju koja se odnosi na korištenje nosivih i mobilnih ure?aja koji korisniku dodatnim informacijama (tekst, slika, zvuk, vibracija i sli?no) dopunjuju informacije koje prima iz realnog svijeta. Tako na primjer, dok promatrate turisti?ku znamenitost nekoga grada, gledajudi kroz nao?ale s proširenom stvarnošdu (kroz koje znamenitost vidite vlastitim o?ima), vidite i virtualnog turisti?kog vodi?a koji stoji pored znamenitosti i pojašnjava ju iako ga fizi?ki tu nema.
S druge strane, Internet stvari predstavlja mrežu sa?injenu od fizi?kih objekata (stvari, ure?aja) stalno spojenih na Internet s kojeg mogu primati i slati podatke. Naj?ešde se koristi kako bi se opisalo skup fizi?kih ure?aja koji imaju mogudnost prikupljati podatke (pomodu senzora) i slati ih u centralnu bazu ili pak prikazati rezultat njihove obrade. Tako na primjer, svaki puta kada se približite semaforu na kojem je trenutno crveno svjetlo, vaš pametni sat na ruci može uklju?iti vibraciju kako bi vas upozorio da stanete. U ovom primjeru, sat zna smjer vašeg kretanja, komunicira sa semaforom, obra?uje informacije o trenutno uklju?enim svjetlosnim signalima i po potrebi obavještava korisnika.
Za razliku od Interneta stvari, Internet svega predstavlja mrežu sa?injenu od fizi?kih i nefizi?kih objekata (stvari, ure?aja, usluga, ljudi, ra?unalnih agenata, ugra?enih ure?aja….) stalno spojenih na Internet s kojeg mogu primati i slati podatke. Ostale karakteristike su sli?ne konceptu Internet stvari.
Rezultat aktivnosti analize tehnoloških trendova i novih inovacija daje uvid u nove tehnologije te popis onih novih tehnologija oko kojih se može graditi daljnje generiranje projektnih ideja u odabranoj domeni razvoja.
1.1.4 Odabir segmenta ciljanih korisnika
Ponekad je segment korisnika za koje želimo razviti aplikaciju ovisan o prethodno odabranoj domeni, a ponekad je potrebna dodatna analiza i odluka. Za pojedine skupine korisnika na tržištu još uvijek ne postoje kvalitetna rješenja koja zadovoljavaju njihove potrebe. Razmislite o mobilnim aplikacijama koje bi bila namijenjene isklju?ivo umirovljenicima, osobama s invaliditetom, vojnicima, lije?nicima, djeci, adolescentima, samohranim roditeljima, policajcima ili drugima. Rezultat ove aktivnosti je definiran segment korisnika za koje razvijamo projektno rješenje.
1.1.5 Definiranje potencijalnih ideja
Uzimajudi u obzir utvr?ene trendove, tehnologije, domenu razvoja i ciljane korisnike u ovom koraku je potrebno provesti aktivnost generiranja potencijalnih ideja. Svaka ideja se temelji na jednoj


klju?noj funkcionalnosti (eng. key feature) oko koje se definiraju pomodne i dodatne funkcionalnosti. Postoje razli?ite tehnike generiranja ideja, od koji su najpoznatije tehnike oluje mozgova (eng. Brain Storming). Tehnike iz obitelji oluje mozgova se temelje na brzom kreiranju velikog broja ideja od strane svih ?lanova projektnog tima, a nakon toga se vrši selekcija i odabir uz mogude dopune i izmjene originalno kreiranih ideja. Rezultat ove aktivnosti je kreirana lista potencijalnih ideja za razvoj mobilnog proizvoda pri ?emu je za svaku ideju definirana i klju?na funkcionalnost.
1.1.6 Analiza konkurentskih proizvoda
Za svaku ideju koja je prošla proces selekcije potrebno je napraviti analizu konkurentskih proizvoda na tržištu te utvrditi njihove nedostatke, kritike korisnika i mogudnosti kreiranja boljeg i kvalitetnijeg rješenja. Analizom tržišta za, na primjer, ideju kreiranja mobilne aplikacije za evidenciju osobnih financija, lako se može utvrditi da trenutno postoji više od 30 postojedih rješenja s korisni?kom bazom od ukupno više od stotinu milijuna korisnika (Slika 1). Me?utim, detaljnijom analizom, tako?er se može utvrditi da vedina tih rješenja ne koristi nove tehnologije, nema kvalitetno riješenu sinkronizaciju izme?u ?lanova obitelji, nema višerazinsku klasifikaciju kategorija potrošnje te da svakako postoji mogudnost njihovog poboljšanja. Rezultat ove aktivnosti je popis svih prednosti i nedostataka konkurentskih proizvoda za svaku projektnu ideju koja je u užem izboru.

Slika 1. Dio rezultata pretraživanja postoje?ih aplikacija na temu osobnih financija


1.1.7 Pronalazak vodede funkcionalnosti
Nastavno na aktivnost analize konkurentskih proizvoda, tijekom ove aktivnosti potrebno je definirati sve mogude funkcionalnosti promatranih projektnih ideja. Klju?ne funkcionalnosti i dio dodatnih funkcionalnosti su ved definirani u prethodnom koraku, ali sada, nakon što imamo uvid u ostale proizvode na tržištu, potrebno je zaokružiti projektnu ideju popisom svih funkcionalnosti i uklju?enih tehnologija. Poseban naglasak treba staviti na definiranje vodede (najvažnije) funkcionalnosti (eng. Kill feature), to jest funkcionalnosti koja ?ini razliku izme?u novog proizvoda i ostalih proizvoda na tržištu. Primjer popisa funkcionalnosti prikazan je u tablici (Tablica 1).




Tablica 1. Definiranje funkcionalnosti

KONKURENTSKI PROIZVODINOVI PROIZVODo evidencija prihoda
o evidencija rashoda
o kategorizacija prihoda
o kategorizacija rashoda
o planiranje potrošnje po kategorijama
o ponavljajude transakcije
o obavijesti o dospjelim obvezama
o izvješda
o sinkronizacija s više ure?aja* evidencija prihoda
* evidencija rashoda
* kategorizacija prihoda
* kategorizacija rashoda
* planiranje potrošnje po kategorijama
* ponavljajude transakcije
* obavijesti o dospjelim obvezama
* izvješda
* sinkronizacija s više ure?aja
+ višerazinska kategorizacija prihoda
+ višerazinska kategorizacija rashoda
+ rotacijski grafovi
+ analiza trendova
+ inteligentna analiza mogu?e uštede
+ opti?ko prepoznavanje (OCR) ra?una
+ NFC sinkronizacija
+ …

U navedenom primjeru možemo vidjeti kako je projektni tim odlu?io zadržati funkcionalnosti koje postoje u konkurentskim proizvodima, ali je tako?er definirao i set novih funkcionalnosti koje postojedi proizvodi ne sadržavaju. Vodeda funkcionalnost, koja bi trebala ?initi najvedu razliku na tržištu, te oko koje de se graditi i vedina budude marketinške kampanje i promocije proizvoda je mogudnost inteligentne analize mogude uštede kod korisnika. Na sli?an na?in potrebno je definirati funkcionalnosti i za ostale projektne ideje.
1.1.8 Kona?ni odabir projektne ideje
Uzimajudi o obzir rezultate svih prethodnih koraka projektni tim donosi kona?nu odluku te odabire proizvod s kojim de krenuti u proces implementacije. Neki od važnih faktora koje tijekom kona?nog odabira treba uzeti u obzir su:
* znanje i iskustvo projektnog tima u odabranoj domeni i s odabranim tehnologijama
* planirano vrijeme do objave proizvoda na tržište (eng. Planned time to market)
* potrebni ljuski, materijalni i nov?ani resursi
* potencijalnu zaradu od projektne ideje
* zasidenost tržišta i o?ekivani trendovi u ponašanju korisnika
* broj tehnoloških oštrica u promatranom proizvodu


S posebnom pozornošdu treba promotriti tehnološke oštrice. Pojam predstavlja elemente projektnog rješenja u kojima projektni tim nema iskustva, koji su potpuno novi na tržištu, neispitani i rizi?ni, ili jednostavno dijelove programskog proizvoda koje je s trenutnom razinom tehnologije teško riješiti. Za primjer, tehnološka oštrica može biti zahtjev da se u realnom vremenu sinkroniziraju podaci izme?u više mobilnih ure?aja. Ovaj zahtjev uklju?uje integraciju više razli?itih tehnologija


projektnom timu predstavlja izazov koji se još uvijek ne može riješiti bez kašnjenja od jedne do nekoliko sekundi.
Tek nakon analize svih ovih faktora projektni menadžment ili projektni tim mogu odabrati ideju koja mora biti motiviraju?a za projektni tim ali pri tome i izvediva u planiranom vremenu i s planiranim resursima i u kona?nici interesantna i korisna korisnicima. Koristedi neku od tehnika oluje mozgova projektni tim može za odabranu projektnu ideju definirati naziv proizvoda. S kona?no odabranom idejom projektni tim zapo?inje proces razvoja programskog proizvoda provodedi aktivnosti koje su opisane u sljededem poglavlju.

1.2 Proces razvoja mobilnih aplikacija
Razvoj mobilnog softvera (eng. Mobile software development) ?ini složen skup aktivnosti koje provode ?lanovi projektnog tima u svrhu osmišljavanja, izrade, puštanja u rad te održavanja programskog proizvoda. Proces razvoja mobilnih aplikacija, promatran van konteksta poslovnog sustava, zapo?inje fazom razrade projektne ideje i definiranjem funkcionalnosti bududeg programskog proizvoda, što je opisano u prethodnom poglavlju, a nakon koje slijedi dizajn korisni?kog su?elja (izgleda) proizvoda, dizajn arhitekture i strukture proizvoda, izrada (programiranje), testiranje i kona?no puštanje u rad i održavanje.
Osnovne definicije koje treba poznavati kako bi se razumio proces razvoja uklju?uju sljedede pojmove:
* Proces razvoja programskog proizvoda – je niz aktivnosti koji pretvara korisni?ke zahtjeve u programski proizvod [1]. U procesu razvoja korisni?ke potrebe se pretvaraju u strukturirane korisni?ke zahtjeve; zahtjevi u jasnu specifikaciju dizajna, koji se potom implementira u programski kôd; programski kôd se testira, te potom isporu?uje u obliku programskog proizvoda i pušta u uporabu.
* Metodika razvoja programskog proizvoda – predstavlja sistematiziran pristup u provedbi procesa razvoja. Prema SWEBOK-u, odabir prikladne metodike može imati zna?ajan utjecaj na uspjeh cjelokupnog projekta razvoja [2]. Metodiku razvoja programskog proizvoda možemo definirati kao okvir po kojem se strukturira, planira i kontrolira proces razvoja programskog proizvoda, a koji uklju?uje unaprijed definirane elemente isporuke i ostale artefakte koji su kreirani od strane projektnog tima u svrhu razvoja i održavanja proizvoda [3]. Projektni timovi mogu imati razli?ite pristupe u provedbi okvira definiranog metodikom razvoja.
1.2.1 Faze procesa razvoja
Kako bi smo lakše razumjeli sljededa poglavlja priru?nika, u ovom poglavlju prikazat demo generi?ki pristup u razvoju programskih proizvoda kroz prikaz osnovnih faza u procesu razvoja. Prema Elliotu (2004) najstariji formalizirani pristup razvoju je SDLC pristup (eng. Systems Development Life Cycle) [4]. Spomenuti pristup je bio fazno orijentiran i sadržavao je sljedede osnovne faze:




Slika 2. Pojednostavljenje SDLC modela
Faza inicijacije predstavlja aktivnosti inkubacije i promišljanja projektne ideje. Tijekom inicijacije uspostavljaju se prvi kontakti izme?u investitora i projektnog tima. Tijekom faze razvoja koncepta proizvoda provodi se analiza tržišta i bududem mobilnom proizvodu se definiraju osnovne funkcionalnosti. Ova faza je detaljno opisana u prethodnom poglavlju. Faza planiranja se odnosi na aktivnosti projektnog menadžmenta, a faza analize zahtjeva predstavlja detaljnu analizu svih korisni?kih zahtjeva iz kojih se radi arhitekturni i strukturni dizajn programskog proizvoda. Slijede faze razvoja u kojoj se razvijaju moduli programskog proizvoda, integracije u kojoj se moduli spajaju te testiranja u kojoj se testira gotov proizvod. U kona?nici proizvod se održava objavom novih verzija te na kraju uklanja s tržišta.
Sve navedene SDLC faze mogu se grupirati u ?etiri osnove faze koju se primjenjive i na razvoj mobilnih aplikacija. Daljnje analize u ovom priru?niku demo temeljiti kroz ?etiri osnovne faze razvoja softvera: konceptualno modeliranje – faza osmišljavanja ideje i projekta razvoja programskog proizvoda, specifikacija i dizajn – faza detaljne specifikacije funkcionalnosti i izgleda programskog proizvoda, implementacija – faza izrade i testiranja programskog proizvoda, korištenje – faza isporuke, korištenja i održavanja programskog proizvoda.
1.2.2 Klasifikacija metodika razvoja
Iako je prva verzija SWEBOK standarda [5] definirala tri osnovne skupine koncepata za sistematizaciju metodika razvoja, u novoj verziji, koja je još uvijek u procesu izrade [2] sve metodike možemo promatrati kroz koncepte koji ih svrstavaju u jednu ili više sljededih skupina: metodike temeljene na iskustvu, formalne metodike, metodike prototipiranja i agilne metodike razvoja.
* Heuristi?ke metodike – metodike softverskog inženjerstva temeljena na iskustvu. ?esto se koriste u praksi, a dijelimo ih na metodike temeljene na strukturnoj analizi i dizajnu, metodike temeljene na podatkovnom modeliranju, te metodike temeljene na objektno orijentiranom dizajnu i analizi.
* Formalne metodike – metodike softverskog inženjerstva temeljene na rigidnim matemati?kim notacijama i jezicima. Koriste se za razvoj visoko zahtjevnih sustava te nisu ?esto primjenjivane u mobilnom razvoju.
* Metodike prototipiranja – metodike temeljene na pristupu kreiranja nedovršenih proizvoda ili proizvoda s minimalnom funkcionalnošdu, naj?ešde u svrhu isprobavanja tehnoloških


oštrica ili implementacije zahtjeva. Temeljem kreiranog prototipa može se dobiti povratna informacija na kvalitetu ispunjenosti zahtjeva, korisni?kog su?elja, dizajna i/ili drugih teško razumljivih aspekata proizvoda. Obi?no, prototip ne postaje kona?ni proizvod bez zna?ajnih dorada.
* Agilne metodike – metodike razvoja nastale 1990-tih godina iz potrebe smanjenja velikog dodatnog posla povezanog s provedbom zahtjevnih i detaljnih metodika razvoja. Agilne metodike su jednostavne metodike koje se temelje na kratkim iterativnim razvojnim ciklusima, timovima koji se samo-organiziraju, jednostavnom dizajnu, u?estalom refaktoriranju kôda, razvoju vo?enom testiranjem, uklju?enosti korisnika te naglasku na kreiranju verzije proizvoda koja ima nove funkcionalnosti spremne za isporuku na kraju svakog razvojnog ciklusa.
Spomenute skupine nisu disjunktne, što zna?i da ista metodika razvoja, može pripadati jednoj ili više skupina. Tako na primjer, objektno orijentirana heuristi?ka metodika može biti agilna, formalna ili se pak temeljiti na prototipiranju.
1.2.3 Klasifikacija pristupa razvoju
Pristupi razvoju mogu biti grupirani temeljem više razli?itih kriterija. U razvoju mobilnih programskih proizvoda posebno su zanimljive klasifikacije temeljem razvojnog ciklusa i temeljem osnovnog modela. Tako, uzimajudi u obzir razvojni ciklus, to jest provedbu faza razvoja i njihovog redoslijeda pristupi razvoju mogu biti:
* fazno orijentiran pristup – pristup u kojem je svaka faza provedena samo jednom tijekom cjelokupnog procesa razvoja. Prije prelaska na sljededu fazu provodi se verifikacija (provjera u skladu sa specifikacijom) i validacija (korisni?ka provjera) kreiranih rezultata trenutne faze.









Iteracije:

Slika 3. Fazno orijentirani pristup


* djelomi?no inkrementalni pristup - pristup u kojem se nekoliko faza razvoja provodi više puta
- inkrementalno, a set po?etnih faza se obi?no provodi samo jedanput kao u fazno orijentiranom pristupu. Postoji više varijanti ovog modela u kojima variraju faze koje se ponavljaju.




Slika 4. Djelomi?no inkrementalni pristup


* inkrementalni pristup – pristup u kojem se cjelokupna funkcionalnost mobilnog programskog proizvoda kreira i isporu?uje iterativno i inkrementalno. Kreirani modeli i funkcionalnost evoluiraju i poboljšani su svakim inkrementom.


Slika 5. Inkrementalni pristup


S druge strane, promatrajudi osnovni model koji se koristi kako bi se definirao proizvod, pristupi razvoju mogu biti: funkcijsko (procesno) orijentirani pristupi koji definiraju da je specifikacija funkcionalnosti temeljni model, podatkovno orijentirani pristupi koji definiraju da je model podataka temeljni model, te objektno orijentirani pristupi koji promatraju objekte i modele objekata kao temeljene modele. Objektni model u osnovi objedinjuje i procesni/funkcijski i podatkovni model u objekt, koji pak mogu biti korišteni kako bi se kreirali stati?ki i dinami?ki modeli sustava.
Zbog specifi?nosti mobilnog razvoja, razmjerno mali broj tvrtki još uvijek koristi klasi?ni (tradicionalni, naj?ešde fazni) pristup razvoju mobilnih programskih proizvoda, a velika vedina tvrtki koristi agilni razvoj (naj?ešde inkrementalni) koji ima naglasak na kona?nom proizvodu, zadovoljnom korisniku i fleksibilnosti, pri tome stavljajudi u drugi plan stroge ugovore i projektne planove, opširnu dokumentaciju i tromo odgovaranje na zahtjeve za promjenama.


U praksi naj?ešde korišten predstavnik agilnih metodika razvoja je Scrum metodika. U sljededem poglavlju prikazane su smjernice Scruma koji definira kako organizirati projektni tim i kako iterativno provesti proces razvoja mobilnog programskog proizvoda.

1.3 Scrum proces razvoja
Scrum je agilna metodika razvoja programskih proizvoda koju su kreirali Ken Schwaber i Jeff Sutherland [6]. Rije? je o definiranom pristupu koji sadrži mali set praksi i preddefiniranih uloga i kao takav je postao de-facto standard kod agilnog razvoja. Bududi da sadrži jako malo praksi, može ga se primijeniti na razli?ite situacije, ali zbog toga Scrum naj?ešde nije dostatan, te projektni timovi i tvrtke ponekad primjenjuju i prakse „preuzete“ iz drugih agilnih metodika, kao što je na primjer Ekstremno programiranje. Za detalje o ekstremnom programiranju možete konzultirati [7].
Web mjesto Scrum.org pruža razli?ite mogudnosti u?enja Scrum procesa. Tako?er, originalni vodi?
„The Scrum Guide“ [6] je ažuriran svake godine, i može ga se koristiti za po?etak u?enja Scruma. Kona?no, ved spomenuti priru?nik Jeffa Sutherlanda [8] tako?er sadrži sve što je potrebno znati kako bi se po?elo s primjenjivanjem Scrum praksi. Osim navedenih, postoji jako puno drugih materijala, knjiga, ?lanaka, vodi?a, prezentacija i priru?nika koje možete konzultirati za proširenje znanja.
Poglavlja koja slijede temeljena su i imaju preuzete materijale iz Priru?nika Jeffa Sutherlanda [8], osim ako je to navedeno eksplicitnom referencom na drugi izvor.

Slika 6. Scrum proces


1.3.1 Osnovni Scrum koncepti
Scrum je iterativni i inkrementalni okvir za razvoj programskih proizvoda. Timovi koji koriste Scrum navode zna?ajna poboljšanja u produktivnosti i motivaciji. Jedna od razloga tome je i ?injenica da Scrum poznaje samo tri „uloge“ ?lanova projektnog tima: vlasnik proizvoda (eng. Product Owner), Scrum majstor (eng. Scrum Master) i projektni tim. Vlasnik proizvoda može biti investitor, naru?itelj ili voditelj proizvoda (eng. Product Manager). Scrum majstor je odgovoran za Scrum te obavlja sve aktivnosti potrebne da bi Scrum funkcionirao. Tu ulogu obi?no obavlja projektni menadžer ili voditelj tima, me?utim važno je spomenuti da on u Scrumu nema nadre?enu ulogu u odnosu na ostatak projektnog tima, ved ima ulogu uklanjanja prepreka koje usporavaju ili zaustavljaju projekt, ili pak nedozvoljavaju provedbu Scrum praksi. Projektni tim ima 5 do 10 ?lanova, koji pokrivaju razli?ita podru?ja (interdisciplinaran je) uklju?ujudi razvojne inženjere, dizajnere korisni?kog su?elja, testere i druge [9].
Projektne funkcionalnosti su definirane kroz listu zadataka to jest željenih funkcionalnosti projekta (eng. Project Backlog). Ova lista ne treba nužno biti detaljna niti u potpunosti opisana, ved se temelji na željama korisnika ili naru?itelja. Listu kreira vlasnik proizvoda koji ujedno definira prioritete zadataka, to jest sortira funkcionalnosti od onih koje su mu najvažnije do onih koje su najmanje važne i mogu biti implementirane na kraju procesa [9].
Scrum, kako je prikazano (Slika 6), cjelokupni proces razvoja dijeli u razvojne cikluse koji se nazivaju Sprintovi (eng. Sprint). Te iteracije su krade od mjesec dana, a obi?no se mjere u tjednima. Sprintovi se izvršavaju jedan iza drugoga, te svaki sprint ima fiksno trajanje – što zna?i da završavaju na planirani datum, bez obzira jesu li svi zadaci ispunjeni ili ne. Trajanje sprinta se nikad ne produžuje.
Na po?etku svakog sprinta, interdisciplinarni tim odabire funkcionalnosti (korisni?ke zahtjeve) iz prioritizirane liste svih zadataka projekta. Tim namjerava završiti sve odabrane funkcionalnosti do kraja sprinta i dat de sve od sebe kako bi to i postigao. Odabrani zadaci, to jest postavljeni cilj, se tijekom sprinta ne mijenjaju, a svakoga dana tim se okuplja na kratkom dnevnom sastanku na kojem se može donijeti novi plan ili reorganizirati tim kako bi se povedala vjerojatnost uspješnog završetka sprinta. Na kraju svakog sprinta naru?itelju se prezentiraju nove funkcionalnosti, nakon ?ega slijedi
„privatni“ retrospektivni sastanak kako bi se analizirao sprint, izvukle pouke i povratne informacije u svrhu poboljšanja sljededih sprintova.
Scrum stavlja naglasak na proizvod koji na kraju sprinta ima dovršene funkcionalnosti. U smislu mobilnog razvoja dovršena funkcionalnost mora biti:
* integrirana u postojede rješenje
* potpuno testirana
* potencijalno isporu?iva.
1.3.2 Prioritetna lista funkcionalnosti
Prioritetna lista funkcionalnosti (eng. Product Backlog) predstavlja popis svih željenih funkcionalnosti programskog proizvoda sortiranih sukladno prioritetima isporuke, kako ih vidi vlasnik proizvoda. Važno je naglasiti da ova lista funkcionalnosti evoluira tijekom provedbe projekta, pri ?emu vlasnik može dodavati, brisati ili druga?ije sortirati stavke. Tako?er, projektni tim nakon svakog Sprinta dopunjava listu novom procjenom potrebnog napora za implementaciju pojedinih zahtjeva. Uvijek postoji samo jedna lista željenih funkcionalnosti što tjera vlasnika proizvoda da definira prioritete promatrajudi sve funkcionalnosti mobilnog programskog proizvoda.





Slika 7. Lista funkcionalnosti proizvoda (eng. Product Backlog)
Scrum ne propisuje formu niti na?in procjene preostalog napora u listi funkcionalnosti, ali je uobi?ajeno koristiti relativne procjene izražene u „poenima“ u odnosu na apsolutne procjene kao što su na primjer „?ovjek mjeseci“. Osnovni razlog tome je što tijekom vremena „poeni“ mogu rasti (ukoliko tim procijeni da treba više napora za dovršetak funkcionalnosti) ili padati.
Stavke prioritetne liste zadataka mogu zna?ajno varirati u veli?ini ili potrebnom naporu. Pri tome se zahtjevnije stavke razbijaju na jednostavnije tijekom 2. sastanka projektnog tima za Sprint. Tako?er se, tijekom istog sastanka, izrazito jednostavne funkcionalnosti mogu okupiti u jedan zadatak.
1.3.3 Sprint
Scrum strukturira razvoj programskog proizvoda u iteracije koje se nazivaju sprintovi. Te iteracije su tipi?nog trajanja od 1 do 4 tjedna. Sprintovi imaju fiksno trajanje, nikad se ne produžuju, te završavaju na planirani datum neovisno o uspješnosti ispunjenja uklju?enih zadataka.

Slika 8. Detaljan Scrum proces [8]


1.3.4 Planiranje sprinta
Kako je prikazano na slici (Slika 8), aktivnosti planiranja sprinta provode se na po?etku svake iteracije, ali prije po?etka samog sprinta. Vlasnik proizvoda i Scrum tim (uz pomod Scrum majstora) tijekom prvog (1.) sastanka prolaze kroz cjelokupnu prioritiziranu listu funkcionalnosti proizvoda, analiziraju ciljeve i kontekst stavki liste, definiraju kona?nu željenu funkcionalnost, te Scrum tim odabire one stavke liste koje, sukladno željama vlasnika, ali i tehni?kim mogudnostima koje ovise o izra?enoj infrastrukturi proizvoda, može implementirati do kraja sprinta. Popis odabranih funkcionalnosti za novi sprint se naziva lista zadataka sprinta (eng. Sprint Backlog). Tijekom ovog prvog sastanka, vlasnik proizvoda ima klju?nu ulogu, a cilj sastanka je u potpunosti shvatiti želje vlasnika proizvoda.
Drugi sastanak tima (Slika 8) fokusira se na detaljno planiranje svih zadataka koje je potrebno obaviti u svrhu implementacije svih funkcionalnosti uklju?enih u sprint. Pri tome se detalji upisuju u kreiranu listu zadataka sprinta (Slika 10). Ovaj sastanak ne bi trebao trajati duže od jednog sata za svaki tjedan planiranog trajanja sprinta. Drugi važan zadatak ovog sastanka je definiranje vremenskog okvira i kapaciteta projektnog tima (Slika 9).

Slika 9. Definiranje vremenskih kapaciteta
U ovoj fazi je mogude uklju?iti u listu dodatne funkcionalnosti ili ?ak maknuti neke od odabranih funkcionalnosti s glavne liste, ukoliko se utvrdi da tim ima višak kapaciteta ili pak u drugom slu?aju nema dovoljno kapaciteta za provedbu svih potrebnih zadataka. Popis detaljnih zadataka, ali ne i popis funkcionalnosti, može biti izmijenjen tijekom same provedbe sprinta, to jest ?ak i kada ?lanovi tima zapo?nu implementaciju. Redoslijed implementacije funkcionalnosti i provedbe definiranih zadataka nije bitan, ved se tim prilago?ava specifi?nim okolnostima i pokušava identificirati me?uodnose funkcionalnosti, a sve u cilju maksimiziranja produktivnosti i kvalitete.

Slika 10. Primjer liste zadataka sprinta


Kona?no, tijekom ovog sastanka ?lanovi tima volonterski odabiru zadatke koje preuzimaju na sebe. Zbog predanosti Scrumu, ne može se dogoditi da neki od zadataka ostane ne odabran od nekog ?lana tima.
1.3.5 Dnevni Scrum
Nakon po?etka sprinta, tim provodi još jednu od klju?nih Scrum praksi: dnevni Scrum, to jest dnevne kratke sastanke. Rije? je o 15-minutnim sastancima koji se održavaju svakog radnog dana u unaprijed dogovoreno vrijeme. Sastancima prisustvuju svi ?lanovi tima i prezentiraju informacije potrebne kako bi se utvrdio napredak projekta. Nova procjena preostalog napora po zadacima se upisuje u Sprint listu zadataka (Slika 11). Ako je potrebno, tim može organizirati sastanak (odmah nakon dnevnog Scruma) i napraviti izmjene u planu sprinta ili realocirati dodijeljene zadatke ?lanovima tima.

Slika 11. Dnevno ažuriranje Sprint liste zadataka
Kako bi dnevni Scrum sastanci bili što kradi, preporuka je da ?lanovi tima ostanu stajati, a tijekom 15- minuta cijeli tim, vrlo kratko, prezentira tri (i samo tri) teme: (1) Što su uspjeli napraviti od ju?erašnjeg sastanka; (2) Što planiraju napraviti tijekom dana; i (3) imaju li kakve probleme i prepreke u realizaciji. Tijekom dnevnog Scruma nema diskusije. Naravno, važno je naglasiti da ovo nije jedina komunikacija izme?u ?lanova tima (koji me?usobno komuniciraju tijekom cijelog radnog dana, ali sa specifi?nim temama vezanim uz izvršenje zadataka), niti se radi o izviješdu voditelju projekta (koji niti ne postoji u Scrumu), ved se radi o na?inu razmjene informacija izme?u ?lanova tima, te po potrebi prilago?avanju tima novim okolnostima. Kako je ved spomenuto, ako se pojavi potreba za diskusijom, tim organizira sastanak odmah nakon dnevnog Scruma.
1.3.6 Ažuriranje liste zadataka i grafa odra?enog posla
Kako se lista zadataka, a posebno preostalog napora za njihovo izvršenje, ažurira svaki dan, projektni tim tako?er vodi evidenciju ukupno odra?enog/preostalog posla koja se prikazuje pomodu posebnog grafi?kog prikaza (eng. Burndown chart). Ovaj graf (Slika 12) na dnevnoj razini prikazuje novu procjenu preostalog napora do završetka svih zadataka. Idealno, rije? je o konstantno silaznom trendu koji je na putu da do kraja sprinta dosegne „nulu“ to jest da prikaže da su zadaci implementirani te da nema potrebe za novim naporom. Ako linija trenda ne slijedi planiranu putanju, Scrum majstor bi trebao poduzeti mjere (promijeniti pristup, ukloniti prepreke, zatražiti pomod drugih stru?njaka, smanjiti obim posla..) na vrijeme (što je prije mogude) kako ne bi dopustio da Sprint završi neuspjehom.






1.3.7 Sprint retrospektiva

Slika 12. Grafi?ki prikaz preostalog posla

Po završetku sprinta i prezentaciji implementiranih funkcionalnosti korisniku, Scrum tim provodi sastanak na kojem se zajedno sa svim zainteresiranim stranama analizira i diskutira provedeni sprint, te se dogovara daljnja strategija razvoja. Na sastanku mogu prisustvovati vlasnik proizvoda, Scrum majstor, ?lanovi tima, korisnici, stru?njaci i bilo tko drugi zainteresiran za projekt i/ili njegove rezultate (eng. Stakeholders).
Odmah nakon ovog sastanka, Scrum tim se okuplja na retrospektivni sastanak kako bi se prodiskutiralo ono što jest i što nije funkcioniralo tijekom samog sprinta, te kako bi projektni tim izvukao pouku za sljedede iteracije, te dogovorio promjene koje de pokušati uvesti.

Slika 13. Ažurirana lista funkcionalnosti i prioriteta
Kako su u ovom trenutku neke stavke prioritetne liste ved dovršene, potrebno je evidentirati nove procjene za dovršenje preostalih stavki (Slika 13). Neki timovi imaju i grafi?ki prikaz preostalog posla na cijelom projektu, koji je svojom svrhom i formom identi?an spomenutom grafu preostalih zadataka sprinta. Slijedom analize sprinta i retrospektive, vlasnik proizvoda može ažurirati i listu zadataka s dodavanjem, promjenom i/ili brisanjem postojedih funkcionalnosti. Bududi da su svi


spremni za po?etak novog ciklusa razvoja nema potrebe za bilo kakvim ?ekanjem izme?u dvaju sprintova, te planiranje novog sprinta može po?eti ved sljedede radno jutro.

1.4 Projektni tim i uloge
Kao i u svakoj drugoj industriji, tako i u industriji razvoja mobilnih aplikacija postoji široki spektar uloga, odgovornosti i ekspertize koju treba projektni tim kako bi kvalitetno osmislio i izradio programski proizvod. U prethodnom poglavlju smo opisali Scrum proces, ali projektni tim smo promatrali kao „crnu kutiju“ te nismo navodili detalje o ekspertizi i ulogama ?lanova tima. U ovom poglavlju, pokušat demo prikazati projektni tim i njegove uloge u uobi?ajenim okolnostima razvoja, te demo navesti i ostale uloge koje mogu biti neophodne u implementaciji specifi?nih projekata. Popis poslova projektnog tima iznesenog u ovom poglavlju dat de vam smjernice o mogudim specijalizacijama u vlastitom profesionalnom razvoju.
Vedina projektnih timova sastavljena je od dva do ?etiri ?lana koji obavljaju sve projektne aktivnosti. Minimalno, projektni tim mora sadržavati razvojnog inženjera, dizajnera korisni?kog su?elja i voditelja proizvoda. Naravno, ponekad sve te aktivnosti obavlja jedna osoba, ali tada ne možemo govoriti o timu.
Stoga, kako je prikazano u tablici ispod (Tablica 2), sve uloge u projektnom timu možemo podijeliti u dvije skupine: osnovne uloge i ostale uloge. Osnovne uloge su voditelj projekta, dizajner korisni?kog su?elja, razvojni inženjer (popularno zvani programer) te tester odnosno osoba zadužena za osiguranje kvalitete. Ostale uloge se javljaju u vedim timovima, u dobro organiziranim tvrtkama, te ovise o veli?ini i tipu projekta. Od ostalih uloga valja izdvojiti voditelja projekta, arhitekta, voditelja razvoja, marketinškog stru?njaka, administratora baze podataka, programera pozadinskih servisa te naravno stru?njaka iz domene kojom se bavi mobilna aplikacija.
Tablica 2. Uloge ?lanova projektnog tima

Osnovne ulogeOstale uloge, ovisno o veli?ini i tipu projekta* Voditelj proizvoda
(eng. Product manager)

* Dizajner korisni?kog su?elja
(eng. Interface Designer)

* Razvojni inženjer
(eng. Developer)

* Provjera kvalitete, Tester (eng. Quality Assessor, Tester)* Voditelj projekta (eng. Project Manager)
* Arhitekt rješenja (eng. Solution Architect)
* Analiti?ar funkcionalnosti (eng. Functional Analyst)
* Projektant portabilnosti (eng. Portability Planner)
* Upravitelj razvoja (eng. Development Manager)
* Voditelj razvoja (eng. Development Lead)
* Upravitelj verzijama (eng. Release Manager)
* Voditelj kvalitete (eng. Quality Lead)
* Projektant implementacije (eng. Deployment Planner)
* Implementator (eng. Deployment Publisher)
* Marketinški stru?njak (eng. Marketing Expert)
* Analiti?ar potreba obuke (eng. Training requirement analyser)
* Trener (eng. Trainer)
* Arhitekt baze podataka (eng. Database Architect)
* Programer baze podataka (eng. Database Programmer)
* Administrator baze podataka (eng. Database Administrator)
* Priprema podataka (eng. Data Populator)
* Arhitekt pozadinskih servisa (eng. Backend Service Architect)
* Razvojni inženjer pozad. servisa (eng. Backend Developer)
* Domenski stru?njak (eng. Subject Matter Expert)



U malim timovima, ?lanovi koji imaju osnovne uloge zastupljeni su tijekom cjelokupnog procesa razvoja, me?utim u pojedinim fazama se stavlja naglasak na jednu ili drugu ulogu (Slika 14). Voditelj proizvoda, iako prisutan u svim fazama razvoja, vrlo važnu ulogu ima tijekom faze konceptualnog modeliranja, pa i tijekom faze dizajna, kako bi se osiguralo da vizija koju ima o programskom proizvodu bude jasno prenesena svim ?lanovima tima te preto?ena u nedvosmislene specifikacije. S druge strane, marketinški stru?njak, iako bitan i u fazi razvoja ideje, posebnu ulogu ima u fazi pripreme distribucije i distribucije samog proizvoda.
Detaljan opis svih osnovnih uloga i kratak opis važnih ostalih uloga dan je u sljededim poglavljima.
1.4.1 Voditelj proizvoda
U užem smislu rije?i, voditelj proizvoda (eng. Product manager) je u smislu provedbe projektnih aktivnosti najodgovornija osoba u projektnom timu koja pretvara viziju u konkretan mobilni proizvod. U Scrum timovima, voditelj proizvoda je zapravo vlasnik proizvoda, to jest osoba koja je odgovorna za (ne)uspjeh projekta, povratak investiranih sredstava, brzo postizanje to?ke pokrida i zarade. U malim tvrtkama, voditelj proizvoda ima ulogu direktora (eng. Chief Executive Officer – CEO). Važna uloga voditelja proizvoda je poznavanje svih aspekata projekta te rad na uklanjanju prepreka i definiranju strategije postizanja zadanih ciljeva. Voditelj proizvoda bi trebao imati znanje i ekspertizu iz razli?itih podru?ja, a neka od njih su vo?enje, osnove razvoja mobilnih proizvoda, kratkoro?no i dugoro?no planiranje, korisni?ko iskustvo, upravljanje klijentima pa ?ak i marketing.

Slika 14. Fokus na ulogama po fazama razvoja


1.4.2 Dizajner korisni?kog su?elja
Dva su osnovna zadatka dizajnera korisni?kog su?elja (eng. Designer). On vodi ra?una o izradi jasnog i jednostavnog korisni?kog su?elja (eng. User Interface – UI) u skladu s preporukama i trendovima u odabranoj mobilnoj platformi te pazi na postizanje visoke razine zadovoljstva u korisni?kom iskustvu (eng. User Experience – UX). Proizvod koji ima lijepo i privla?no korisni?ko su?elje (UI) ne mora nužno biti dobar u kontekstu korisni?kog iskustva (UX). Naime, za dobro korisni?ko iskustvo, proizvod mora biti intuitivan, lako navigabilan, prikladno dizajniran za ciljane korisnike, te mora omoguditi korisniku da u svakom trenutku zna gdje se nalazi, kako se može vratiti na po?etni zaslon te gdje de ga svaka akcija dovesti.


Primjer nedostatka u navigaciji možemo pronadi u najpopularnijoj svjetskoj mobilnoj aplikaciji za u?enje stranih jezika – Duolingo4. Aplikacija je preuzeta više od 50 milijuna puta, te ima mobilnu ina?icu za sve popularne mobilne platforme, kao i web ina?icu. Dizajner korisni?kog su?elja je u ovoj aplikaciji napravio odli?an posao u smislu UI-a, primijenio je posljednje trendove dizajna Android aplikacija, kao što je Material dizajn (uklju?ujudi primjenu koncepata kao što su prijelazi, animacije, osvjetljenje, sjene i drugo) te je osnovnu navigaciju osmislio kroz primjenu klasi?ne ViewPager5 kontrole koja omoguduje tranziciju izme?u tri osnovna pogleda: Learn, Friends i Shop ().

Slika 15. Duolingo design
Me?utim, stranicu za u?enje korisnici intuitivno smatraju osnovnom po?etnom stranicom aplikacije, te nakon prelaska na pomodne stranice za pregled napretka u u?enju prijatelja (Friends) ili za kupovinu unutaraplikacijskih proizvoda (Shop), intuitivno o?ekuju da funkcionalnost hardverske tipke za povratak u natrag (eng. Back) ponovno prikaže po?etnu stranicu, što nije slu?aj. Naprotiv, aplikacija se zatvara. Naravno, ovaj mali nedostatak ne utje?e zna?ajno na korisni?ko iskustvo, ali može biti pokazatelj o kakvim sve detaljima dizajner korisni?kog su?elja treba paziti.
U kona?nici, uloga dizajnera u tvrtki može biti i pomod u kreiranju branda od mobilnog proizvoda ili od cijele tvrtke, kreirajudi logo, dizajn web stranice, promotivnih materijala i filmova te reklama, što sve obi?no radi u suradnji s marketinškim stru?njakom.
1.4.3 Razvojni inženjer
Popularan kolokvijalni naziv za razvojnog inženjera je programer – što je doslovan prijevod s engleskog jezika (eng. Programmer) koji se toliko uvriježio u svakodnevni jezik da demo ga i mi koristiti u ovom kratkom poglavlju. Programeri su zaduženi za razvoj i implementaciju mobilnog programskog proizvoda koristedi dogovorene razvojne okoline i programske jezike. Za razliku od programera pozadinskih servisa koji moraju imati znanje u web tehnologijama, programeri Android aplikacija naj?ešde pišu programski kôd u specifi?nom razvojnom okruženju, Android Studiju, te

4 https://www.duolingo.com/
5 Ova kontrola i ostale kontrole korisni?kog su?elja opisane su u posebnom poglavlju ovoga priru?nika.
22


koriste Java programski jezik. Velik dio ovog priru?nika stavlja naglasak upravo na ove dvije tehnologije.
Programeri su odgovorni za implementaciju dogovorene arhitekture, te za implementaciju i integraciju pojedina?nih modula u cjelokupno rješenje. Nerijetko, pojedini moduli moraju komunicirati sa drugim sustavima, te ulogu njihovog spajanja tako?er imaju programeri. Iako su sve uloge važne, programeri naj?ešde doprinose cjelokupnom rješenju s najviše uloženog posla i truda.
1.4.4 Tester
Sistematsko testiranje je jedna od naj?ešde zapostavljenih, a važnih aktivnosti. Zabludom, projektni timovi smatraju da je dovoljno testiranje koje provode razvojni inženjeri tijekom samog pisanja programskog kôda. Takav pristup naj?ešde dovodi do pogrešaka koje otkrivaju korisnici, što utje?e na lošu reputaciju programskog proizvoda.

Slika 16. Primjer rezultata automatiziranog testiranja
S druge strane, testeri (eng. Tester) provode sistematsko testiranje programskog kôda, a potom i programskog proizvoda provodedi niz automatiziranih, polu-automatiziranih i manualnih testova. Neki od zna?ajnih testova koji se provode tijekom faze razvoja su jedini?ni testovi (Slika 16), funkcionalni testovi, integracijski testovi, sistemski testovi, stres testovi te testovi prihvatljivosti. U Androidu postoji više gotovih okvira pomodu kojih se mogu pisati automatizirani ili polu- automatizirani testovi a neki od njih su Android Test Framework, Robotium i drugi.
Dizajn, pisanje i provo?enje ovih testova te osiguranje kvalitete programskog proizvoda (eng. Quality Assurance – QA) osnovna su zadada testera.
1.4.5 Ostale uloge
U ovisnosti o veli?ini i vrsti projekta, pri razvoju mobilnih programskih proizvoda javljaju se i druge bitne uloge sa specifi?nim zadacima i znanjima. Detaljan popis svih uloga dan je u ved spomenutoj tablici (Tablica 2), a podebljano su prikazane važnije uloge prisutne u svakoj ozbiljnoj tvrtki koja se bavi razvojem mobilnog softvera. Osim osnovnih uloga pobrojanih u prethodnom poglavlju, ovdje prikazujemo druge važne uloge ?lanova projektnog tima.
Za vježbu, razvrstajte sve uloge ?lanova projektnog tima pobrojanih u spomenutoj tablici u sljededa podru?ja koja pokrivaju: projektni menadžment, dizajn programskog proizvoda, razvoj programskog


proizvoda, testiranje, objava/isporuka, marketing, obuka korisnika, upravljanje podacima, razvoj pozadinskih servisa, poznavanje domene.
Voditelj projekta (eng. Project Manager) – Voditelj projekta za razliku od voditelja proizvoda ima nadre?enu ulogu u projektnom timu te je direktno odgovoran za planiranje, provedbu i izvješdivanje o projektnim aktivnostima. Voditelj projekta koristi alate i tehnike projektnog menadžmenta u obavljanju svojih aktivnosti te kako bi u definiranom vremenu, s dostupnim resursima implementirao željene funkcionalnosti. Po potrebi vrši restrukturiranje projektnog tima te promjenu uloga ?lanova tima.
Arhitekt rješenja (eng. Solution Architect) – Arhitekt rješenja ima odgovornost u osmišljavanju i definiranju arhitekture programskog proizvoda. Arhitekt treba imati dosta iskustva u razvoju, treba modi dalekosežno sagledati posljedice primjene odre?ene tehnologije, razvojnog stila ili pak arhitekturnog ili strukturnog dizajna. Arhitekt definira module programskog proizvoda i njihove veze.
Voditelj razvoja (eng. Development Lead) – U timovima u kojima ima više razvojnih inženjera (programera), voditelj razvoja upravlja, nadgleda i kontrolira njihov rad te im daje zadatke. Voditelj razvoja tako?er mora odlu?iti o pristupu i tehnologiji koja de biti korištena u rješenju odre?enog problema, te je odgovoran za osmišljavanje cjelokupne programske infrastrukture – skeleta na koji se dodaju moduli i funkcionalnosti. Voditelj razvoja nadgleda kvalitetu programskog kôda, vrši reviziju kôda te pazi da nekvalitetan, nedovoljno testiran, nekomentiran i nerefaktoriran kôd ne u?e u repozitorij kao kona?no rješenje za neku funkcionalnost.
Stru?njak za marketing (eng. Marketing Expert) – Marketinški stru?njak ima potpuno druga?ije obrazovanje od ostatka projektnog tima, ?esto je vanjski suradnik u timu, te je važno da s ostatkom tima radi u sinergiji i stalnoj komunikaciji. Marketinški stru?njak definira, u okviru budžeta, strategiju prodora na tržište i privla?enja što vedeg broja korisnika. On definira vrijeme kada de se na tržište izadi sa informacijama o proizvodu, demo verzijama proizvoda, marketinškom kampanjom ili sa proizvodom u cjelini. Stru?njak za marketing usko sura?uje sa dizajnerima koji izra?uju ili sudjeluju u izgradnji marketinških i promidžbenih materijala. Kona?no, marketinški stru?njak pomaže izraditi brand od mobilnog proizvoda ili tvrtke.
Administrator baze podatka (eng. Database Administrator) – Vedina mobilnih programskih proizvoda generira, prikuplja, obra?uje i pohranjuje podatke. Arhitekturna rješenja naj?ešde zahtijevaju centraliziranu pohranu tih podataka u bazu podataka koja se nalazi na udaljenom ra?unalu ili u oblaku (eng. Cloud). U pojedinim aplikacijama upravljanje podacima je jedan od najzahtjevnijih izazova projektnom timu kako bi osigurali dostupnost podataka u realnom vremenu i sa što manje vremena ?ekanja korisnika na podatke. U takvim sustavima, uloge kao što su administrator baze podataka, arhitekt baze i/ili skladišta podataka, pa i osobe koje se bave unosom i obradom podataka postaju jako važne. Osnovni zadaci administratora baze podataka uklju?uju odabir optimalnog sustava za upravljanje bazom podataka, definiranje i implementacija modela podataka, osiguranje sigurnosnih pohrana podataka, optimizacija sustava i sli?no.
Razvojni inženjer pozadinskih servisa (eng. Backend Developer) – U kontekstu rada s podacima opisanog kod prethodne uloge, razmjena podataka izme?u mobilnih aplikacija i pozadinskih sustava, ostvaruje se pomodu web servisa. Web servisi su web aplikacije bez korisni?kog su?elja, dizajnirane i izra?ene isklju?ivo u svrhu komunikacije s mobilnim aplikacijama. Web servisi rade na web serverima, te prema zahtjevu uslužuju mobilne aplikacije podacima ili prikupljaju podatke od mobilnih aplikacija. Programeri web servisa moraju imati znanja u korištenju web tehnologija i web programskih jezika. U


24


kontekstu razvoja za Android, web servisi mogu biti pisani u Javi, PHP-u, ASP.Net-u ili bilo kojem drugom jeziku podržanom od strane web servera.
Domenski stru?njak (eng. Subject Matter Expert) – Ovisno o tipu i svrsi mobilne aplikacije, projektni tim obi?no nema dovoljno znanja iz specifi?nih domena u kojima razvija mobilnu aplikaciju. Za primjer možemo uzeti mobilnu aplikaciju koja se bavi nadgledanjem i analizom rada srca. Specifi?na potrebna znanja za komunikaciju sa ure?ajem za snimanje rada srca, prihvat EKG podataka, prikaz podataka na ekranu, obradu signala i sli?no, znanja su koja projektni tim vjerojatno posjeduje.

Slika 17. Isje?ak iz mobilnog programskog proizvoda Smart.ECG6
Me?utim, analizu EKG signala i prepoznavanje anomalija u radu srca kao što su tahikardija, bradikardija, predinfarktno stanje, hipertrofije i druge, domena su u kojoj projektni tim ne može imati znanje te treba mentorstvo i vodstvo kako bi implementirali rješenje koje je u stanju prepoznati takve nedostatke. Drugim rije?ima, domenski stru?njak obi?no dio svog domenskog znanja prenosi projektnom timu koji ga onda ugra?uju u samo rješenje. Domenski stru?njaci su vanjski suradnici na projektu, a dobra suradnja izme?u njih i projektnog tima obi?no postaju kriti?an faktor u uspjehu cjelokupnog projekta.















6 Projekt Smart.ECG, FOI Varaždin, 2005-2010. Autori: Velid, Stapid, Novak, Padavid. Stru?njak iz domene: Car S., kardiolog.


1.5 Pitanja za provjeru znanja
1. Pojasnite koncept „razrada projektne ideje“. Koji je osnovni cilj provedbe aktivnosti vezanih uz razradu projektne ideje?
2. Koje su prednosti sistematskog pristupa razradi projektne ideje u odnosu na nesistematski pristup?
3. Navedite i pojasnite aktivnosti koje provodi projektni tim tijekom procesa razrade projektne ideje.
4. Koji su klju?ni parametri važni kod pozicioniranja u domenu razvoja?
5. Pojasnite na koji na?in promjena navika korisnika može biti prilika ali i prijetnja projektnom timu.
6. Navedite nekoliko novih tehnologija koje su trenutno u nastajanju i navedite nekoliko mogudih primjena tih tehnologija.
7. Koja je osnovna razlika pojmova proširena stvarnost i virtualna stvarnost?
8. Razmislite i navedite nekoliko podru?ja primjene tehnologija interneta stvari i interneta svega. Na koji na?in s navedenim tehnologijama možemo unaprijediti ta podru?ja?
9. Odaberite nekoliko kriterija po kojima se mogu segmentirati korisnici, te navedite primjere segmentacije po tim kriterijima.
10. Koje tehnike možemo koristiti prilikom provede aktivnosti definiranja projektnih ideja?
11. Pojasnite pojam „vodeda funkcionalnost“ i zna?aj postojanja takve funkcionalnosti u odnosu na konkurentne proizvode.
12. Navedite klju?ne ?imbenike koje treba uzeti u obzir kod kona?nog odabira projektne ideje.
13. Koje su osnovne faze procesa razvoja i koji su rezultati tih faza?
14. Pojasnite razliku izme?u agilnih metodika razvoja i klasi?nih metodika u koje spadaju heuristi?ke metodike, formalne metodike i metodike prototipiranja.
15. Koje su specifi?nosti djelomi?no inkrementalnog pristupa provedbi metodika razvoja?
16. Definirajte Scrum proces razvoja, uloge ?lanova Scrum tima, te osnovne korake u Scrum procesu.
17. Pojasnite pojam sprint kao jedan od osnovnih Scrum koncepata.
18. Koji se artefakti (dokumenti, alati...) kreiraju i koriste tijekom Scrum procesa?
19. Navedite i pojasnite na?in nastajanja i svrhu postojanja grafa preostalog posla.
20. Navedite i pojasnite osnovne uloge ?lanova projektnog tima?

1.6 Resursi za samostalan rad7
* Langer M. Arthur. A Guide to software development: designing and managing the life cycle. New York, NY: Springer Berlin Heidelberg; 2016.
* Murch Richard. The Software Development Lifecycle - A Complete Guide: Richard Murch; 2012.
* Sommerville Ian. Software Engineering. 9. izdanje. Boston: Pearson; 2011.
* Schwaber Ken, Sutherland Jeff. The Scrum Guide - The definitive guide to Scrum: The rules of the game. Scrum.org; 2011.

7 Zbog nedostataka literature na hrvatskom jeziku, donosimo popis izvora ne engleskom jeziku.
26

2 OBJEKTNO ORIJENTIRANI PRISTUP RAZVOJU

Objektno orijentirana paradigma predstavlja na?in dizajna i razvoja programskih proizvoda korištenjem objekata kao osnovnih gradbenih elemenata. Objekti predstavljaju apstrakciju entiteta iz stvarnosti, a opisuju se pomodu klasa objekata. U odnosu na strukturni dizajn i strukturno programiranje, objektno orijentirani dizajn i objektno orijentirano programiranje zahtijeva od razvojnih inženjera druga?iji na?in razmišljanja što ponekad predstavlja problem. Stoga, u ovom poglavlju želimo prikazati osnovne objektno orijentirane koncepte i principe koristedi programski jezik Javu. Kako bi smo mogli razumjeti ove složene koncepte, u prvim poglavljima predstavljamo osnovne Jave koncepte, a potom i složene koncepte povezane s objektno orijentiranim programiranjem.



SADRŽAJ POGLAVLJA
Uvod u objektno orijentirano programiranje	28
Java programski jezik	28
Tipovi podataka i operacija	29
Logi?ke strukture	33
Metode i svojstva	42
Objektno orijentirano programiranje	44
Dodatni resursi	54


2.1 Uvod u objektno orijentirano programiranje
Objektno orijentirana paradigma (OOP) je prisutna u svijetu programiranja ved skoro pedeset godina. Prvi programski jezik koji je bio objektno orijentirano koncipiran je bio SmallTalk. Prvi programski jezik koji u cijelosti podržava objektno orijentirano programiranje za Windows platformu je Microsoft Visual C++. Upravo je ovaj jezik bio dugo godina prvi izbor svima koji su željeli slijediti objektno orijentirane principe, ali bududi nije jednostavan pa ni elegantan programski jezik zamijenjen je programskim jezicima koji su dizajnirani i gra?eni kao objektno orijentirani programski jezici. Jedan od takvih jezika je i Java koji koristimo u razvoju Android mobilnih aplikacija.
Objektno orijentirani pristup predstavlja potpuno druga?iju logiku dizajniranja programskog proizvoda od tradicionalne strukturne logike. U objektno orijentiranom dizajnu primjena objektno orijentiranih principa i koncepata je nužna i neizostavna. Uz to, osim što treba znati primijeniti koncepte OOP-a, treba razumjeti zašto ih uopde primjenjivati. Uvo?enjem OOP riješena su tri velika problema strukturnih programskih jezika, a time i proizvoda koji su pisani tim jezicima. OOP donosi mogudnost modularne izrade programa, ponovne iskoristivosti postojedeg kôda te jednostavne nadogradnje ved postojedeg programskog kôda.
Cijela objektno orijentirana paradigma se temelji na pretpostavci da sam sustav i osoba koja piše programski kôd dijele zajedni?ko okruženje, te da su svi programi definirani kao proširenje ovom okruženju. Kao primjer možemo navesti na?in gradnje kude. Ako kudu gradite u C-u, onda je za nju potrebno opisati svaku pa i najmanju ?esticu, svaki atom, jer je C atomarni programski jezik. Objektno orijentirani jezici dopuštaju definiranje vlastitih objekata, kao što su recimo gradbeni elementi kude ili pak cijeli zidovi ili katovi, a potom i izgradnju kude spajajudi ove gradbene elemente. Kako bi smo razumjeli sintaksu i na?in kreiranja spomenutih „gradbenih elemenata“ mobilnog programskog proizvoda – to jest objekata, u sljededim poglavljima demo prvo predstaviti programski jezik Javu, a potom demo pokazati njezina OOP svojstva.

2.2 Java programski jezik
Zbog složenost programskog jezika Java, ovo poglavlje predstavlja samo kratki uvod u osnovne koncepte programiranja u Javi. Stoga, svakako preporu?amo u?enje ovog programskog jezika pomodu sveobuhvatnijih priru?nika ili knjiga. Materijali prikazani u ovom poglavlju temeljeni su na knjizi Y. Daniela Lianga [10].
Java je programski jezik opde namjene. Inicijalno je kreirana 1991. godine u svrhu programiranja elektroni?kih ?ipova ugra?enih u kudanske aparate i ure?aje opde namjene. Ved 1995. Java dobija današnje ime nakon što je redizajnirana za razvoj web aplikacija. Od 2010. godine Java je u vlasništvu tvrtke Oracle koji nastavlja graditi na viziji da bude više-platformski programski jezik. To je rezultiralo da Java danas postane programski jezik koji se koristi za izradu softvera ugra?enog u ure?aje, aplikacija za web, mobilnih aplikacija, te samostalnih desktop aplikacija. Tako?er, programi pisani u Javi mogu se izvršavati na vedini operacijskih sustavima.
Java je, kako navode njezini dizajneri, programski jezik koji se temelji na jednostavnosti, orijentiranosti na objekte, distribuiranosti, robusnosti, sigurnosti, neovisnosti o arhitekturi, portabilnosti, visokoj u?inkovitosti, višedretvenosti i dinami?nosti.
Otvorenost Jave, njezinu dostupnost i veliku popularnost prepoznali su i kreatori Androida, te su ju prigrlili kao osnovni programski jezik za kreiranje Android aplikacija. Stoga u ovom poglavlju


donosimo osnove programiranja u Javi kao uvodu u objektno orijentiranu paradigmu i u razvoj Android aplikacija.

2.3 Tipovi podataka
Tip podataka predstavlja na?in na koji de podaci iz ra?unalnog programa biti pohranjeni u memoriju ra?unala, to jest na?in na koji de se podaci tuma?iti pri ?itanju iz memorije. Promotrite sljededi scenarij:
Podaci se u memoriju ra?unala zapisuju u obliku binarnog zapisa, grupirani u memorijske rije?i (bajtove). Zbog jednostavnosti, pretpostavimo da se svaki broj i svaki znak zapisuju u jednu memorijsku rije?, dakle jedan bajt koji je dužine 8 bitova.

Slika 18. Interpretacija memorijskog zapisa ovisna o tipu podataka


Promatrajudi primjer memorijskog zapisa prikazan na slici iznad (Slika 18) vidimo da se na memorijskoj lokaciji s adresom A004, nalazi zapis bitova „01000100“. Me?utim, ra?unalni program de pri izvršavanju promatrani zapis interpretirati ovisno o deklariranom tipu podatka, te ako je varijabla kojoj je dodijeljena ta adresa deklarirana kao cijeli broj (int) onda de njena vrijednost biti protuma?ena kao cijeli broj 68. S druge strane, ako je varijabla na toj adresi deklarirana kao znak (char) onda de njena vrijednost biti protuma?ena kao znak D.
2.3.1 Deklaracija, inicijalizacija i definicija varijabli
Kako bi smo podatke mogli pohraniti na jednozna?no mjesto u memoriju, te im kasnije opet pristupiti bez da pamtimo adresu gdje su pohranjeni, u Javi koristimo posebne identifikatore koji se nazivaju varijable. Varijable se koriste u svrhu ozna?avanja (imenovanja) memorijskih lokacija s promjenjivim (varijabilnim) podacima. Varijabla za pohranu cijelog broja može biti ovo:
int vrijednost = 68;	

Iznad prikazana linija kôda sadrži potpunu definiciju varijable, što zna?i da je u jednoj liniji kôda deklarirana varijabla naziva vrijednost i tipa int, te joj je odmah inicijalizirana vrijednost na 68. Ovaj zapis (Slika 19) ujedno predstavlja osnovnu sintaksu deklariranja i inicijaliziranja varijabli u Javi.





Slika 19. Osnovna sintaksa definiranja varijabli u Javi


2.3.2 Numeri?ki tipovi podataka
U Javi se tipovi podataka dijele na osnovne (uro?ene) i složene tipove podataka. Postoji osam osnovnih (primitivnih) tipova podatka koji služe za pohranu:
* numeri?kih vrijednosti
* znakovnih vrijednosti i
* logi?ka da-ne vrijednost (boolean).
Numeri?ki tipovi podataka pobrojani su u sljededoj tablici:
Tablica 3. Numeri?ki tipovi podataka

NazivOpsegPotrebna memorijabyte-128 do 1278-bitshort-32.768 do 32.76716-bitint-2.147.483.648 do 2.147.483.64732-bitlong-263 do 263-164-bitfloatZa pohranu realnih brojeva. Za detalje
pogledaj IEEE 754 standard [11].32-bitdouble64-bit

Tipovi podatka byte, short, int i long služe za pohranu cjelobrojnih vrijednosti, dok tipovi podataka float i double služe za pohranu pozitivnih i negativnih realnih vrijednosti. Zbog složenosti i specifi?nosti definiranja tipova podataka sa takozvanim pomi?nim zarezom (eng. floating point), ovdje nedemo ulaziti u detalje njihove implementacije ved demo za primjer navesti opsege pohrane realnih brojeva u float tip podataka kako bi se stekao dojam o mogudnostima i preciznosti ovog tipa podataka. U pozitivnom nizu, u float se mogu pohraniti brojevi u opsegu od 1.4E-45 do 3.4028235E+38, a u negativnom nizu u float se mogu pohraniti brojevi u opsegu od -3.4028235E+38 do -1.4E-45.
Minimalan pozitivan broj:
o Binarno: 00000000 00000000 00000000	00000001
o Znanstvena notacija:	1.4E-45
o Decimalna notacija:	0.0000000000000000000000000000000000000000000014
Maksimalan pozitivan broj:
o Binarno:	01111111 01111111 11111111 11111111
o Znanstvena notacija:	3.4028235E+38
o Decimalna notacija:	340282350000000000000000000000000000000
Naravno, vrijednosti double tipa podataka su još preciznije i opsežnije. Za detalje o na?inu zapisa podataka u float i double tipu konzultirajte IEEE 754-2008 standard [11] ili neke od materijala prilago?enih za pou?avanje kao što su predavanja sa Sveu?ilišta u Marylendu [12]. Za testiranje


konverzije i zapisa brojeva može se koristiti i neki od dostupnih online kalkulatora, kao što je na primjer Schmidtov kalkulator [13].


2.3.3 Operacije nad numeri?kim tipovima
Postoji pet osnovnih matemati?kih operacija koje se mogu provoditi nad numeri?kim varijablama. Popis operacija i znakovnih operatora koje ih predstavljaju, te prioritet izvo?enja operacija prikazan je u tablici ispod (Tablica 4).
Tablica 4. Prioritet operacija

OperacijaOperandPrioritetPrimjerRezultatZbrajanje+272 + 1890Oduzimanje-272.0 – 18.553.5Množenje*172 * 181296Dijeljenje/118.0 / 72.00.25Ostatak pri dijeljenju%173 % 181

Ispod se nalazi isje?ak programskog kôda koji prikazuje osnovni rad s varijablama i numeri?kim tipovima podataka u Javi.

U prikazanom primjeru su korišteni numeri?ki tipovi podataka za pohranu cijelog broja krugova za koje se ra?una površina, zatim realnog 32-bitnog broja tipa float za pohranu radijusa kruga, te ukupnog rezultata kao realnog 64-bitnog broja tipa double. Tako?er, korišteni su i koncepti definicije varijable brojKrugova, zatim odvojene deklaracije i inicijalizacije podacima varijabli radijus i povrsina, te koncepti korištenja preddefiniranih paketa za matemati?ke operacije (konstanta PI je definirana u Javi u paketu Math) i ispisa u log (pomodu paketa System). Rezultat izvo?enja programa vidljiv je u Log panelu:
Ukupna površina 10 krugova je: 384.84510006474966	

2.3.4 Evaluiranje izraza
Redoslijed izvo?enja operatora u Javi jednak je aritmeti?kim pravilima izvo?enja operatora. Ako izraz sadrži zagrade, onda se prvo evaluiraju dijelovi izraza u zagradama, a potom ostatak izraza. Kod primjene operatora, prvo se evaluiraju operacije množenja, dijeljenja i ostatka, a potom operacije zbrajanja i oduzimanja. Ukoliko izraz ima više operacija istog ranga, one se evaluiraju redoslijedom kojim su napisani, to jest s lijeva na desno.
Tablica 5. Redoslijed evaluiranja izraza

Redoslijed evaluiranja izraza u Javi8.5 + 4 * 12 – 6 / (1 + 1 * 2) % 38.5 + 4 * 12 – 6 / (1 + 2) % 38.5 + 4 * 12 – 6 / 3 % 38.5 + 48 – 6 / 3 % 38.5 + 48 – 2 % 38.5 + 48 – 256.5 – 2

54.58.5 + 4 * 12 – 6 / (1 + 1 * 2) % 3 = 54.5
2.3.5 Prelijevanje vrijednosti
Posebnu pozornost u radu s numeri?kim tipovima podatka treba obratiti na takozvano prelijevanje vrijednosti (eng. overflow). Naime, do prelijevanja vrijednosti dolazi kada se u varijablu pokušava upisati numeri?ka vrijednost izvan opsega koji može stati u definirani tip podataka. Tako?er do prelijevanja vrijednosti može dodi kao rezultat provo?enja matemati?ke operacije nad postojedom vrijednosti. Pogledajte sljededi primjer:

Program u kojem se može dogoditi prelijevanje vrijednosti imat de logi?ke pogreške koje je teško pronadi u fazi testiranja.
2.3.6 Pretvorba tipova podataka
Java podržava automatsku pretvorbu tipova podataka, koja de se u razli?itim scenarijima izvršiti sa ili bez gubitka informacija. Svaka numeri?ka vrijednost se može upisati u varijablu ?iji tip podržava širi opseg vrijednosti. Takva operacija se naziva proširenje tipa podataka. S druge strane, ukoliko želite upisati vrijednost u varijablu koja ima manji opseg vrijednosti, to jest ukoliko želite suziti tip podataka, onda morate koristiti eksplicitnu pretvorbu tipa podataka.
Pretvorba tipa podataka (eng. type casting) je posebna operacija koja pretvara podatak iz jednog tipa u drugi tip. Sintaksa pretvorbe je jednostavna – potrebno je upisati željeni (odredišni) tip u zagradu ispred naziva varijable ili vrijednosti koju treba pretvoriti. Promotrite sljedede primjere i rezultate:

System.out.println((int)8.6f);//8System.out.println((int)4.2);//4System.out.println((double)8.6f);//8.600000381469727System.out.println((double)1 / 2);//0.5System.out.println((double)(1 / 2));//0U prvom primjeru, kod pretvorbe float u int vrijednost, zbog sužavanja tipa, to jest pretvorbe u tip s manjim opsegom, Java de odbaciti realni dio broja i zadržat de cijeli dio broja. Sli?no je i u drugom primjeru u kojem se pretvara double vrijednost u int vrijednost. Primijetite da pretvorba nije isto što i zaokruživanje, jer bi zaokruživanje broja 8.6 vratilo vrijednost 9. U tredem primjeru pretvaramo float u double vrijednost. Zbog karakteristika i razlika u float i double zapisu, konvertirani broj nikad ne može biti identi?an originalnom broju. Ipak razlike u pretvorbi su zanemarive. U pretposljednjem primjeru, operand 1 se pretvara u double vrijednost, zatim se provodi operacija dijeljenja nad vrijednostima tipa double i tipa int, pri ?emu Java prednost daje double vrijednosti, što zna?i da de i rezultat biti double vrijednost. Razmislite zašto je rezultat 0 u posljednjem primjeru?
2.3.7 Znakovni tipovi podataka
Poseban tip podataka char predstavlja tip podataka u koji se može pohraniti jedan jedini znak, dok se niz znakova pohranjuje u složeni tip podataka koji se naziva String. Vradajudi se na sliku s po?etka ovog poglavlja (Slika 18), primijetit demo da se znak i broj upisuju u memoriju na sli?an na?in – kao niz jedinica i nula. Pri tome, dogovor oko na?ina pretvorbe numeri?kih vrijednosti je definiran standardom, a dogovor oko pretvorbe znakova zovemo shemom kodiranja. Java koristi Unicode shemu kodiranja, koja je zamišljena da u 16-bitova ima mogudnost pohraniti sve mogude znakove, te


tako omogudi maksimalnu portabilnost. Me?utim, pokazalo se da 65.536 razli?itih kombinacija nije dovoljno za pohranu svih znakova, te se shema morala naknadno proširiti pomodnim znakovima.
Slijedi nekoliko primjera upisa znakovnih vrijednosti u char i String varijable.

Primijetite, znakovi se upisuju u varijablu tipa char pomodu jednostrukih navodnika. Znakovni nizovi se upisuju u varijable tipa String pomodu dvostrukih navodnika. Znakovi i znakovni nizovi mogu sadržavati bilo koji znak uklju?ujudi slova, interpunkcijske znakove, posebne znakove u razli?itim jezicima, simbole i sli?no. Ukoliko želite promatrati specijalne znakove koji u Javi imaju sintaksnu ulogu, onda ih morate prefiksirati specifi?ni znakom backslash (\). Tako u posljednjem primjeru za varijable tipa char i posljednjem primjeru za varijable tipa String primjenjujemo backslash kako bi smo ozna?ili kompajleru da znak koji slijedi ne promatra kao dio sintakse Java jezika, ved kao vrijednost.
Razmislite kako bismo ispisali jedan znak backslash, a kako dva backslasha uzastopno?
Na znakove se mogu primijeniti i numeri?ki operatori. Promotrite sljedede primjere i njihove rezultate:

Java u navedenim primjerima konvertira operande u cijele brojeve, provodi operaciju, te potom vrijednost upiše u cjelobrojnu varijablu (kod prva dva primjera) ili ju konvertira natrag u znakovnu vrijednost (kod druga dva primjera). Ovakve operacije su izrazito rizi?ne jer mogu rezultirati sa neo?ekivanim ili nemogudim vrijednostima, te ih treba izbjegavati.
Za razliku od char tipom podataka, nad String tipom podataka se može provoditi samo operacija konkatenacije (spajanja znakovnih nizova) za koju se koristi operator „+“. Pogledajmo primjer.

Operator konkatenacije spaja znakovne nizove u novi znakovni niz ?ija je dužina jednaka zbroju dužina spojenih nizova. Sve ostale operacije nad znakovnim nizovima, kao što su uspore?ivanje, pretraživanje, dijeljenje i sli?no provode se pomodu specifi?nih metoda dostupnih u String klasi podataka.

2.4 Logi?ke strukture
2.4.1 Logika vo?ena doga?ajima
Moderni programski jezici spadaju u skupinu programskih jezika u kojima je osnovna programska logika vo?ena doga?ajima (eng. Event driven). To zna?i da se programski proizvodi grade na na?in da


neprestano osluškuju doga?aje, te izvršavanjem programskog kôda odgovaraju na njih to jest upravljaju njima (eng. Event handling). Takva je i Java za Android.
Za usporedbu, u strukturnom programiranju, programski proizvod bi zapo?eo od glavne funkcije, te bi se bez prestanka, uz povremeno ?ekanje na korisni?ki unos, slijedno izvršavao do kraja (Slika 20). S druge strane, Android aplikacije (pisane u Javi) zapo?inju kôdom glavne dretve u kojem se, izme?u ostalog, odradi priprema prikaza korisni?kog su?elja i podataka, kreira se vlastite doga?aje i postavi se slušatelje na doga?aje (eng. Event listener) i nakon toga glavna dretva ?eka dok se ne dogodi doga?aj koji treba obraditi (Slika 21).


Slika 20. Slijedno izvo?enje programa s povratnom vezom
U pristupu programiranju vo?enom doga?ajima, doga?aje podižu (eng. Trigger) operacijski sustav, aplikacija i korisnici. Neki od doga?aja koje operacijski sustav šalje svim aplikacijama su: promjena statusa baterije, promjene vrijednosti o?itanja na senzorima, proslje?ivanje poruka drugih aplikacija i sli?no. Aplikativni doga?aji mogu biti podignuti po završetku akcije, promjeni vrijednosti u varijabli, dobivanju odgovora od web servisa i sli?no. Korisni?ki pokrenuti doga?aji su doga?aji kojima se obavještava aplikacija da je korisnik izvršio nekakvu radnju kao što je pritisak (eng. Tap) ili dugi pritisak na elemente korisni?kog su?elja, korisni?ke geste na zaslonu ili korisnikom su?elju, korisni?ki pritisak na hardverske tipke i sli?no.
Na slici ispod prikazan je slijed izvo?enja programa vo?enog doga?ajima. Na tom primjeru možemo vidjeti da glavna dretva provodi pripremu podataka i osnovnu obradu, te potom pretplatu (isprekidani tokovi) na tri doga?aja (tri kružida) pri ?emu pripremi i izvršitelje. Razli?ite boje doga?aja i povezanih elemenata sugeriraju da izvršitelji nisu kompatibilni te se strogo zna koji izvršitelj može odgovoriti na koji doga?aj. Po nastanku doga?aja, bilo korisni?kom ili akcijom sustava (isprekidani tokovi s to?kom), glavna dretva se aktivira i izvršava odgovarajudi kôd. U uobi?ajenom primjeru aplikacije za Android jedna takva akcija po svom završetku zatvara program.





Slika 21. Izvo?enje programa s pretplatom na doga?aje
Na isti doga?aj može se izvršiti više zainteresiranih izvršitelja unutar jedne ili razli?itih aplikacija. Redoslijed izvršavanja više izvršitelja koji osluškuju isti doga?aj se provodi istim redoslijedom kojim su izvršitelji pretpladeni na doga?aj. Me?utim, dobra je praksa izbjegavati graditi programsku logiku koja se temelji na redoslijedu provo?enja izvršitelja bududi da razvojni inženjer teško može upravljati spomenutim redoslijedom.
Osim promjena na logici provo?enja cijelog programa, u izvršavanju logi?kih cjelina programskog kôda, nema suštinskih promjena u odnosu na strukturno izvršavanje programa. Stoga, sve logi?ke strukture koje se pojavljuju u izvršavanju programa možemo svrstati u slijed, selekciju ili iteraciju.
2.4.2 Slijed
Slijed (eng. Sequence) predstavlja logi?ku strukturu koja osigurava izvršavanje linija kôda u istom slijedu u kojem su pisane. Slijed je ujedno i osnovna programska struktura koja jam?i razvojnom inženjeru dosljednu provedbu kreiranog programskog kôda koji de se izvršiti uvijek na isti na?in bez bilo kakvih odstupanja u kona?nom rezultatu.
Slijed može biti narušen uporabom skokova ili paralelnim izvršavanjem programskog kôda. Uporabe skokova su stru?ne zajednice odba?ene prije dvadesetak godina, te se uobi?ajeno smatra da uporaba skokova predstavlja ili dizajnerske propuste ili propuste u znanju samih razvojnih inženjera. S druge strane, paralelno izvršavanje programskog kôda je ponekad potrebno ili ?ak neizbježno i ono se postiže uporabom više dretvi (eng. Thread). Sinkronizacija i razmjena podataka izme?u dretvi su teme koje demo samo djelomi?no obraditi u prakti?nom dijelu priru?nika, a zbog njihove složenosti preporu?amo konzultiranje sveobuhvatne literature.





Slika 22. Rezultat provedbe slijednog programskog kôda
Slijedno provo?enje prethodno prikazano programskog kôda osigurat de da se vrijednost stanja ra?una nakon definicije na iznos od 5600.50 prvo upiše u varijablu prethodnoStanje, a potom izmijeni. Pri ispisu vidimo da je spomenuta varijabla prethodnoStanje sa?uvala inicijalnu vrijednost stanja ra?una.
2.4.3 Selekcija
Selekcija (eng. Selection) predstavlja logi?ku strukturu odabira provedbe jednog izme?u više mogudih programskih blokova. Mogudnosti se nazivaju grane. Odabir se vrši temeljem provjere postavljenih logi?kih uvjeta. Kod ispravno definirane selekcije u jednom prolazu se može izvršiti maksimalno jedna, a minimalno niti jedna grana. Drugim rije?ima, selekcija predstavlja mogudnost programskog proizvoda da odlu?i koje de naredbe izvršiti.
Naredbe kojima se postiže odabir u Javi su if naredba, if… else naredba i switch naredba. Shematski prikaz spomenutih naredbi dan je na slici ispod (Slika 23).


Slika 23. Logi?ke strukture u implementaciji selekcije


2.4.3.1 Logi?ki izrazi
Kako bi smo razumjeli provjeru uvjeta u naredbama selekcije, važno je razumjeti logi?ke izraze u Javi i njihovu evaluaciju. Naime, rezultat evaluacije logi?kih izraza može biti to?no ili pogrešno (eng. True; False).
Vrijednost to?no – neto?no se pohranjuje pomodu specifi?nog tipa podataka koji se naziva Boolean. Stoga, rezultat evaluacije svakog logi?kog izraza može biti pohranjen u boolean varijablu te de imati vrijednost true ili false.


Logi?ki izrazi se kreiraju i provjeravaju uz korištenje operatora usporedbe (eng. Comparison Operators). Java poznaje operatore usporedbe prikazane u tablici ispod (Tablica 6). Operatori usporedbe podrazumijevaju postojanje operanda s lijeve i desne strane operatora.
Tablica 6. Operatori usporedbe

OperatorZna?enje==Operator jednakosti!=Operator nejednakosti<, <=, >, >=Operatori usporedbe veli?ine

Za kreiranje i provjeru složenih logi?kih izraza Java koristi Booleovu algebru, to jest logi?ki izrazi se mogu slagati u složene izraze uz pomod Booleovih logi?kih operatora. Svi logi?ki operatori, osim operatora negacije, podrazumijevaju da se s lijeve i desne strane nalazi Bool vrijednost, dakle ili to?no ili neto?no. Operator negacije se provodi nad jednim operandom. Booleovi logi?ki operatori navedeni su u tablici ispod (Tablica 7).


Tablica 7. Logi?ki (Booleanovi) operatori

Logi?ki operatoriZna?enje / Notacija!Negacija	NOT&&Konjunkcija	AND||Disjunkcija	OR^Isklju?iva disjunkcija	XOR

Za razumijevanje evaluacije složenih logi?kih izraza potrebno je poznavati tablicu istinitosti pri primjeni logi?kih operatora na boolean vrijednosti (Tablica 8).
Tablica 8. Tablica evaluacije logi?kih izraza

P1OperatorP2Rezultattrue!falsefalse!truetrue&&truetruetrue&&falsefalsefalse&&truefalsefalse&&falsefalsetrue||truetruetrue||falsetruefalse||truetruefalse||falsefalsetrue^truefalsetrue^falsetruefalse^truetruefalse^falsefalse

Primjer i vrjednovanja složenog logi?kog izraza koji provjerava je li 2016 godina prijestupna godina prikazan je ispod:
(2016 % 400 == 0) || ((2016 % 4 == 0) && (2016 % 100 != 0))


Nakon provedbe matemati?kih operacija o kojima smo govorili u prethodnom poglavlju, slijedi logi?ko vrjednovanje istinitosti izraza (Tablica 9). Rezultat pokazuje da je 2016. godina uistinu prijestupna godina.
Tablica 9. Redoslijed vrjednovanja složenog izraza

Evaluiranje složenog logi?kog izraza u Javi(2016 % 400 == 0) || ((2016 % 4 == 0) && (2016 % 100 != 0))(16 == 0) || ((0 == 0) && (16 != 0))false || (true && true)false || truetrue(2016 % 400 == 0) || ((2016 % 4 == 0) && (2016 % 100 != 0)) = true

2.4.3.2 Primjeri selekcije
Najjednostavnija implementacija selekcije je pomodu if naredbe. Kako je prikazano na prvoj logi?koj strukturi danoj u slici iznad (Slika 23), rezultat vrjednovanja uvjeta može ali i ne mora biti provedba programskog bloka. U primjeru ispod, rezultat vrjednovanja vrada true što zna?i da de se programski blok izvršiti i u log sustava bit de ispisana re?enica „Godina 2016 je prijestupna!“.

Programski blok se može sastojati od nijedne, jedne ili više linija kôda. Ako je programski blok prazan ili ako se sastoji od više linija kôda, onda blok mora biti jasno ogra?en viti?astim zagradama koje predstavljaju po?etak '{' i kraj '}' programskog bloka. Ako se blok sastoji od samo jedne linije kôda, zagrade nisu obvezne, ali je preporu?eno pisati ih.
U drugom primjeru, godina koja se provjerava je rezultat prethodne obrade (ne mora uvijek biti ista) te je evaluacija izraza neizvjesna. Me?utim, u svakom slu?aju izraz de ispisati jednu od dvije mogude poruke, bududi da kod if…else naredbe jedan programski blok mora biti izvršen. To je grafi?ki prikazano u drugoj logi?koj strukturi danoj na slici (Slika 23).

U tredem primjeru se koristi switch naredba koja pojednostavljuje pisanje složenog logi?kog if…else izraza koji može imati više mogudih scenarija izvo?enja. Ako analiziramo tredu logi?ku strukturu selekcije (Slika 23), možemo primijetiti nekoliko bitnih stvari:
- Ako provjera prvog izraza vrati true Java de izvršiti Blok naredbi 1, ali i sve ostale blokove naredbi. Kako bi smo to izbjegli, moramo koristiti break naredbu na kraju prvog bloka naredbi.
- Može, ali i ne mora, postojati osnovni (eng. default) blok naredbi koji se izvršava ukoliko niti jedan uvjet nije zadovoljen.
- Logi?ki izraz kod switch naredbe uvijek se odnosi na primjenu operatora uspore?ivanja „==“.


Promotrimo primjer:
Pretpostavimo da ra?unalni program za odre?ivanje prijestupne godine može korisniku vratiti razlog (cijeli broj) zašto neka godina nije prijestupna. Analizom logi?kog izraza koji odre?uje prijestupnost godine možemo utvrditi da godina nije prijestupna ako:
- razlog 1: Godina nije djeljiva sa 4.
- razlog 2: Godina je djeljiva sa 4 i 100, ali nije djeljiva sa 400.
- u svim drugim slu?ajevima: Godina je prijestupna!
Stoga, korištenjem switch naredbe korisniku možemo ispisati poruke rezultata analize kako slijedi.



2.4.4 Iteracija
Iteracija (eng. Iteration) predstavlja logi?ku struktura koja omogudava višestruko izvršavanje jedne ili više linija programskog kôda. Stoga, iteracija predstavlja prvi i osnovni alat povedanja razine ponovne iskoristivosti kôda, što je cilj svih razvojnih inženjera. Osnovna struktura kojom provodimo iterativnost je petlja (eng. Loop).
Programski jezik Java poznaje više naredbi kojima se postiže iterativnost, me?utim sve ih dijelimo u dvije skupine. U prvu skupinu spadaju naredbe koje uvjet provo?enja ponovljivog bloka kôda ispituju na po?etku, to jest prije svakog izvo?enja. Takve naredbe su while petlja i for petlja. U drugu skupinu spadaju naredbe koje uvjet provo?enja ispituju na kraju ponovljivog bloka, to jest nakon što je blok linija kôda ved izveden. Takva naredba je do…while petlja. Pogledajte sliku ispod (Slika 24).






Slika 24. Logi?ke strukture u implementaciji iteracije
Naj?ešde korištene petlje iz prve skupine su petlje while i for. Bududi da se uvjet ispitivanja provo?enja programskog blôka (ome?enog viti?astim zagradama) provjerava na po?etku, rezultat provo?enja ovih logi?kih struktura može biti da se programski blok ne izvrši niti jednom, da se izvrši jednom, da se izvrši više puta, pa ?ak i da se izvrši beskona?no puno puta (što ako nije kontrolirano predstavlja programsku pogrešku). Primjer kôda sa istim rezultatom napisan u while i for sintaksi nalazi se ispod.





Razmislite što radi prikazani kôd, te koje rezultate vrada verzija pisana s while petljom, a koje rezultate vrada verzija pisana sa for petljom. Pojasnite algoritam te matemati?ke i logi?ke operatore.
Naj?ešde korištena petlja iz druge skupine je do…while petlja. Ova petlja provodi provjeru uvjeta tek na raju bloka kôda, te se kod primjene ove petlje ne može dogoditi da de programski blôk biti ne izveden. Isti primjer programskog kôda koji ispisuje sve prijestupne godine u zadanom intervalu dan je u sintagmi do…while petlje ispod.





Slika 25. Rezultat provedbe primjera s iteracijama

2.5 Metode i svojstva
Drugi važan iskorak u povedanju ponovne iskoristivosti pri pisanju ra?unalnog kôda nastao je kreiranjem koncepta metode (funkcije, operacije). Metoda predstavlja programski blok koji se može sastojati od niti jedne, jedne ili više linija kôda ?ije izvršenje možemo pozvati po potrebi, te opcionalno proslijediti joj odre?ene vrijednosti ili primiti odgovor.

Iznad prikazani primjer sadrži potpunu definiciju metode, što zna?i da je ovim kôdom deklarirana metoda naziva ProvjeriPrijestupnostGodine, tipa boolean, kojoj je proslije?en jedan parametar, te joj je odmah inicijalizirano tijelo, to jest programski kôd koji se izvršava ovom metodom. Sve metode koje nisu tipa void moraju završiti naredbom vradanja vrijednosti. Opis definicije metode dan je i na slici ispod (Slika 26).


Slika 26. Osnovna sintaksa definiranja varijabli u Javi


Primjer definiranja i korištenja metode naveden je u primjeru ispod. Prvi isje?ak programskog kôda sastavni dio je neke složenije strukture, te u slijedu izvo?enja operacija sadrži i definiranje varijabli, to jest granica ispitivanja prijestupnosti godine. U primjeru su granice definirane kao pocetnaGodina i zavrsnaGodina.


Primjenjujudi while iterator programskim kôdom se promatra svaka godina izme?u definiranih granica, uklju?ujudi i granice, te se u svakom koraku iterativnog bloka poziva metoda ProvjeriPrijestupnostGodine. Metoda prima jedan parametra – promatranu godinu, a rezultat obrade vrada u obliku cijelog broja. Prihvadeni rezultat se pohranjuje u privremenu varijablu rezultatObrade te se isti proslje?uje drugoj metodi – IspisiPojasnjenja, koja ispisuje rezultat u jeziku razumljivom korisniku.


Metoda ProvjeriPrijestupnostGodine prima godinu kao parametra, te provjerava zadovoljava li godina uvjete prijestupnosti. Rezultat obrade može biti:
- 0 – godina je prijestupna
- 1 – godina nije djeljiva sa 4
- 2 – godina je djeljiva sa 4 i 100, ali nije sa 400
U ovoj se metodi primjenjuje selekcija te operatori usporedbe i logi?ki operatori o kojima je tako?er bilo govora u prethodnim poglavljima. Kona?no u metodi IspisiPojasnjenje, koja prima dva razli?ita parametra, se koristi switch selekcija te se korisniku ispisuju razumljive poruke.



Dvije prikazane metode imaju razli?ite povratne tipove, ali i razli?it broj i tipove parametara koje primaju. Ovdje je važno navesti da tip void predstavlja odsutnost povratne vrijednosti, zbog ?ega druga metoda niti nema return naredbu. Rezultat provedbe ovog programskog kôda prikazan je u slici ispod ().


Slika 27. Rezultat provedbe primjera s metodama
Pregled osnovnih koncepata programiranja u Javi predstavljen ovim poglavljem sve koncepte prezentira do razine primjenjivosti, ali ne ulazi u detaljne specifikacije, varijacije ili iznimke koje se mogu pojaviti pri klasi?nom razvoju. Stoga, u svrhu boljeg razumijevanja Java programskog jezika i njegovih potpunih mogudnosti, svakako preporu?amo konzultiranje sveobuhvatnije literature.

2.6 Objektno orijentirano programiranje
2.6.1 Ciljevi OOP-a
Bjarne Stroustrup, otac C++ programskog jezika, jednom je prilikom rekao da mali program može biti napisan u bilo kojem jeziku i bilo kako. Ako ne odustaješ suviše lako, na kraju deš sigurno u?initi da radi. Ali veliki program, to je druga?ija pri?a. Ako ne koristiš tehnike dobrog programiranja, nove pogreške de se javljati jednako brzo kako deš uklanjati ved postojede pogreške [14].
Stroustrup je svakako bio u pravu, a možemo redi da je razlog za ovo velika me?uovisnost razli?itih dijelova programa. Svaka promjena u jednom dijelu programa utje?e na ostatak napisanog kôda i ukoliko se koristi strukturno ili proceduralno programiranje ovu me?uovisnost je nemogude u potpunosti kontrolirati. Rješenje za ovaj problem je kreiranje malih, u potpunosti neovisnih, dijelova kôda koji sa ostatkom aplikacije komuniciraju preko definiranih su?elja. Ovi dijelovi kôda nazivaju se moduli, a rješenje spomenutom problemu modularnost. Drugi veliki problem koji se nametnuo je bila nemogudnost ponovne iskoristivosti napisanog programskog kôda jer su dijelovi programskog kôda bili previše isprepleteni vezama koje se nije smjelo prekinuti, ili pak takva infrastruktura nije bila prisutna u odredišnoj aplikaciji. Na posljetku, tredi problem je bio nemogudnost nadogradnje aplikacija i svaka pa i najmanja promjena na postojedoj aplikaciji implicirala je mnogo nepotrebnih i suvišnih promjena ili pak pisanje cijele aplikacije iz po?etka.
Objektno orijentirana paradigma je zamišljena upravo na na?in da riješi sve spomenute probleme; da maksimizira modularnost, mogudnost ponovne iskoristivosti i mogudnost nadogradnje programskog kôda. Upravo zbog toga ovo poglavlje donosi koncepte objektno orijentiranog pristupa koji je danas najrašireniji pristup razvoju programskih proizvoda uopde.
Koncepti objektno orijentiranog programiranja (OOP-a) su razvijeni na na?in da primjena ovog pristupa pojednostavljuje razvoj i testiranje iznimno velikih i kompliciranih sustava. Kao neke od odlika objektno orijentiranog programiranja spomenut demo apstrakciju podataka, u?ahurivanje,


naslje?ivanje i polimorfizam kao i koncepte koji su korišteni da bi se spomenuti principi mogli ostvariti.
Programski jezik Java je u potpunosti objektno orijentirani programski jezik, dizajnirana upravo za razvoj objektno orijentiranih aplikacija i kao takva je odli?na podloga za u?enje i prihvadanje OO strategije u razvoju mobilnih aplikacija.
2.6.2 Koncept objekta i razumijevanje OOP-a
Da bi u potpunosti iskoristili mogudnosti OOP-a, važnije je razumjeti metodologiju izgradnje programa koja se sada mijenja iz samih osnova, nego samu sirovu sintaksu nekog jezika koji sada ima zna?ajku da osigura okruženje koje je potrebno OO programima da se izvršavaju. U ovom okruženju, najvažnija zna?ajka je pojam objekta, koji objedinjava podatke, metode koje operiraju nad ovim podacima, te na?ine komunikacije s drugim objektima. Pokušajte prepoznati koncepte podataka i operacija promatrajudi definiciju objekta pomodu jezika za modeliranje UML8 ().


Slika 28. Uobi?ajen grafi?ki prikaz objekta klase pomo?u UML sintakse
U tradicionalnom programskom jeziku potrebno je specificirati svakom sastavnom dijelu proizvoda kojeg razvijamo što raditi i kako to napraviti. U OO sustavima možemo pretpostaviti da objekt ved zna kako obaviti odre?ene stvari i kod njegove primjene, potrebno je samo navesti što treba raditi. Ako pak i moramo programirati i dio „kako nešto napraviti“, onda to radimo samo jedanput, tu metodu pridružujemo željenom objektu, a potom ju samo koristimo. Navedena razlika naj?ešde se navodi i kao klju?na razlika izme?u trede i ?etvrte generacije programskih jezika.
Objekti koje sadrže programski sustavi ?etvrte generacije su programska analogija objekata iz realnog svijeta. Klju?na razlika izme?u objekata u OO sustavu i bilo koje komponente napisane u neobjektno orijentiranom jeziku je u tome što objekt po svojoj definiciji sadrži podatke i neophodni set metoda koje su odgovorne za manipuliranje tim podacima. S druge strane, u neobjektno orijentiranim jezicima programeri su odgovorni za eksplicitno povezivanje funkcija s podacima nad kojim one operiraju.
Dakle, prilikom definicije objekta, razmišljamo o cijeloj klasi objekata, a svojstva i metode koje opisuju jedinke te klase specificiramo u oblik atributa i metoda. Upravo zbog toga, prilikom definiranja, entitete iz stvarnog svijeta uvijek promatramo kao klasu istih objekata koje opisujemo njihovim zna?ajkama (atributima) te im dodjeljujemo radnje (metode). Primjer ovog procesa identificiranja klasa objekata je dan na slici ispod (Slika 29).

8 UML – Standardni jezik za modeliranje (eng. Unified Modeling Language). Za detalje pogledajte http://www.uml.org/





Slika 29. Identificiranje klasa objekata
Tijekom cijelog procesa izgradnje programa, sli?nosti izme?u objekata od kojih se izgra?uje sustav moraju biti prepoznate i iskorištene. Pretpostavimo da mobilni programski proizvod koji izgra?ujemo treba imati tri posebna odjeljka evidencije. Evidenciju o inventaru, zatim evidenciju prodaje i na posljetku evidenciju zaposlenika. Razlažudi zahtjeve za izgradnju ovih evidencija, uvidjet demo da postoje odre?ene komponente u svakoj evidenciji koje dijele zajedni?ki koncept. Sustav za potporu inventara sadrži i podatke o dobavlja?ima, sustav za potporu prodaji sadrži i podatke o kupcima a sustav za evidenciju osoblja sadrži podatke o zaposlenima. Treba primijetiti da svaki od ovih objekata (dobavlja?, kupac, zaposlenik) predstavlja osobu i da sve osobe sadrže neke zajedni?ke podatke (na primjer imaju ime i adresu). Upravo zbog toga, u sustavu mora postojati objekt vedeg stupnja apstrakcije, koji bi definirao zajedni?ke karakteristike svakog od ovih elemenata.
Svaki objekt je definiran razredom ili klasom, koju zapravo možemo predstaviti kao predložak (eng. template) za kreiranje specifi?nih objekata koji se ponašaju na sli?an na?in. Klase možemo grupirati u hijerarhiju, na ?ijoj de se najvišoj razini nalaziti klase ?ije su karakteristike sastavni dio klasa na nižim razinama. S druge strane, na najnižoj razini de se nadi klasa sa specifi?nim karakteristikama primjenjivim samo u njoj. Za primjer možemo navesti selekciju životinja. Promatrat demo mesojede, ali pri tome ne znamo radi li se o vukovima ili lavovima. Zapravo tu se radi o osobinama koje vukovi i lavovi imaju sli?ne, na primjer da jedu meso. Ako se spustimo na razinu vuka ili lava, onda demo vidjeti da su ove dvije životinje uistinu razli?ite. I upravo nam entitet mesojeda kao klasa najviše razine omogudava da na sli?an na?in, bazirano na zajedni?kim karakteristikama opišemo i vukove i lavove. Definirajudi nove klase, mi ne moramo opisivati svaki aspekt objekta koji opisujemo, dovoljno je navesti samo razlike od ved definiranih klasa.
Osnovno pravilo koje treba slijediti pri objektno orijentiranom dizajnu je da treba ignorirati posebne slu?ajeve tako dugo dok ih se može ignorirati [15, p. 10]. Naime, na po?etku procesa dizajna prvi korak treba biti potraga za sli?nostima koje objekti imaju. Uz ovo, OO sustavi omogudavaju dizajnerima da izbjegnu specijalizaciju sve dok se ne izgradi generalni kostur, to jest struktura programa. Ovaj proces se naziva generalizacija, a tek kad je ona napravljena, prelazi se na specijalizaciju, koja je posljednji korak. Naime, specijalizaciju je mogude ?initi onoliko dugo dok se ne iscrpi budžet naru?itelja programa ili se ne zadovolje svi njegovi specifi?ni uvjeti. Pri tome je važno spomenuti da poslije kvalitetno ura?ene generalizacije, može se konstantno specijalizirati sustav, a da se ne utje?e na ništa što je ved prije bilo napravljeno.
2.6.3 U?ahurivanje
U?ahurivanje (engl. Encapsulation) je prvi važan koncept OOP-a. U?ahurivanje predstavlja uklju?ivanje programskog kôda (metoda) i podataka (atributa, svojstava) u isti objekt. U?ahurivanje


omoguduje smještanje podataka u onaj objekt koji sadrži i definiciju upravljanja tim podacima, te tako?er omoguduje kontrolirani pristup do podataka kojima drugi objekti mogu pristupiti isklju?ivo kroz eksplicitno definirana javna svojstva i/ili metode. Stoga, svi drugi objekti programskog proizvoda koji trebaju odre?ene specifi?ne podatke, dohvadaju ih kroz objekt koji ih u sebi sadrži. Prednost u?ahurivanja je da samo jedan objekt mora znati kako se nositi sa posebnostima vlastitih podataka, a drugim objektima to uopde nije važno. Drugim rije?ima, u?ahurivanje omoguduje prikrivanje na?ina implementacije odre?ene funkcionalnosti koja je poznata samo objektu u kojem je sadržana.


Slika 30. U?ahurivanje
Na ved prikazanom primjeru klase U?enik možemo vidjeti da su podaci kao što su ime, prezime, datumRo?enja i razred skriveni sadržani u objektu koji ima metode za manipulaciju tim podacima. Bududi da su spomenuti podaci privatni, ne može im se pristupiti osim kroz javno dostupne metode kao što su na primjer getIme(). Tako?er možemo vidjeti da su pojedine metode tako?er privatne (skrivene) što zna?i da nisu dostupne u su?elju ovog objekta prema drugim objektima, te ih drugi objektni ne mogu koristiti, niti mogu znati da one postoje.


2.6.4 Naslje?ivanje
Govorili smo o hijerarhiji klasa i mogudnostima koje pruža OO pristup da više klasa niže razine koristi definirane elemente u klasi više razine. Ovaj koncept se naziva naslje?ivanje (eng. Inheritance). Izvedena klasa koristi podatkovne i funkcionalne mogudnosti od osnovne klase da bi u?inila odre?ene operacije. Primjer može biti generalizacija podataka iz klasa U?enik i Nastavnik u klasu Osoba (Slika 31). Naš definirani entitet Osoba omogudava svakoj od dvije specijalizirane klase da koriste podatke te metode kojima se manipulira tim podacima sadržane u klasi Osoba. Neposredno nakon definiranja klase U?enik izvedene iz klase Osoba, novo definirana klasa odmah može koristiti spomenute atribute i metode. Kažemo da je klasa U?enik naslijedila ove mogudnosti od klase Osoba, to jest naslijedila ih je od njoj nadre?ene klase.






Slika 31. Naslje?ivanje
Specijalizirana klasa može imati i vlastite atribute i metode, ali naslje?ivanje je izri?ito jednosmjerno i ovi atributi i metode ne mogu biti korišteni od strane nadre?ene klase.
Tako?er, u primjeru iznad možemo vidjeti da je klasa Osoba apstraktna klasa, što zna?i da, bududi da ne definira entitete iz stvarnog svijeta u potpunosti, ne može imati instance objekata. Svaki objekt instanciran u sustavu, ako se vodimo primjerom sa slike (Slika 29) mora biti ili u?enik ili nastavnik, ali ne samo osoba.
Kona?no, bududi da se u Javi privatni atributi i privatne metode ne naslje?uju, ukoliko im se treba eksplicitno pristupati iz podklase, onda se moraju proglasiti javnima (svima dostupnima) ili zaštidenima (eng. Protected), što zna?i da su dostupni samo u klasama iz istog paketa. Na dijagramu, identifikator # predstavlja zaštidene elemente klase.
Definicija apstraktne klase može izgledati kao na primjeru ispod. Obratite pozornost na klju?ne rije?i kojima se postiže željena funkcionalnost: package, import, public, abstract, class, protected i this, te na tipove podataka korištene u primjeru: Date, String i void.





Primjer klase U?enik koja naslje?uje klasu Osoba može izgledati kako je prikazano ispod. Klju?na rije? na naslje?ivanje je extends, što u doslovnom prijevodu zna?i da klasa U?enik nadogra?uje klasu Osoba.



Iz gornjeg primjera se može vidjeti razmjerno malo kôda za opis klase U?enik, iako objekt klase U?enik ima sve mogudnosti sadržane u klasi Osoba uz dodatno svojstvo razred i metode za njegovo ?itanje i pisanje.
2.6.5 Polimorfizam
Polimorfizam (engl. Polymorphism) je trede važno svojstvo, bez kojeg objektni pristup ne bi mogao postojati. Polimorfizam zapravo omogudava definiranje operacija koje su ovisne o tipu. Ved smo prije rekli kako se svakom ?lanu osnovne klase može pristupiti u izvedenoj klasi. To zapravo omogudava o?uvanje integriteta objekta, ali to ne zna?i da metode iz izvedene klase moraju isto raditi što i metode u osnovnoj klasi, iako su naslije?ene. Naime, u objektno orijentiranom pristupu mogude je svaku naslije?enu metodu na više na?ina preoblikovati, da u karakteristi?noj situaciji radi upravo ono što mi želimo, pa ?ak ako se to razlikuje od onog što smo naslijedili. Mogudnost korištenja metoda osnovne klase, ali i promijenjenih metoda u izvedenoj klasi se naziva polimorfizam. Drugim rije?ima možemo redi da isti objekt može imati više oblika, a na programeru je da koristi onaj oblik koji mu je u karakteristi?nom trenutku potreban.
Polimorfizam možemo pojasniti i na našem primjeru klasa Osoba, U?enik i Nastavnik. Iako obje specifi?ne klase naslje?uju metodu setDatumRo?enja, zbog specifi?nosti logike provjere ispravnosti datuma ro?enja kod u?enika i provjere datuma ro?enja kod nastavnika, ove dvije klase mogu preoblikovati / premostiti (eng. Override) spomenutu metodu te omoguditi specifi?nu vlastitu implementaciju.




Slika 32. Polimorfizam


Datum ro?enja u?enika, u trenutku upisa mla?eg od 6 godina vjerojatno nije ispravan, dok bi s druge strane datum ro?enja nastavnika, u trenutku upisa mla?eg od 18 godina tako?er bio neispravan. Primjer ispod pokazuje preoblikovanu metodu setDatumRo?enja koja umjesto da datum jednostavno upiše u lokalnu varijablu (kako je naslije?eno od klase Osoba) pruža vlastitu implementaciju te uz pomod jedne privatne metode vrši dodatne logi?ke provjere. Ovdje je potrebno primijetiti korištenje klju?ne rije?i Override koja anotira (@) metodu te tako kompajleru daje do znanja da zanemari naslje?enu metodu i u prijevodu koristi ovu preoblikovanu metodu. Preoblikovana metoda uvijek mora imati isto ime kao i naslije?ena metoda, a u Javi se prije svake metode koju se preoblikuje dodaje anotacija preoblikovanja (@Override).



Me?utim, polimorfizam se ogleda tek kroz kontekst korištenja klase U?enik u nekoj tredoj klasi. Tada, klasa U?enik po potrebi može poprimiti oblik klase Osoba ili oblik klase U?enik, pri ?emu de u jednom slu?aju prikazati svojstva i metode dostupne u klasi Osoba, a u drugom slu?aju svojstva i metode dostupne u klasi U?enik. Ovdje je važno spomenuti da de preoblikovana metoda uvijek biti izvršena, pa ?ak i kad se u?enik predstavlja kao Osoba. Ako želimo pristupiti metodi iz nadklase onda moramo koristiti klju?nu rije? super. Isje?ak iz kôda koji prikazuje polimorfizam pokazan je u nastavku.



U prethodnom isje?ku programskog kôda, prvi segment se odnosi na upis datuma u objekt tipa Date. Zbog odbacivanja vedine mogudnosti zastarjelog paketa java.util.Date, u novijim verzijama se alternativno može koristiti paket java.util.Calendar.
Promatrajudi objekt ucenik u obliku tipa Ucenik, primijetimo da su dostupna sva naslije?ena, ali i dodatna specifi?na svojstva i metode. Me?utim, promatrajudi ga u obliku tipa Osoba možemo vidjeti da za korištenje više nema specifi?nih svojstava i metoda kao što je npr. metoda setRazred().

Slika 33. Su?elje objekta kroz oblik nadklase
U Java programskom jeziku svaka klasa naslje?uje klasu Object, bilo indirektno kroz neku drugu naslije?enu klasu, ili direktno ako klasa eksplicitno ne naslje?uje niti jednu drugu klasu. To zna?i da se objekt bilo koje korisni?ki definirane klase može u svakom trenutku preoblikovati u tip Object te pri tome koristiti osnovna svojstva i metode naslije?ene od klase Object.
2.6.6 Su?elje
Pri razvoju mobilnih aplikacija za Android, izuzetno je važno razumjeti i znati primijeniti pojam su?elja (eng. Interface), te stoga smatramo važnim predstaviti su?elja kao jedan od specifi?nih koncepata objektno orijentirane paradigme.


Su?elje predstavlja poseban stereotip klase koja sadrži javnu definiciju, ali ne i implementaciju metoda. Za usporedbu, ved smo spomenuli neke od stereotipa klase. Za vježbu, samostalno istražite i prou?ite specifi?nosti osnovnih stereotipa: apstraktna klasa, konkretna klasa, struktura, enumeracija.



Druge klase mogu implementirati (to jest realizirati) su?elje, ali ga ne mogu naslijediti. Svaka klasa koja implementira su?elje ugovorno jam?i da de sadržavati sve javne metode i druge konstrukte koji su definirani tim su?eljem.



Klasa se ugovorno obvezuje na implementaciju su?elja pomodu klju?ne rije?i implements. Kako je prikazano u prethodnom kôdu, klasa može u?ahuriti i druge podatkovne konstrukte te metode za pristup i manipulaciju istima, ali pri tome ne smije narušiti potpunu implementaciju ugovornog su?elja.
Drugim rije?ima, mogudnost korištenja su?elja još je jedna od blagodati polimorfizma i objektno orijentirane paradigme. Primjer višeobli?ja objekta ucenik možemo vidjeti u primjeru ispod.





Koncept su?elja se u razvoju mobilnih aplikacija za Android koristi u razli?ite svrhe, ali naj?ešda uporaba je u svrhu postizanja modularnosti te implementacije koncepta doga?aja. Ako se dva ili više modula obvežu implementirati unaprijed definirano su?elje, onda je za aplikaciju potpuno svejedno koja se od tih implementacija koristi, bududi da obje imaju iste unaprijed definirane i u su?elju opisane funkcionalnosti. Naravno, u kontekstu izrade modula, dobar arhitekturni dizajn zna?i da se sva komunikacija s modulom vrši isklju?ivo kroz su?elje. S druge strane, kod implementacije koncepta doga?aja, su?elje pomaže da se osigura da svi zainteresirani objekti ugovorno jam?e da de sadržavati metodu koju se pozove kada se doga?aj dogodi.
Jedan od na?ina razumijevanja su?elja (eng. Interface) je pomodu fizi?kih su?elja na vašem osobnom ra?unalu. Vrlo dobar primjer je USB su?elje koje definira vezu izme?u razli?itih vanjskih ure?aja i vašeg ra?unala. USB port nema vlastitu funkcionalnost, ali zato opisuje protokol razgovora kojeg svaka vanjska jedinica koja se želi spojiti na ra?unalo mora zadovoljiti. Pomodu istog USB su?elja i protokola, vaše ra?unalo razgovara s mišem, tipkovnicom, printerom i sli?no.


2.7 Pitanja za provjeru znanja
1. Koje su karakteristike i dobre osobine Java programskog jezika?
2. Što definira i ?emu služi „tip podataka“?
3. Navedite i pojasnite osnovnu sintaksu definiranja varijabli u Javi.
4. Koji su osnovni tipovi podataka?
5. Koja je razlika izme?u jednostavnih (osnovnih) i složenih (izvedenih) tipova podataka?
6. Pojasnite pojam prioritet operanda i njegove implikacije pri primjeni.
7. Kako se implementira i ?emu služi pretvorba tipova podataka?
8. Navedite specifi?nosti znakovnih tipova podataka u Javi?
9. Koje su karakteristike, prednosti i nedostaci logike vo?ene doga?ajima?
10. Koje su osnovne logi?ke strukture koje se pojavljuju pri izvršavanju programa? Pojasnite ih.
11. U kojim slu?ajevima se preporu?a koristiti selekciju tipa switch?
12. Koji su mogudi rezultati evaluacije jednostavnih, a koji složenih logi?kih izraza?
13. Koja je razlika izme?u logi?kih operatora i operatora usporedbe u Javi?
14. Kreirajte matemati?ko-logi?ki izraz koji provjerava parnost broja?
15. Koja je osnovna razlika izme?u while i do-while petlje?
16. Napišite i testirajte programski kôd koji ispisuje sve parne brojeve u nizu od 84 do 231.
17. Koja je uloga primjene metoda pri razvoju programskog proizvoda?
18. Izmijenite programski kôd iz 16. kako bi se provjera parnosti vršila pomodu metode.
19. Pojasnite pojam „objektno orijentirano“.
20. Koja je osnovna razlika izme?u objektno orijentiranog i strukturnog pristupa razvoju?
21. Koji su osnovni ciljevi primjene objektno orijentiranog programiranja?
22. Pojasnite pojmove objekta i klase objekata. ?emu služi klasifikacija?
23. Koji su osnovni koncepti objektno orijentiranog programiranja?
24. Pojasnite razliku izme?u u?ahurivanja i naslje?ivanja. ?emu služi prvi, a ?emu drugi koncept?
25. Kreirajte model klasa Prijevozno sredstvo – Automobil – Autobus, te na njemu pojasnite pojam polimorfizam?
26. ?emu služe su?elja u Javi?

2.8 Resursi za samostalan rad
* Fain Yakov. Programiranje Java. Wrox/IT Expert; 2015.
* Liang Y. Daniel. Introduction to JAVA Programming - Comprehensive Version, 9. izdanje. Boston: Pearson, 2013.
* Bergin J, Stehlik M, Roberts J, Pattis R. Karel J Robot: a gentle introduction to the art of object-oriented programming in Java. Dreamsongs Press; 2013.
* Wu C. Thomas. An introduction to object-oriented programming with Java. 5. izdanje. Boston: McGraw Hill Higher Education; 2010.
* Perry J. Steven. IBM Introduction to Java Programming: http://www.ibm.com/developerworks/java/tutorials/jintrotojava1/, pristupano u srpnju, 2016.
* Oracle Web. Object-Oriented Programming Concepts, https://docs.oracle.com/javase/tutorial/java/concepts/, pristupano u srpnju 2016

54

3 RAZVOJ ANDROID APLIKACIJA

Ovo poglavlje donosi sažet prikaz mogudnosti i osnove rada sa integriranim razvojnim okruženjem za razvoj aplikacija za Android – Android Studiom. Tako?er, u ovom poglavlju se prikazuje osnovni set klasa za razvoj Android aplikacija (Android SDK), pojašnjava temeljni koncept aplikacije – aktivnost, pojašnjava programska logika i višeslojnost aplikacije i kona?no vodi korisnika kroz proces kreiranja, kompiliranja, pokretanja i testiranja prvog projekta. Poseban naglasak je stavljen na odnos aktivnosti i pripadajudih resursa, te automatski kreirane i održavane klase R.



SADRŽAJ POGLAVLJA
Integrirano razvojno okruženje	56
Android SDK	61
Programska logika Android aplikacije	64
Alati Android Studija	72
Dodatni resursi	77


3.1 Integrirano razvojno okruženje
3.1.1 Klasifikacija razvojnih okruženja

Razvoj Android aplikacija možemo provoditi koristedi razli?ite alate i/ili razvojna okruženja. Sukladno temeljnim razlikama sve alate možemo klasificirati u tri osnovne skupine:
* Integrirana razvojna okruženja za razvoj Android aplikacija
* Razvojna okruženja za više-platformski razvoj
* Generatori aplikacija
Integrirana razvojna okruženja za razvoj Android aplikacija (eng. Integrated Development Environment (IDE)) predstavljaju cjeloviti skup alata za provedbu svih aktivnosti u procesu razvoja, testiranja i objave Android aplikacije. U usporedbi s ostalim alatima, na tržištu se nalazi tek mali broj cjelovitih integriranih razvojnih okruženja dizajniranih specifi?no za Android razvoja. Prema [16], trenutno se mogu koristiti samo ?etiri razvojna okruženja (Tablica 10).
Tablica 10. Android integrirana razvojna okruženja

NazivProgramski jezikAndroid StudioJavaBasic4AndroidBASICIntelliJIDEAJavaRFO BasicBASIC

Na spomenutom popisu se više ne nalazi Eclipse razvojno okruženje koje je do 2015. godine bilo jedino službeno podržano od strane Googlea. Me?utim, bududi da se Eclipse (kao okolina korištena za razli?ite svrhe) od po?etka koristio kao IDE „dok se ne kreira novi IDE isklju?ivo za Android“, razli?iti proizvo?a?i su pokušali kreirati vlastitu okolinu. Jedan od takvih je i IntelliJ, na kojem je nastao IntelliJIDEA, a potom i Android Studio kojeg Google preuzima kao novo službeno razvojno okruženje. Stoga, u ovom poglavlju demo se isklju?ivo baviti opisom najvažnijeg predstavnika ove skupine – Android Studiom.
Razvojna okruženja za više-platformski razvoj predstavljaju skupinu alata koji jedan programski kôd automatski transformiraju u jedan ili više ciljanih programskih kôdova. Razvojni inženjer može pisati programski kôd u specifi?nom jeziku (naj?ešde ograni?enom na domenu – DSL-u) ili u nekom od postojedih poznatih programskih jezika, a potom koristedi alate iz IDE-a za višeplatformski razvoj automatski kreira programski kôd za Android i/ili neke druge mobilne platforme. Trenutno ima više od 150 razli?itih dostupnih sustava za više-platformski razvoj, od kojih su neki spremni za komercijalnu uporabu. Sukladno [16], neki od najpoznatijih više-platformskih rješenja, uklju?ujudi i programske jezike u kojima se programira osnovna aplikacija prikazani su u tablici ispod (Tablica 11).
Tablica 11. Više-platformska rješenja

NazivProgramski jezikAIDE (Android IDE)HTML5/C/C++Application CraftHTML5CordovaHTML5CoronaLuaIntel XDKHTML5KivyPython

MIT App InventorBlocksMonkey XBASICMonoGameC#MoSyncHTML5/C/C++NS BASICBASICPhoneGapHTML5RAD Studio XEObject Pascal, C++RhoMobile SuiteRubyTelerikHTML5TitaniumJavaScriptXamarinC#
Generatori aplikacija predstavljaju alate za razvoj programskih proizvoda koji temeljem generi?kog ulaza i/ili specifikacije mogu automatski kreirati Android aplikaciju. Razvojni inženjer ima malo ili nimalo kontrole nad programskim kôdom, a ponašanje aplikacije može izmijeniti isklju?ivo izmjenom ulazne specifikacije u generator. Vedina ovih alata su još uvijek u fazi prototipa te nisu komercijalno primjenjivi. Prema [16], primjeri generatora aplikacija su AppMakr9, GoodBarber10, AppyPie11 i AppMachine12. Su?elje AppMachine generatora prikazano je na slici ispod (Slika 34).

Slika 34. Su?elje AppMachine generatora


3.1.2 Android Studio
Android Studio je trenutno jedino službeno podržano integrirano razvojno okruženje za razvoj Android aplikacija [17]. Sastoji se od niza alata koji služe za razvoj mobilnog programskog proizvoda,

9 http://www.appmakr.com/
10 https://www.goodbarber.com/
11 http://www.appypie.com
12 http://www.appmachine.com


uklju?ujudi alate za dizajn korisni?kog su?elja, pisanje programskog kôda, testiranje i otklanjanje pogrešaka, komunikaciju sa mobilnim ure?ajem, pripremu programskog proizvoda, pripremu aplikacije za objavu i sli?no. Kako bi ste instalirali Android Studio, posjetite službenu web stranicu i slijedite	upute	za	preuzimanje	i	instaliranje	razvojnog	okruženja: https://developer.android.com/studio/index.html.

Slika 35. Osnovno su?elje Android Studio razvojnog okruženja
Pogled prikazan na slici iznad (Slika 35) predstavlja osnovni razvojni pogled unutar Android studio razvojnog okruženja, ali nakon otvaranja postojedeg ili kreiranja novog projekta. Pogled je podijeljen u pet osnovnih dijelova. U vrhu se nalazi traka s alatima, s lijeve strane je panel strukture projekta, desno se nalazi radna površina, a dolje su u osnovnom pogledu paneli za nadgledanje statusa ure?aja (lijevo) i nadgledanje poruka o doga?ajima (desno).
Korisnik može po potrebi razmještati alate po ekranu koristedi klasi?ni „povuci i pusti“ princip, a važno je spomenuti da se osnovni pogled uvijek može vratiti odabirom opcije Windows -> Restore Default Layout.
Mnogi alati su dostupni na radnoj površini, ali su privremeno skriveni, te ih se može otvoriti klikom na listove (eng. Tab) s njihovim nazivima koji su raspore?eni sa svih strana razvojnog okruženja. Neki od skrivenih alata na prikazanoj slici su npr. Android Model i Gradle Console (dolje desno), Run ili Favorites (dolje lijevo), Structure (gore lijevo) i Gradle (gore desno). Kona?no, ovo je samo dio alata bududi da se mnogi od njih automatski pokredu u pozadini, ili su dostupni isklju?ivo na zahtjev korisnika, ili se pak automatski prikažu u nekoj drugoj perspektivi kao što je perspektiva za otklanjanje pogrešaka.
Važno svojstvo panela radne površine (u kojem je na slici iznad prikazan programski kôd) jeste da se dvostrukim klikom na list naziva nekog dokumenta, taj dokument otvara preko cijelog ekrana. Za povratak na originalni pogled potrebno je ponovno dvostruko kliknuti na isti list.
Za kraj, neki od spomenutih panela imaju vlastitu hijerarhiju (pod listove) kojoj se pristupa klikom na naziv podlista prikazanog u promatranom panelu. Tako na primjer, promatrajudi radni dokument activity_main.xml otvoren u radnom panelu, u donjem lijevom kutu dokumenta (i panela) možemo



Slika 36. Prikaz radnog lista (panela) s podlistovima


Nakon otvaranja postojedeg ili kreiranja novog projekta s nastavnikom, pokušajte otvoriti spomenute alate te provjeriti koje vam sve opcije pružaju.
Prilikom razvoja primjera iz ovog udžbenika, nedemo koristiti sve Android studio alate, ali demo se svakako dotaknuti onih osnovnih.
3.1.3 Kreiranje novog projekta
Proces kreiranja novog projekta u Android Studiju je vo?en ?arobnjakom za izradu projekata. Sve odluke koje korisnik mora donijeti tijekom ovog procesa mogu naknadno biti promijenjene. Proces kreiranja se sastoji od sljededih osnovnih koraka:
1. Pokrenuti Android Studio. Pri prvom pokretanju niti jedan projekt nede biti automatski otvoren. Odabrati opciju „Start a new Android Studio project“.
2. Upisati osnovne podatke o projektu:
a. naziv aplikacije,
b. domenu iz koje se automatski kreira korijenski paket proizvoda, te
c. lokaciju projekta na disku.
Korijenski paket je važan pojam koji predstavlja jedinstvenu identifikacijsku oznaku vaše aplikacije. Obi?no svi paketi/proizvodi neke tvrtke imaju isti korijen, ali razli?it naziv proizvoda. Korijen na primjer može sadržavati i oznaku države i naziv same tvrtke.
3. Odabir uklju?enih modula / ciljanih platformi i specifi?nih verzija. Za odabir su dostupni, ali neobvezni razvojni okviri: Mobilni ure?aji, nosivi ure?aji (wear), TV, android auto i nao?ale (glass). Odabirom novije verzije razvojnog okruženja, razvojni inženjer ima dostupne nove mogudnosti, ali mora žrtvovati dio korisnika kod kojih se aplikacija pisana u novom razvojnom okruženju ne može izvršavati. S druge strane, odabirom starije verzije razvojnog okruženja imamo pristup vedem broju korisnika, ali na uštrb novih mogudnosti. Tako na primjer, u trenutku pisanja ovog udžbenika, odabirom verzije API 19 (Android 4.4), dostupno je bilo 74% korisnika, za API 21 (Android 5) oko 40.5% korisnika, a za API 24 (Android 7) manje od 1% korisnika.



Slika 37. Odabir uklju?enih modula
4. Odabir tipa po?etne aktivnosti – Android Studio nudi više mogudnosti za odabir tipa po?etne aktivnosti, što ovisi o odabranoj minimalno podržanoj SDK verziji. Neke od mogudih tipova aktivnosti su osnovna aktivnost, prazna aktivnost, aktivnost preko cijelog ekrana, aktivnost za prikaz reklama, aktivnost za prikaz mape, aktivnost za autentikaciju korisnika i sli?no. Pojam aktivnosti de biti detaljno pojašnjen u sljededim poglavljima.

Slika 38. Odabir po?etne aktivnosti


5. Imenovanje aktivnosti i resursa. U ovisnosti o vrsti odabrane aktivnosti, u ovom koraku se definiraju imena uklju?enih dokumenata i resursa. Važno je primijetiti da se aktivnosti pišu u Java kôdu te se i imenuju sukladno pravilima imenovanja klasa o kojima smo govorili u poglavlju o osnovama objektno orijentiranog programiranja. S druge strane, resursi su xml dokumenti, te se imenuju malim slovima s rije?ima odvojenim donjom crtom ( _ ) kako bi java


klase i XML resursi bili logi?ki odvojeni i kako nazivi ne bi zbunjivali razvojnog inženjera pri programiranju.

Slika 39. Imenovanje aktivnosti i resursa
6. Završavanje. Klikom na Finish bit de kreiran projekt odabrane konfiguracije i otvorit de se osnovni Android Pogled pojašnjen u prethodnom primjeru.

3.2 Android SDK
Kako bi smo razumjeli ostale koncepte pojašnjene u ovom poglavlju, potrebno je pojasniti pojam Android SDK koji se odnosi na set klasa i osnovnih alata ciljano kreiranih za razvoj aplikacija za Android. Ovaj set klasa i pripadajudih alata je temeljen na Java setu klasa (Java SDK), te zajedno sa alatima dostupnim u Android Studiju ?ini minimum potreban za razvoj aplikacija za Android. Prvi set klasa za Android (API 1) objavljen je 2008. godine, a posljednji je API 24 koji se može pokretati samo na Android 7 operacijskom sustavu, te je objavljen u kolovozu 2016. godine.
Brojne su novosti koje donosi API 24. U svrhu kratkog uvoda može se navesti da se od ove verzije mogu pokretati dvije aplikacije istovremeno (podjelom ekrana na dva dijela), da je u SDK uklju?en novi set klasa za rad s 3D grafikom (Vulkan API), optimizaciju potrošnje baterije, povedanu sigurnost, stabilnost, upravljanje memorijom i korisni?ko iskustvo.
3.2.1 Aplikacijski stog
Sukladno [18], Android softverski stog je kreiran na Linuxu te sadrži najvažnije komponente kako je prikazano na slici ispod (Slika 40). Na dnu stoga, u osnovi, nalazi se Linux jezgra (eng. Linux Kernel) koja je odgovorna za osnovni pristup hardverskim jedinicama i upravljanje napajanjem. Na drugoj razini se nalazi Androidov sloj za apstrakciju hardvera (eng. Hardware Abstraction Layer – HAL) koji se s jedne strane oslanja direktno na jezgru, a s druge strane kroz standardna su?elja omoguduje višim razinama korištenje spomenutih hardverskih komponenti.
Na tredoj razini se nalaze nativne Linux biblioteke pisane u C/C++ programskom jeziku koje se tako?er mogu koristiti s viših slojeva, to jest iz sistemskih i korisni?kih aplikacija. S druge strane se nalazi Android Runtime (ART) kao temeljni stroj za izvršavanje aplikacija koji izvršava svaku aplikaciju u vlastitom procesu s vlastitom ART instancom. ART je od verzije API 21 u potpunosti zamijenio stari


virtualni stroj (Dalvik) te novim mogudnostima kao što su kompiliranje u naprijed (eng. Ahead of time compilation) omogudio znatno brže instaliranje, pokretanje i izvršavanje aplikacije.

Slika 40. Android aplikacijski stog
U kona?nici se nalazi Java API razvojni okvir koji ?ini dostupnim sve funkcionalnosti Android OS-a uklju?ujudi upravitelje (eng. Managers), pružatelje sadržaja (eng. Content providers) i elemente korisni?kog su?elja (eng. View System) za izgradnju sistemskih i korisni?kih aplikacija. Povrh svega, korisni?ke aplikacije mogu pozivati i koristiti ugra?ene sistemske aplikacije za ostvarenje željenih funkcionalnosti.
3.2.2 Struktura SDK-a
Osnovna struktura seta za razvoj aplikacija za Android (Android SDK) prikazana je na slici pored (Slika 41). SDK sadrži moguda proširenja, alate za kompiliranje, dokumentaciju, dodatne resurse, podatke o licencama, podatke o podržanim platformama, alate specifi?ne za platforme, izvorne kôdove, slike sustava, ostale alate te dva vrlo važna upravitelja: upravitelj SDK-a i upravitelj virtualnih ure?aja.
Pomodu SDK upravitelja korisnik može dodavati, brisati ili ažurirati razli?ite verzije SDK-a ili samo elemente iz pojedinih verzija, dok pomodu AVD upravitelja korisnik može pokretati virtualne ure?aje s razli?itim verzijama Androida, ovisno o tome što sve ima instalirano.


Jedan od alata, vrijedan posebne pozornosti, koji se nalazi u mapi
platform-tools naziva se ADB. Rije? je o pozadinskom alatu kojeg pokrede
Android Studio, a koji je odgovoran za omogudavanje komunikacije izme?u


Slika 41. Android SDK struktura


Kona?no, od posebnog zna?aja za ovaj pregled je sadržaj mape sources koja sadrži sve osnovne (nativne) pakete koji se mogu koristiti pri razvoju aplikacija za Android. Popis paketa, bez detaljnog prikaza klasa unutar njih prikazan je na slici ispod (Slika 42).


Slika 42. Dio osnovnih paketa dostupnih u Android SDK-u
Paketi koji se koriste vrlo ?esto i neizostavni su u razvoju svake aplikacije su util, view, support, text, widget, app, content, preference i system. Naravno, ovaj popis paketa nije kona?an, jer se u Setu tako?er nalaze i Java paketi, org paketi i drugi.
3.2.3 Instaliranje Android API-a
U svrhu dodavanja, promjene ili brisanja instaliranih SDK komponenti, potrebno je pokrenuti SDK manager. Isti se može pokrenuti kroz Android Studio (Tools -> Android -> SDK Manager), ili kao zaseban program iz mape kako je prethodno navedeno.

Slika 43. Android Studio SDK upravitelj
U svrhu jednostavnijeg i boljeg prikaza verzija predlažem korištenje samostalnog SDK upravitelja koji se može pokrenuti klikom na link u donjem lijevom uglu ekrana prikazano na slici iznad (Slika 43).



Slika 44. Android SDK upravitelj
Za potrebe vježbi prihvatite ažuriranje bilo kojeg od postojedih instaliranih paketa, te instalirajte ili dodajte posljednje verzije Android SDK Tools, SDK Platform Tools, SDK Build-tools iz mape Tools, Documentation for Android SDK, SDK Platform, Samples for SDK, ARM EABI v7a System Image iz mape Android 7 (API 24) te Android Support Library, Google Play Services i Google USB Driver iz mape Extras. SDK manager je prikazan na slici iznad. Provjerite i ostale dostupne komponente te instalirajte po potrebi.

3.3 Programska logika Android aplikacije
Razvoj aplikacija za Android je uvelike vo?en zahtjevom za strogim odvajanjem korisni?kog su?elja od programske logike. Taj zahtjev je toliko striktan da se u fazi razvoja programskog proizvoda koriste razli?iti jezici za opis dvaju spomenutih aplikativnih slojeva: Java za opis programske logike i XML za opis i dizajn su?elja.
Koristedi panel Project i pogled Android (Slika 45) koji služe za prikaz strukture projektnih dokumenata, promatranih kao elemente Android aplikacije, možemo vidjeti da su sve Java klase smještene u java ?vor projektnog stabla, a svi opisi resursa su smješteni u res ?vor projektnog stabla.
Osim navedenih u manifest ?voru je smješten osnovni aplikacijski proglas (eng. Manifest) koji definira sve zahtjeve aplikacije, a u potpuno odvojenoj cjelini pod nazivom Gradle Scripts su smještene sve konfiguracijske skripte potrebne za Gradle – automatski proces koji u realnom vremenu analizira i po potrebi
kompilira programski kôd.
Detaljnijom analizom sadržaja java ?vora, primijetit demo da


su sve programske klase smještene u osnovni aplikacijski paket, te dva pomodna paketa koji služe za testiranje programskog proizvoda. Mi demo kroz ovaj priru?nik koristiti isklju?ivo osnovni aplikacijski paket hr.heureka.memento i u njemu demo kreirati vlastitu strukturu paketa. S druge strane, ?vor res sadrži mapu layout u kojoj su smještene XML datoteke koje opisuju izgled aplikacije, mapu mipmap koja sadrži grafi?ke resurse te mapu values u kojoj su dokumenti koji sadrže vrijednosti u obliku aplikacijskih resursa.
3.3.1 Android aktivnosti
Aktivnost (eng. Activity) predstavlja aplikativnu dretvu koja se izvršava u aplikativnom kontekstu te kojoj je dana mogudnost da u vlastitom prozoru prikaže korisni?ko su?elje [19]. Aktivnost tipi?no predstavlja jednu korisni?ku funkcionalnost nad programskim proizvodom, te u interakciji s korisnikom i s operacijskim sustavom kontrolira elemente korisni?kog su?elja.

U prethodnom primjeru programskog kôda možemo vidjeti da klasa MainActivity naslje?uje klasu AppCompatActivity (podklasa klase Activity iz Android razvojnog okruženja) koja omoguduje kompatibilnost sa svim verzijama operacijskog sustava koje smo pri kreiranju projekta ozna?ili kao ciljane verzije. Kako bi prevoditelj poznavao sve klase koje se koriste u primjeru, potrebno je uvesti (eng. import) dvije nadklase iz paketa support i os.
Trenutno, unutar klase postoji implementacija samo jedne metode, koja je u ovom slu?aju nadja?anje metode onCreate iz nadklase. Sukladno konvenciji pisanja naziva metoda u Androidu, svaka metoda koja odgovara na neki doga?aj ima prefiks na (eng. on). Tako metoda onCreate odgovara na doga?aj kreiranja aktivnosti, te se izvršava odmah nakon što je aktivnost kreirana.
Gornji kôd u na?elu govori: „Kada kreiraš aktivnost dodjeli joj dizajn grafi?kog su?elja iz R.layout.activity_main“. Kroz ovaj predmet promovirat demo nekoliko dobrih praksi programiranja. Uz navedenu ponovnu iskoristivost (engl. reusability), ovdje je prikazan primjer višeslojne arhitekture. Dizajn grafi?kog su?elja (/res/layout/activity_main.xml), odvojen je od programskog kôda (/src/hr.heureka.memento/MainActivity.java).
Kako bi smo razumjeli ponašanje aktivnosti, sukladno [20] prikazat demo dijagram mogudih stanja aktivnosti i doga?aje koji iniciraju promjenu tih stanja (Slika 46).



Slika 46. Stanja aktivnosti u Android aplikaciji
Stoga, aktivnost može biti u jednom od sljededih stanja:
* Aktivna – kada je aktivnost na vrhu stoga, vidljiva, ozna?ena, ?eka na korisnikovu interakciju ili prikazuje neke podatke. Aktivnosti niže u stogu su pauzirane ili zaustavljene.
* Pauzirana – kada vaša aktivnost jest vidljiva no nije u fokusu, ona se pauzira. Primjerice kada se otvori Da/Ne dijalog.
* Zaustavljena – Kada nije vidljiva, aktivnost u Androidu se zaustavlja. Ona ostaje u memoriji zajedno sa informacijama stanja te postaje kandidat za terminiranje. U ovom trenutku preporu?ljivo je pohraniti stanje. Kada je aktivnost zatvorena, ona postaje neaktivna.
* Uništena – nakon što je aktivnost zaustavljena, odnosno prije nego je pokrenuta, ona je neaktivna. Sve neaktivne aktivnosti su uklonjene iz aplikacijskog stoga.
Vidljivi životni ciklus aktivnosti je izme?u onStart i onStop doga?aja. U tom periodu aktivnost je vidljiva korisniku.
* onStop - naj?ešde se koristi za zaustavljanje animacija, dretvi ili ?ita?a senzora.
* onStart – nastavlja rad aktivnosti (ili onRestart koja ju pokrede iznova)
Aktivni životni ciklus aplikacije po?inje sa onResume i završava sa onPause doga?ajima. Aktivnost je aktivna kada je u fokusu odnosno korisnik je u interakciji s njom. Aktivno stanje aktivnosti završava s prikazom nove aktivnosti, gašenjem ure?aja ili kada aktivnost izgubi fokus. Tipi?ni primjer ove interakcije je pojava dijaloga. Odmah nakon onPause poziva se onSaveInstanceState koja daje mogudnost spremanja stanja i UI-a. Ti podaci prenose se preko Bundle klase. ?esto se stanje sprema kod onPause doga?aja jer poslije njega aktivnost može biti ugašena bez upozorenja.
Aplikacija za Android ne kontrolira životni tijek svojih procesa ved to ?ini Android runtime, a stanje svake aktivnosti doprinosi u odluci odre?ivanja prioriteta roditeljske aplikacije. Android runtime prema prioritetu odlu?uje o prekidanju pojedinih aplikacija. Stanje svake aktivnosti odre?eno je stogom aktivnosti koji radi na LIFO (Posljednji ulazi prvi izlazi – eng. Last In First Out) principu. Kada se pokrene nova aktivnost, trenutni ekran ide na vrh stoga. Kada korisnik navigira korak natrag, grafi?ko su?elje trenutne aplikacije se gasi, aktivnost se gasi (ukoliko se ne radi o višedretvenim sustavima, procesima, prioritetnim aktivnostima itd.), izlazi iz stoga i prva slijededa aktivnost dolazi na zaslon. Detalji ovakvog pristupa prikazani su na sljededoj slici (Slika 47).







3.3.2 Resursi

Slika 47. Stog aktivnosti

Programski kôd prikazan na po?etku prethodnog poglavlja odmah pri kreiranju aktivnosti dohvada identifikator resursa koji definira izgled korisni?kog su?elja, te ga proslje?uje metodi setContentView koja de ga prikazati korisniku. Rije? je, naravno, o sljededoj liniji kôda:

Ovdje bi smo posebnu pozornost obratili na dvije stvari. Prvo, na na?in na koji su resursi (definirani pomodu XML-a) korišteni u programskoj logici koja se piše u Javi, a drugo na samu definiciju resursa u XML-u.
Klju?nu ulogu u povezivanju resursa i programskog kôda ima automatski generirana klasa R, koja sadrži jedinstvene identifikatore svih resursa definiranih u sklopu projekta. Resursi su u toj klasi stati?ki i organizirani su hijerarhijski sukladno mapama u koje su fizi?ki smješteni. Svaki puta, kada korisnik promijeni resurse definirane u XML-u, ako je rezultirajudi XML validan, Android Studio de automatski osvježiti klasu R te se odmah potom resursi mogu koristiti i u programskom kôdu.
Važno je naglasiti da pogreške u XML-u rezultiraju nemogudnošdu kreiranja klase R, nakon ?ega de Android Studio javiti pogreške i u programskom kôdu gdje god se spomenuta stati?ka klasa koristila. U tom slu?aju nije potrebno ispravljati programski kôd, ved pronadi i ukloniti pogreške koje onemoguduju kreiranje klase R.
Za kraj kratkog osvrta na klasu R, treba imati na umu da su svi identifikatori kreirani unutar klase R cjelobrojnog tipa podataka (int) te da su imenovani identi?no kao i resurs koji je korisnik definirao. Stoga, promotrimo XML opis resursa activity_main koji se koristi u prethodnom primjeru.



Bududi da se dokument naziva activity_main.xml i nalazi se u mapi layout, klasa R sadrži identifikator toga resursa imenovan R.layout.activity_main. Me?utim, R sadrži i sve druge resurse eksplicitno imenovane u ovom dokumentu. To su, primijetit dete, objekt tabs klase TabLayout i objekt viewpager klase ViewPager. Oba ova resursa imenovana su definiranjem id atributa dodjeljujudi mu vrijednost "@+id/naziv_resursa".
Stoga, u programskom kôdu, ove identifikatore možemo pronadi koristedi R.id.naziv_resursa.
3.3.3 Kvalifikatori resursa
Još jedna specifi?nost razvoja za Android jest mogudnost korištenja kvalifikatora resursa. Kvalifikator je dodatna oznaka pridružena resursu koja taj resurs kvalificira za korištenje u specifi?nom kontekstu na koji se taj kvalifikator odnosi. Drugim rije?ima, možemo kreirati dva resursa koji opisuju izgled activity_main pogleda. Me?utim, jedan od njih možemo kvalificirati da bude korišten kada je ure?aj u uspravnom položaju (eng. Portrait), a drugi da bude korišten kada je ure?aj u horizontalnom položaju (eng. Landscape). Kako je prikazano na slici ispod (Slika 48), moguda je i kombinacija razli?itih kvalifikatora. Tako de iz primjera ispod, resurs koji se upravo kreira, biti korišten samo kada se aplikacija pokrene na ure?aju s hrvatskim jezikom (hr), malih dimenzija ekrana (small) u uspravnom položaju (portrait).



Slika 48. Kvalificiranje resursa
Ovako kreirani resurs activity_main bit de smješten u mapu layout_hr_small_port. Me?utim, prilikom pristupanja resursu iz programskog kôda, nije potrebno navoditi kvalifikatore. Dovoljno je pristupiti resursu R.layout.activity_main, a operacijski sustav de sam potražiti onu verziju resursa koja najbolje odgovara kontekstu u kojem se aplikacija nalazi. U najgorem slu?aju, bit de korišten osnovni (eng. Default) resurs.
3.3.4 Android Manifest
Važan konstrukt svake aplikacije za Android je dokument proglasa zapisan u AndroidManifest.xml datoteci.


Proglas je u novijim verzijama rastereden elemenata koji su se odnosili na proces kompiliranja programskog proizvoda, te sadašnja verzija sadrži samo aplikativno bitne oznake. Tako se trenutno u proglasu nalazi naziv korijenskog paketa, te opis aplikacije koji sadrži aplikativne atribute kao što su ikona, naslov aplikacije, tema i sli?no. Tako?er, u proglasu moraju biti pobrojani i svi zahtjevi aplikacije prema sustavu ili drugim aplikacijama. Tako ova aplikacija trenutno ne zahtijeva nikakva posebna dopuštenja od strane korisnika (kao npr. za pristup Internetu, osobnim podacima, porukama, kontaktima i sli?no).
Posebnu cjelinu u proglasu, unutar aplikacijske oznake (eng. Tag) ?ine oznake koje opisuju aplikacijske aktivnosti. Trenutno je prijavljeno korištenje samo jedne aktivnosti (.MainActivity), kojoj je korištenjem filtera namjera (eng. Intent filtera) na akciju zahtjeva sustava za pokretanjem glavne (eng. Main) aktivnosti i pokretanjem same aplikacije definirano da bude glava aplikacijska aktivnost, to jest aktivnost od koje de se aplikacija po?eti izvršavati.
Pogledajte sadržaj AndroidManifest.xml dokumenta kako bi ste pronašli informacije koje sadržava. Detaljno o proglasu aplikacija za Android možete pro?itati u službenoj dokumentaciji [21].


3.3.5 Gradle
Gradle predstavlja dodatni alat (eng. Plugin) razvijen od trede strane (Gradle Inc.) koji se pri razvoju aplikacija za Android koristi za automatiziranje procesa izgradnje (eng. Build) programskog proizvoda (eng. Build automation) [22], [23]. Gradle u osnovi predstavlja poseban sustav koji u suradnji s Android studiom provodi zadane operacije nad programskim kôdom te automatski kreira izlazni dokument spreman za pokretanje na ART-u.
Gradle se tako?er koristi u svrhu upravljanja paketima uklju?enim u programski proizvod to jest paketima o kojima programski proizvod ovisi (eng. Dependencies), ali i za kreiranje vlastite programibilne/promjenjive logike izgradnje programskog proizvoda [24], [25].
Gradle skripte se mogu definirati na razini cijelog projekta, ali i na razini svakog pojedinog aplikacijskog modula. Primjer ispod prikazuje sadržaj Gradle skripte za glavni aplikativni modul app.



Iz priloženog dokumenta se može zaklju?iti da Gradle ovaj modul promatra kao aplikaciju za Android primjenom odgovarajudeg dodatka (eng. Plugin). Potom, slijedi popis atributa Android aplikacije, uklju?ujudi verzije Android SDK-a, konfiguraciju aplikacije i tip izgradnje aplikacije. U kona?nici Gradle sadrži popis dodatnih modula koji uklju?uje sve jar datoteke u mapi libs, ali i dvije biblioteke eksplicitno navedene pomodu compile naredbe. Posljednja biblioteka junit se koristi samo kod kreiranja testne aplikacije.
Osim prikazanog dokumenta za Gradle, kroz panel Project i pogled Android, u grani Gradle Scripts
možete provjeriti i analizirati i ostale Gradle skripte i postavke.


3.3.6 Namjera (Intent)
Namjera (eng. Intent) predstavlja poseban mehanizam proslje?ivanja poruka koji se može koristiti unutar i izme?u aplikacija. Namjera deklarira namjeru da de aktivnost ili servis izvršiti neku radnju, odnosno za eksplicitno pokretanje aktivnosti ili servisa. Namjerom se može pristupiti interakciji s bilo kojom komponentom aplikacija instaliranih na Android ure?aju. Time Android ure?aj postaje platforma me?usobno povezanih, neovisnih komponenti koje zajedni?ki ?ine povezani sustav. Ako želite sami kreirati aktivnost koja može osluškivati namjere drugih aplikacija potrebno ju je proglasiti slušateljem namjera (eng. Intent Receiver). Me?utim, ta funkcionalnost izlazi iz okvira ovog priru?nika.
Za primjer korištenja klase Intent, prikazat demo programski kôd za pokretanje druge aktivnosti.




Dakle, kreirali smo objekt namjere – Intent, u koji smo proslijedili podatke o trenutnom kontekstu (this) o aktivnosti koju želimo pokrenuti (NewActivity.class), te dodatno i poruku ozna?enu klju?nom rije?i „PORUKA“ (message). Operacijski sustav de izvršiti namjeru ?im se za to steknu uvjeti. U vedinu slu?ajeva, uvjeti su ispunjeni odmah, me?utim u izvanrednim situacijama operacijski sustav može privremeno ili potpuno odgoditi izvršenje namjere, na primjer ako se u istom trenutku dogodi telefonski poziv koji ima viši prioritet izvršenja.


3.4 Alati Android Studija
U perspektivi ovoga priru?nika, te provedbe prakti?nog dijela nastave razvoja mobilne aplikacije, sve alate u Android Studiju možemo podijeliti u sljedede skupine:
* alati za razvoj
* alati za otkrivanje pogrešaka
* ostali važni alati
3.4.1 Alati za razvoj
U fazi razvoja programskog proizvoda koristimo alate za pisanje programskog kôda u Javi, pregled i izmjenu strukture projekta i definiranje projektnih resursa.
Panel Project sa razli?itim pogledima koristimo u svrhu pregleda i izmjene strukture projekta, dodavanje modula, dokumenta i resursa. Rad s ovim alatom je intuitivan i svodi se na korištenje kontekstualnih izbornika (desni klik miša) otvorenih na odgovarajudim ?vorovima prikazanim u strukturi.

Slika 49. Razli?iti pogledi Project panela
Slika 49 prikazuje alat za prikaz strukture projekta u Android pogledu (lijevo), opciju promjene pogleda (u sredini), te primjer kontekstualnog izbornika na ?voru res koji omoguduje naredbom New kreiranje novih izbornika (desno).
Alat za pisanje programskog kôda (Java editor) prikazan je u središnjem (radnom) panelu. Taj alat upotpunjuje pisanje programskog kôda s nekoliko važnih mogudnosti. Prva mogudnost je ozna?avanje sintakse (eng. Syntax Highlighting) kojom alat prepoznaje klju?ne rije?i programskog jezika Java, uklju?ene klase, korištene varijable i sli?no. Tako?er, alat prepoznajudi programske konstrukte automatski formatira programski kôd i ?ini ga ?itljivijim. Druga važna mogudnost ovog alata je savjetnik (eng. Intellisense). Savjetnik prikazuje razvojnom inženjeru mogudnosti korištenja programskih konstrukta u ovisnosti o kontekstu, ili bolje re?eno, o liniji kôda koja se u danom trenutku kreira. Primjer korištenja alata je prikazan na slici ispod (Slika 50).



Slika 50. Alat za pisanje programskog kôda
Posebno je važno spomenuti da alat za pisanje programskog kôda ima dosta dodatnih mogudnosti kojima se može pristupiti koristedi kontekstualni izbornik ili naredbe Code, Analyze, Refactor u glavnom aplikacijskom izborniku.
Drugi modus alata za razvoj odnosi se na skup alata koji omoguduju definiranje resursa. Pri tome skoro za svaki resurs postoji specifi?an alat koji kroz grafi?ko su?elje omoguduje definiranje resursa. Zajedni?ka karakteristika svih ovih alata je da imaju izlaz u obliku XML dokumenta koji opisuje svaki pojedini resurs.



Slika 51. Alat za dizajn ekrana
Opis funkcionalnosti svih ovih alata nije tema ovog priru?nika, ali bududi da je rad u tim alatima intuitivan, ved nakon nekoliko kreiranih primjera u?enik i/ili inženjer de stedi dovoljno iskustva kako bi mogao koristiti njihove mogudnosti.
3.4.2 Alati za otkrivanje pogrešaka
Pogreške se pri razvoju aplikacija za Android otklanjaju još tijekom razvoja, pri ?emu se koriste upravo spomenuti alati za prikaz strukture (u kojem su podcrtani paketi, to jest klase i resursi) koji imaju sintakti?ke pogreške.
Posebna pomod je alat Messages koji eksplicitno navodi uzroke pogrešaka i prijedloge rješenja istih (Slika 52). Iako su ove poruke u velikoj vedini slu?ajeva korisne, ponekad mogu biti i pogrešne te mogu usmjeriti razvojne inženjere u pogrešnom smjeru.

Slika 52. Panel poruka
Spomenuti alat omoguduje i automatsko fokusiranje one linije kôda u kojoj je prepoznat problem jednostavnim dvostrukim klikom miša na odgovarajudu poruku. Za kraj, u ovom alatu se prikazuju i druge relevantne poruke, a ne samo poruke o pogreškama.
Posljednji set alata koji treba spomenuti u svrhu otkrivanja pogrešaka prilikom izvršavanja programskog proizvoda su alati Android Monitor i Debug. Pomodu Android Monitor alata može se vidjeti status izvršavanja aplikacije na ure?aju te log poruke same aplikacije, sustava ili poruke o pogrešci kako je to prikazano na slici ispod (Slika 53).



Slika 53. Android Monitor alat
Debug alat sura?uje sa alatom za pisanje programskog kôda pri ?emu se izvršavanje aplikacije može pauzirati, izvršavati liniju-po-liniju, te uz pomod pomodnih panela dobiti uvid u stanje memorije, instancirane objekte i vrijednosti njihovih privatnih i javnih varijabli.

Slika 54. Alat Debug i pomo?ni alati
Slika 54 prikazuje mogudnosti uvida u stanje memorije i pronalaska pogrešaka u realnom vremenu. U donjem dijelu slike je alat Debug sa stogom naredbi (Frames), lokalnim varijablama (Variables), te vlastitim definiranim pogledima na memoriju (Watches). Razvojni inženjer dodavanjem to?aka prekida izvršenja kôda (eng. Breakpoint) može ozna?iti gdje želi zaustaviti izvršenje kôda, te pomodu kontekstualnog izbornika dodati pogled na objekt ili varijablu (eng. Watch). To?ka prekida na slici iznad je kreirana na liniji kôda ActiveAndroid.initialize(this);
3.4.3 Ostali važni alati
Ostali važni alati Android Studija odnose se na infrastrukturne alate koji omoguduju ažuriranje samog Studija, upravljanje setom klasa za razvoj aplikacija za Android (SDK Manager), alatom za upravljanje virtualnim i povezanim ure?ajima (AVD Manager) te alat za upravljanje trenutno spojenim ure?ajem (Android Device monitor).



Slika 55. Android Device Monitor


Android Device Monitor (Slika 55) pokredemo naredbom Tools -> Android -> Android Device Monitor. Pomodu ovog alata se može pristupiti dokumentima i podacima na ure?aju, napraviti sliku ekrana s ure?aja i sli?no.


3.5 Pitanja za provjeru znanja
1. Koja je razlika izme?u integriranih razvojnih okruženja i generatora aplikacija?
2. U kojim slu?ajevima je prikladno koristiti generatora aplikacija?
3. Od kojih se sve alata sastoji Android studio?
4. Kreirajte razli?ite vrste projekata za Android i prou?ite projektne materijale koji su automatski kreirani. Pokušajte prepoznati ugra?ene elemente (klase, resurse, biblioteke) i njihove me?usobne veze.
5. Kako imenujemo aktivnosti (i ostale klase), a kako resurse?
6. Pojasnite slojeve aplikacijskog stoga Android operacijskog sustava.
7. ?emu služi set za razvoj softvera (SDK) i koje su osobine Android SDK-a?
8. Koji su osnovni elementi aplikacije za Android? Pojasnite proglas, aktivnosti, resurse i Gradle skripte.
9. Što je aktivnost Android aplikacije? Koja sve stanja aktivnost može imati i koji se doga?aji okidaju pri prijelazu stanja?
10. Kako funkcionira stog aktivnosti? Kada se aktivnost stavlja, a kada skida sa stoga?
11. ?emu služe kvalifikatori resursa? Pri definiranju novog resursa analizirajte koji sve tipovi kvalifikatora postoje.
12. ?emu služi proglas (manifest) aplikacije za Android?
13. Kako funkcionira sustav izgradnje (eng. build) aplikacija za Android? ?emu služi Gradle?
14. Analizirajte alate Android Studija. ?emu služi alat Android monitor?
15. Koje alate koristimo za pisanje programskog kôda, a koje za otkrivanje pogrešaka?
16. Pojasnite kako se koristi Watch panel pri otkrivanju pogrešaka.
17. Koji su ostali važni alati integrirani u Android Studio?

3.6 Resursi za samostalan rad
* Gargenta Marko. Nau?ite Android. O’Reilly/IT Expert; 2011.
* Gimson Matthew. Android programming: complete introduction for beginners : step by step guide how to create your own Android app easy!, CreateSpace Independent Publishing Platform 2015.
* Beer Paula, Simmons Carl. Hello app inventor!: Android programming for kids and the rest of us. Shelter Island, NY: Manning Publications Co; 2015.
* Gerber Adam, Craig Clifton. Learn Android Studio: build Android apps quickly and effectively. Berkeley, CA: Apress; 2015.



4 RAD S PODACIMA

Ovo poglavlje daje pregled i primjer rada s podacima kod razvoja mobilnih aplikacija za Android ure?aje, prvenstveno mobilne telefone i tablete, a podijeljeno je u tri glavna dijela. Prvi dio poglavlja koncentrira se na pregled dostupnih mogudnosti za spremanje ne strukturiranih ili slabo strukturiranih podataka te rad sa datotekama. U drugom djelu fokus na rad sa mobilnom bazom podataka, a posebna pozornost dana je modeliranju podataka, te prijenosu modela podatka u programski kôd. Uz opis rada Android operacijskog sustava sa SQLite bazom podataka, detaljan primjer napravljen je korištenjem Active Android biblioteke koja zna?ajno olakšava i ubrzava rad sa mobilnom bazom podataka. Tredi dio ovog poglavlja odnosi se na rad s udaljenim podacima odnosno web servisima. Uz opis osnova koje su potrebne za razumijevanje na?ela rada i korištenja web servisa, primjer njihovog korištenja u razvoju Android mobilnih aplikacija prikazan je uz pomod biblioteke Retrofit.



SADRŽAJ POGLAVLJA
Pohrana podataka	80
Zapis podataka u datoteke	85
Rad sa mobilnom bazom podataka	92
Rad s web servisima	106
Dodatni resursi	117


4.1 Pohrana podataka
Angry Birds, Skype, Twitter, samo su neke od mobilnih aplikacija koje su na Android ure?ajima na listi najinstaliranijih sa nešto više od sto milijuna jedinstvenih instalacija, dok su YouTube i WhatsApp Messenger primjer onih koje imaju više od milijardu jedinstvenih instalacija. Iako na prvi pogled aplikacije nemaju zna?ajnijih karakteristika koje dijele, veže ih potreba za pohranom podataka. Danas, vedina najkorištenijih mobilnih aplikacija na Android Play-u implementira neki oblik pohrane, prikaza ili obrade podataka, stoga je izuzetno važno razumjeti koje mogudnosti rada s podacima su dostupne razvojnim inženjerima za Android.
Kako navodi službena Android dokumentacija, vedina ne-trivijalnih aplikacija ima potrebu pohrane korisni?kih postavki, spremanja zna?ajnije koli?ine raznolikih datoteka ili korištenje neke vrste strukturiranog zapisa podataka. Osnovne mogudnosti pohrane podataka na Androidu su, a) klju?- vrijednost skupovi, b) datoteke i c) baza podataka.
Klju?-vrijednost skupovi (engl. key-value pairs) zapisuju se u obliku XML datoteke koja se sastoji od parova koji sadrže dvije karakteristike, klju? i vrijednost. Klju? je obi?no ime kojim se pristupa do neke vrijednosti. Primjer ovakvih skupova datoteka može se pronadi u /res/values svake Android mobilne aplikacije. Razmotrimo primjer /res/values/dimens.xml datoteke.



U navedenom primjeru, klju? nazvan name sadržaja „activity_horizontal_margin“ dohvada vrijednost 16dp. Klju?-vrijednost skupovi obi?no se koristi za zapis manje koli?ine podataka.
Datoteke se koriste za zapis vedeg skupa podataka na datote?ni sustav kojemu je pristup nalik onome korištenom kod klasi?nih datote?nih sustava operacijskih sustava poput Linux-a, Windows-a, itd. Aplikacije koje koriste mogudnost rada s datotekama za vrijeme instalacije traže posebnu dozvolu kojom korisnik dozvoljava pristup datote?nom sustavu, bilo internom (na kojoj je instaliran Android operacijski sustav) ili eksternom (podatkovni dio memorijskog prostora, fizi?ki ure?aj poput micro-SD kartice ili simulirana micro-sd kartica).
Obzirom na pristup datote?nom prostoru, datoteke mogu biti javne ili privatne. Javne datoteke su one koje iako neka aplikacija kreira, omogudeno je drugim aplikacijama da ih koriste, a za vrijeme uklanjanja aplikacije koja ih je kreirala, one se ne brišu. Primjer takvih datoteka su fotografije ili datoteke preuzete s weba.
Privatne datoteke su one kojima je vlasnik isklju?ivo aplikacija koja ih kreira i za vrijeme deinstalacije iste trebaju biti uklonjene. Android operacijski sustav svaku aplikaciju tretira kao korisnika, a kako Android pripada Linux obitelji operacijskih sustava, prema sustavu prava pristupa, druge aplikacije, odnosno korisnici, nemaju pristup privatnom direktoriju korisnika, odnosno aplikacije. No, ponekad, to je omogudeno ukoliko korisnik ima root prava koja omoguduju ?itanje /Data/Dana/ direktorija gdje se nalaze privatni podaci svake aplikacije. Po zadanim postavkama, ure?aji su zaklju?ani i ne daju tu mogudnost, no popularno nazvanim procesom „rootanja“ omoguduje korisniku da pristupi tim podacima. ?itatelju ostavljamo na razmišljanje koje su prednosti i koji su nedostaci za obi?nog korisnika, za stru?nog korisnika i za malicioznog korisnika.


Baza podataka omoguduje strukturirani zapis, sli?no kao i kod privatnih datoteka, pristup bazi podataka u na?elu je dozvoljen samo aplikaciji koja ju kreira i koristi. Takav zapisa podataka omoguduje formalnu specifikaciju entiteta, njihovi atributa i tipova, te složene odnose s drugim podacima. Kao zadani sustav za upravljanje bazom podataka Android koristi SQLite, no postoje i druga proširenja, primjerice BerkeleyDB, Couchbase Lite, Realm, itd.
4.1.1 Mogudnosti pohrane podataka
Odabir na?ina perzistencija podataka, odnosno fizi?ke lokacije ovisi o vrsti mobilne aplikacije i potrebama korisnika. Obzirom na to, kod Androida postoje sljedede mogudnosti zapisa podataka [26]:
- Zajedni?ke postavke (engl. shared preferences) – pohrana podataka pomodu klase SharedPreferences koja omoguduje pohranu klju?-vrijednost parova. Podržani tipovi podataka su boolean, float, int, long i string. Obi?no se koristi za pohranu postavki korisnika na razini aplikacije [27] [28].
- Unutarnja memorija – kako je ranije re?eno, datoteke pohranjene u internoj memoriji su privatne, i pohranjene na na?in da njima ne mogu pristupati druge aplikacije, a direktno ni korisnik. Nakon deinstalacije aplikacije, datoteke s interne memorije se uklanjaju, a zapisane su na lokaciji /Data/Data/paket/files.
- Vanjska memorija – primarno se odnosi na memoriju ?iju je primjenu mogude zabraniti operacijskom sustavu, odnosno memoriju koja nije nužno trajno prisutna, bila ona fizi?ki ili softverski uklonjiva (engl. unmount). Datoteke zapisane na vanjsku memoriju su dostupne drugim aplikacijama i korisniku, a putem USB pristupa je moguda i njihova manipulacija. Za pristup tom mediju, mobilna aplikacija mora imati dozvolu.
- SQLite database – ranije spomenut strukturirani zapisa podataka.
- Mrežno dostupna memorija – kada je dozvoljen i omoguden pristup mreži, mogude je zapisivati i dohvadati podatke na mrežno dostupnim servisima.
Naredna poglavlja demonstriraju pohranu podataka korištenjem klju?-vrijednost parova, datoteka i baze podataka. Kao demonstracijski primjer na kojima de biti pokazani navedeni koncepti, koristi se jednostavna aplikacija nazvana CookBook kroz koju su pokazani demonstracijski primjeri. CookBook je aplikacija koja omoguduje pohranu recepata i sastojaka istih.


4.1.2 Klju?-vrijednost parovi
Raniji primjer XML-a koji prikazuje na koji na?in se zapisuju klju?-vrijednost parovi može se koristiti na dva na?ina. Prvi se odnosi na ru?ni (programskim kôdom) zapis i ?itanje podataka, dok se drugi odnosi na polu-automatiziran pristup, pri ?emu programer u XML datoteci definira koji podaci se zapisuju.
4.1.3 Korištenje parova klju?-vrijednost putem programskog kôda
Klasa zajedni?kih postavki, SharedPreferences omoguduje zapis i ?itanje nekoliko prethodno definiranih tipova podataka. Tipi?an primjer zapisa para klju?-vrijednosti definira se kao na primjeru:




U prethodnom primjeru, najprije se putem getPreferences dohvada trenutna instanca dijeljenih postavke koja se odnosi na kontekst trenutne aktivnosti. MODE_PRIVATE odnosi se na (zadani) na?in kreiranja datoteke, pri ?emu je pristup istoj mogudi samo putem aplikacije koja je kreira.
U sljededoj liniji nad SharedPreferences objektom metodom edit dohvada se su?elje koje omoguduje modifikaciju sadržaja tog objekta, odnosno modifikaciju povezane XML datoteke.
Slijedi zapis parova klju?-vrijednost u obliku teksta, cijelog broja i logi?ke vrijednosti, a na kraju se metodom commit zapisuju promjene.
Navigiranjem do aplikacije CookBook i izlistavanjem sadržaja direktorija rezultat je sljededi:


No, nakon izvršavanja ranijeg kôda, pojaviti de se novi direktorij sa jednom datotekom i sadržajem prikazanom u sljededem primjeru:


Datoteka je nazvana prema asociranoj aktivnosti a sadržaj je zapisan u XML formatu.
 ZADATAK: Samostalno promotrite zapis i usporedite ga s Java kôdom.	


4.1.4 Korištenje parova klju?-vrijednost prema predifinranim pravilima
Korištenje parova klju?-vrijednost zadani je na?in zapisa podataka kod fragmenata sa preferencama mobilne aplikacije, PreferenceFragment. Za razliku od prethodnih dijeljenih preferenci, PreferenceFragment kreira XML datoteku sa zapisom preferenci korisnika na razini konteksta ?itave mobilne aplikacije.
Kako bi se definirale vrijednosti koje de fragment sa preferencama mobilne aplikacije zapisivati, potrebno je dodati novu XML datoteku. Pritiskom na /res direktorij u strukturi projekta, odabrati desnim klikom opciju „New“, „Android resource file“, nakon ?ega de se pojaviti dijalog prikazan na slici (Slika 56).

Slika 56. Dodavanje nove XML datoteke za prikaz postavki aplikacije
Prikazani dijalog potrebno je popuniti prema tablici (Tablica 12).
Tablica 12. Postavke za dodavanje XML datoteke za postavke mobilne aplikacije.

File nameapp_settings_fragmentResource typeXMLRoo elementPreferenceScreenSource setmainDirectory namexml

Nova datoteka prema zadanom nazivu kreira se u /res/xml direktoriju i potrebno je upisati sljededi sadržaj:




Kao što je vidljivo iz primjera, kreiran je pogled, odnosno ekran PreferenceScreen kojim de korisniku biti prikazane mogudnosti aplikacije, odnosno postavke može postaviti na željene vrijednosti. PreferenceCategory oznakom (engl. tag) odre?en je naziv kategorije. Iako je mogude imati više kategorija kako bi se korisnik lakše snalazio, u ovom primjeru definirana je samo jedna.
Svaki od elemenata ima tri klju?na svojstva, klju? (key), naslov (title) i opis (summary). Na raspolaganju su sljededi elementi:
* CheckBoxPreference – logi?ke vrijednosti, istina ili laž.
* EditTextPreference – tekstualne i broj?ane vrijednosti. Prilikom unosa otvara se dialog prema definiranom naslov (android:dialogTitle svojstvo).
* ListPreference – omoguduje korisniku odabir jednog elementa iz liste definirane dodatnom XML datotekom, unutar /res/values direktorija. Prilikom unosa otvara se dialog, kao i za prethodnu oznaku.
* MultiSelectListPreference – jednako kao i prethodna oznaka, samo što omoguduje odabir više vrijednosti.
* SwitchPreference – jednako kao i CheckBoxPreference no druga?ijeg grafi?kog prikaza.
Kako bi se dodao navedeni tip fragmenta, potrebno je u projektu kreirati novu klasu, primjerice naziva AppSettingsFragment i proširiti je klasom PreferenceFragment te ga asocirati sa XML datotekom koja sadrži definiciju postavki (addPreferenceFromResource), kao što je prikazano u sljededem kôdu:


Rezultat navedenog kôda prikazan je na slici Slika 57.


	

Slika 57. Fragment sa zadanim postavkama ?ije se vrijednosti zapisuju kao klju?-vrijednost parovi
Tako?er, nakon izvršavanja navedenog kôda, kreirati de se datoteka strukturiranog naziva prema sljededem pravilu korijenski.paket.nazivaplikacije_preferences.xml. To mogude provjeriti putem adb13 konzole, prikazanom u sljededem primjeru.



4.2 Zapis podataka u datoteke
Kod razvoja mobilnih aplikacija namijenjenih za Android zapis podataka u datoteke koristi se u slu?aju kada je potrebno zapisati vedu koli?inu podataka, primjerice slike, filmovi ili datoteke uredskih paketa (.docx, .xlsx, .odt, .pdf, itd.).
Svi Android ure?aji imaju mogudnost zapisa datoteka na unutarnju ili vanjsku memoriju. Kod vedine Android ure?aja u današnje vrijeme oba tipa memorije odnose se na unutarnju memoriju koja je sastavni dio ure?aja. No, prije nekoliko godina (a kod nekih ure?aja i danas) vanjska memorija bila je

13 ADB – Android debug bridge, program kojim se putem ra?unala spaja na android ure?aj, odnosno naredbeni redak operacijskog sustava [27].
85


prijenosni medij, poput micro SD kartica koja se po potrebi mogla izvaditi i mijenjati. Obje vrste memorije imaju specifi?ne karakteristike prikazane u tablici (Tablica 13).
Tablica 13. Usporedba unutarnje i vanjske memorije

Unutarnja memorijaVanjska memorijaUvijek dostupna i nije uklonjiva.Nije uvijek dostupna, mogu?e ju je fizi?ki (USB
ili micro SD kartica) ili softverski (unmount) ukloniti iz sustava.Datoteke su dostupne samo aplikaciji koja im je
vlasnik.Datoteke su dostupne svim aplikacijama.Deinstalacijom vezane aplikacije, uklanjaju se sve kreirane datoteke.Deinstalacijom vezane aplikacije, kreirane datoteke se uklanjaju samo ako je eksplicitno
nazna?eno.

Sukladno preporuci službene dokumentacije za razvoj Android mobilnih aplikacija, unutarnja memorija koristi se u slu?aju kada se želi osigurati da datotekama koje kreira aplikacija ne koristi nitko drugi osim nje. Vanjska memorija koristi se u slu?aju kada nema takvih potreba za upravljanje pristupom datotekama ili u slu?aju pohrane velikih datoteka. U na?elu, vanjska memorija je zna?ajno veda od unutarnje, a za njeno korištenje, mobilna aplikacija u AndroidManifest.xml datoteci mora od korisnika zatražiti posebne dozvole:



4.2.1 Primjer zapisivanja tekstualne datoteke na internu memoriju
Za zapis datoteka koristi se java.io biblioteka. Primjer koji slijedi prikazuje zapis datoteke naziva
„CookBookFile“ sadržaja „This is a CookBook file!“ [26].


Klasa FileOutputStream koristi se za kreiranje datoteke i zapisivanje sadržaja u istu. Njena metoda openFileOutput kreira otvara ili kreira datoteku prema zadanom nazivu i prema zadanim pravima, u ovom slu?aju MODE_PRIVATE što zna?i da de datoteci modi pristupati samo CookBook aplikacija.
Izvršavanjem navedenog kôda iz aplikacije adb konzolom mogude je izlistati sadržaj direktorija aplikacije CookBook:


Kreirao se novi direktorij naziva „files“ unutar kojeg je datoteka prema zadanom nazivu i sadržaju. Ako je nekome poznata to?na putanja do CookBookFile datoteke, a nije korišten MODE_PRIVATE u tom slu?aju pristup datoteci de biti mogud.
Važno je još ponoviti da de ovakav tip datoteke biti prisutan na Android ure?aju sve dok je aplikacija CookBook instalirana. No, mogude je napraviti i datoteke koje su privremene te koje korisnik može ukloniti. Privremene datoteke zapisuju se pomodu createTempFile metode iz klase File sukladno sljededem primjeru:




Izlistavanjem sadržaja direktorija CookBook mobilne aplikacije neposredno po izvo?enju prethodnog kôda može se uo?iti novi direktorij „cache“ koji sadrži privremenu datoteku prema danom imenu, no uz sufiks Unix vremenskog zapisa (engl. Unix timestamp):


Privremene datoteke mogude je obrisati putem postavki Android ure?aja, odnosno putem sustavskih postavki aplikacija, ozna?iti željenu aplikaciju što ?ime se otvara ekran prikazan na slici Slika 58 i kona?no pritiskom na tipku „Clear cache“.

Slika 58. Brisanje sadržaja direktorija s privremenim datotekama
4.2.2 ?itanje sadržaja datoteka
?itanje datoteke mogude je putem sljededeg kôda:




?itanje sadržaja datoteka vrši se pomodu klase InputStreamReader. Klasom InputStream otvara se datoteka, a zatim se ?ita redak po redak (while petlja u prethodnom primjeru). Sadržaj retka putem klase StringBuilder ?ita se u obliku teksta. Po završetku ?itanja ulazni tok podataka (instanca InputStream klase) obavezno se zatvara, a u navedenom primjeru se pro?itani sadržaj ispisuje u Logcat konzoli:



4.2.3 Primjer zapisivanja podataka na vanjsku memoriju
Kako je mogude da vanjska memorija nije uvijek dostupna za korištenje, prije korištenja iste valjda provjeriti njenu prisutnost, što je vidljivo u sljededem primjeru:


Ono što je specifi?no kod zapisa datoteke u internu memoriju, uz samu provjeru dostupnosti memorije, je i lokacija pohrane koja se dobiva iz pobrojenja Environment. Sve lokacije pobrojane u tablici ispod (Tablica 14) su javno dostupne za korištenje.



Tablica 14. Standardne lokacije za zapis datoteke na vanjskoj memoriji

DIRECTORY_ALARMSDirektorij za pohranu zvu?nih datoteka koje se koriste za melodije alarmnih poruka.DIRECTORY_DCIMDirektorij za pohranu slika i videa, primarno
dobivenih putem kamere Android ure?aja.DIRECTORY_DOCUMENTSDirektorij pohranu datoteka korisnika.DIRECTORY_DOWNLOADSDirektorij za pohranu svih datoteka preuzetih
putem mreže.DIRECTORY_MOVIESDirektorij za pohranu filmova.DIRECTORY_MUSICDirektorij za pohranu glazbe.DIRECTORY_NOTIFICATIONSDirektorij za pohranu zvu?nih datoteka koje se
koriste kod dojave notifikacija.DIRECTORY_PICTURESDirektorij za pohranu slika.DIRECTORY_PODCASTSDirektorij za pohranu zvu?nih datoteka vezanih
za „podcast“.DIRECTORY_RINGTONESDirektorij za pohranu zvu?nih datoteka koje se
odnose na melodije poziva.

Sve navedene lokacije su samo konvencija, no korisnik za zapis pojedinih sadržaja može odabrati i druge lokacije. Izvršavanjem kôda iz prethodnog primjera korištenjem adb konzole mogude je izlistati sadržaj vanjske memorije te navigirati do kreirane datoteke u Download direktoriju. Tako?er, iz popisa direktorija može se uo?iti struktura direktorija koja odgovara pobrojenju Environment prikazanom u tablici Tablica 14.


Isto tako, korištenjem mobilne aplikacije za pregled sadržaja datote?nog sustava Android ure?aja (File Manager) može je navigirati do kreirane datoteke, što je prikazano na slici (Slika 59).




Slika 59. Prikaz sadržaja direktorija Download na eksternoj memoriji putem File Manager-a
4.2.4 Brisanje datoteka
Vrlo jednostavnom metodom delete, nad instancom klase File brisanje datoteke vrši se sljededom linijom kôda:
file.delete();	

Navedena metoda ima logi?ki povratni tip, stoga je mogude provjeriti uspješnost brisanja.


4.3 Rad sa mobilnom bazom podataka
Android omoguduje rad sa nekoliko razli?itih vrsta baza podataka, primjerice BerkeleyDB, Couchbase Lite, LevelDB, UnQLite i mnoge druge. No, zadana baza podataka koja je sastavni dio Android operacijskog sustava je SQLite, pa baš upravo iz tog razloga de se u narednim primjerima koristiti navedena baza.
SQLite je transakcijska SQL baza podataka koja ne koristi server i nije ju potrebno dodatno konfigurirati, a zapisana je na datote?nom sustavu u obliku datoteke [29]. U ovom poglavlju bit de razmotrena dva na?ina korištenja SQLite baze podataka:
a) Nativni pristup, korištenjem dostupnih klasa i metoda iz Android operacijskog sustava, odnosno paketa android.database.sqlite.
b) Pristup putem biblioteke za objektno-relacijsko mapiranje (engl. ORM – object-relational
mapping).
No, prije daljnjeg rada sa bazama, promotrimo primjer aplikacije CookBook i potrebe za pohranom podataka.
4.3.1 Analiza potrebe zapisa podataka za CookBook mobilnu aplikaciju
Kako je prije re?eno, jedini zahtjev u mobilnoj aplikaciji CookBook je zapisivati podatke o receptima. Promotrimo što to zna?i za razvojne inženjere mobilne aplikacije tako da prepoznamo entitete. Entitet se u ovom kontekstu na objekte realnog svijeta koji su opisani specifi?nim skupom atributa i ?ine vlastitu odijeljenu cjelinu, a u bazi podataka predstavljaju jednu tablicu. U tom svjetlu, entitetne klase odnose su one klase koje programskim jezikom opisuju entitet, a namijenjene su radu sa objektima koji se ?itaju ili pohranjuju u relacijsku bazu podataka. Modeliranje baza podataka tema za ?itavi novi predmet, u ovom dijelu dajemo brzi pregled kroz najosnovnije elemente potrebne za izradu mobilne baze podataka.


Kako bismo odredili koje entitetne klase su potrebne za CookBook, promotrimo sljededi recept:


Svakako, uo?ljivo je da je prvi entitet sam recept (Recipe). Recept ?ine naziv, opis pripreme te niz sastojaka. Kako relacijske baze podataka dolaze iz relacijske teorije u matematici, prilikom dizajna relacijskog modela potrebno se držati odre?enih pravila i notacija. Dakle, prvi korak je napraviti shemu relacije, koja se sastoji od imena relacije i popisa imena atributa. Trenutno to je:
Recipe (id_recipe, name, description, ingredient).	


Primarni atribut, odnosno klju? je onaj koji jednozna?no definira odre?eni entitet, odnosno redak u tablici. Isto tako, prethodnu relacijsku shemu, može se prikazati pomodu relacijskog ERA modela koji prikazuje entitete, atribute i njihove veze, što je vidljivo na slici (Slika 60).

Slika 60. ERA model sa samo jednim entitetom, Recipe
No trenutno, promotrimo li ERA model, može se uo?iti da ukoliko imamo 2 recepta koja oboje primjerice trebaju brašno, svaki puta de ponovno trebati unositi brašno. Sli?no tome, teško de se raditi filtriranje podataka, primjerice ako želimo sve recepte koji kao sastojak imaju piletinu. Dakle, pojavljuju se problem u navedenom modelu, što svoj korijen ima u višestrukom ponavljanu podataka, odnosno redundanciji, koja je samo jedan od problema koji se mogu pojaviti. Mogudi su i problemi s performansama baze podataka te integritetom podataka koji stvaraju anomalije kod kreiranja novih zapisa, brisanja ili njihovog ažuriranja.
Kako bi se navedeni problemi riješili, pristupa se postupku normalizacije baze podataka kojom tablice smještano u neku od normalnih formi. Postoji sedam normalnih formi i sve svoj korijen imaju u matemati?koj logici stoga je normalizacija formalno definiran proces. Za prakti?ne svrhe, naj?ešde su dovoljne prve tri normalne forme. Za one koji žele znati svih sedam normalnih forma te vezanih pravila, upudujemo na literaturu vezanu uz teoriju baza podataka; [30] [31]. Jedno od pravila normalizacije jest da svi atributi u tablici moraju biti atomarni, odnosno ne rastavljivi. Takav primjer je atribut sastojak (engl. ingredient), odnosno jedan recept može imati puno sastojaka. Svaki sastojak ima ime i mjernu jedinicu, stoga bi relacijska shema sada bila:



Isto tako, jedan sastojak može svakako biti na više recepata, pa je stoga brojnost veze izme?u tablice Recipe i Ingredient više naprama više, odnosno M:N. To predstavlja problem jer više ne možemo jednozna?no identificirati koji sastojak pripada kojem receptu i obratno.
Taj problem rješava se uvo?enjem tablice slabih entiteta, odnosno tredom tablicom prema kojoj obje navedene tablice imaju vezu više, dok ona prema obje tablice ima vezu jedan. Isto tako, ona ima složeni klju? sastavljen od primarnih klju?eva tablica u odnosu M:N. Prikaz rješenja dan je slikom (Slika 61).

Slika 61. Uvo?enje tablice slabih entiteta
U ovom slu?aju, ako je potrebno dohvatiti sve sastojke nekog recepta, potrebno je tablicu RecipeItem filtrirati prema stranom klju?u id_recipe. Sli?no tome, želimo li dohvatiti sve recepte koji sadrže odre?eni sastojak, potrebno je napraviti filtriranje po klju?u id_ingredient. Kako tablica RecipeItem veže sastojak i recept, kao tredi atribut dodana je i koli?ina koja se odnosi na koli?inu s kojom neki sastojak ulazi u recept.
Nadalje, sli?an problem kao i ranije postoji u tablici Ingredient, a odnosi se na mjernu jedinicu (engl. unit). Kako bi moglo dodi do ponavljanja podataka koja je nepoželjna, atribut jedinice potrebno je staviti u novu tablicu.

Slika 62. Normalizirana baza podataka
Slika 62 prikazuje kona?an ERA model za CookBook mobilnu aplikaciju. Atribut mjerne jedinice postao je tablica, a uz to tablici je dodan primarni klju? i novi atribut opisa.
U svrhu pojednostavljenja primjera CookBook, za implementaciju demo koristiti ERA model prikazan na slici Slika 61.


4.3.2 Nativni pristup
Za demonstraciju nativnog pristupa korištenju baze podataka kod Androida [32], u postojedem projektu CookBook mobilne aplikacije, kreirati novi paket naziva dbnative, koji de sadržavati sve potrebne klase za kreiranje baze podataka i rad sa tablicama.
Temeljna klasa za rad sa bazom podataka je SqliteOpenHelper ?ijim naslje?ivanjem je potrebno implementirati dvije temeljne metode, onCreate i onUpgrade. Kako i ime sugerira, na doga?aj kreiranja baze (dakle baza podataka još ne postoji), unutar metode onCreate implementira se programski kôd i vezane SQL naredbe putem kojih se generira baza podataka. Kod doga?aja dogradnje (onUpgrade) baze vršimo korekciju (ako želimo mijenjati relacije), što se signalizira prema broju verzije trenutne baze podataka, koja je obavezan parametar kod metoda za pristup bazi podataka.
Prva kasa koju je time potrebno dodati u paket dbnative je DbHelper, a ona naslje?uje temeljnu klasu za pristup bazi podataka, što je pokazano u sljededem primjeru:


Nakon toga je potrebno kreirati entitetnu klasu koja de odgovarati tablici iz baze podataka. Za to je potrebno napraviti novi paket, nazvati ga entities a unutar istog kreirati prvu entitetnu klasu, Recipe:


Uz tu klasu, potrebna je i klasa pomodu koje de se pristupati bazi podataka, a prikazana je na sljededem primjeru:



// naziv datoteke baze podataka i trenutna verzija
public static final String DATABASE_NAME = "database.db"; public static final int DATABASE_VERSION = 1;
private DbHelper sqLiteHelper;
private SQLiteDatabase sqLiteDatabase;

private Context context;

public DataAdapter(Context context) { this.context = context;
}
// otvaranje veze prema bazi podataka za ?itanje
public SQLiteDatabase openToRead() throws android.database.SQLException { sqLiteHelper = new DbHelper(context, DATABASE_NAME, null,
DATABASE_VERSION);
sqLiteDatabase = sqLiteHelper.getReadableDatabase(); return sqLiteDatabase;
}
// otvaranje veze prema bazi podataka za pisanje
public SQLiteDatabase openToWrite() throws android.database.SQLException { sqLiteHelper = new DbHelper(context, DATABASE_NAME, null,
DATABASE_VERSION);
sqLiteDatabase = sqLiteHelper.getWritableDatabase(); return sqLiteDatabase;
}
// zatvaranje veze prema bazi podataka
public void close() { sqLiteDatabase.close(); sqLiteHelper.close();
}

}



Može se uo?iti da navedena klasa implementira metode za ?itanje i pisanje u bazu podataka, a isto tako pohranjuje naziv datoteke baze podataka te njenu trenutnu verziju.
Zbog preglednijeg na?ina rada, svakom entitetu pridružiti de se odgovarajuda adapterska klasa koja de naslijediti DataAdapter klasu te je koristiti za pristup bazi na jedinstven na?in. Time se verzija i opdi podaci o bazi podataka biti na jednom mjestu.
Za tablicu Recipe, ta klasa de se stoga zvati RecipeAdapter, bit de smještena u paketu
dbnative, a naslje?uje ranije kreiranu klasu DataAdapter:



U navedenom kôdu nedostaje implementacija metode za unos novog recepta i pregled svih, odnosno dohvadanje liste svih trenutno unesenih recepata u mobilnoj bazi podataka. Kao što je vidljivo, tablica ima svoje ime, koje treba odgovarati imenu u bazi podataka, te oznaku primarnog klju?a.
Podaci namijenjeni za zapis u bazi podataka pohranjuju se pomodu klase ContentValues, pa de stoga metoda insertRecipe biti:


Iz priloženog kôda uo?ljivo je da objekt klase ContentValues koriti zapise u obliku klju?-vrijednost koje potom zapisuje u odgovarajudu tablicu u bazi podataka. Iz super klase DataAdapter koristi se metoda koja otvara vezu prema bazi podataka namijenjenu za pisanje.
Kako bi se ?itali podaci, potrebno je koristiti Cursor klasu koja nakon postavljenog SQL upita sadrži rezultate, kao što to prikazuje sljededi primjer:


Iz primjera je vidljivo kako nakon postavljanja upita nad tablicom pomodu metode query, rezultat se pohranjuje u instancu klase Cursor. Nadalje, prolaskom kroz sve elemente tog objekta, ?itaju se vrijednosti iz baze podataka prema nazivu atributa. U ovom slu?aju, rezultat je lista recepata.
Sljededi primjer pokazuje na koji na?in se koriste kreirane klase za nativni rad sa bazom podataka. Nakon kreiranja instance klase RecipeAdapter, korištenjem njene metode insertRecipe, kreiraju se recepti (odnosno instance klase Recipe). Po završetku korištenja baze podataka, potrebno je zatvoriti vezu.
Tako?er, primjer pokazuje ispis trenutnog sadržaja tablice Recipe u konzolnoj liniji, pozivanjem metode getAllRecipes. Izvo?enje navedenog kôda najbolje je isprobati unutar glavne aktivnosti.




Izvršavanjem prethodnog primjera, u konzolnom retku Android Studia (Logcat) nadi de se ispis svih recepata:


Isto tako, korištenjem adb konzole na Android ure?aju, navigacijom do database direktorija, može se vidjeti i kreirana baza podataka: database.db i database.db-journal. database.db je SQLite datoteka, odnosno sama baza podataka, dok je database.db-journal datoteka je privremena pomodna datoteka koja se koristi kod transakcija SQLite baze podataka.


Osim toga, adb konzola omoguduje direktno spajanje na bazu podataka i korištenje SQL upita, naredbom sqlite3 naziv-baze, odnosno u ovom slu?aju sqlite3 database.db:


Primjer prikazuje spajanje na bazu podataka, izlistavanje svih trenutno dostupnih tablica naredbom
.tables (Recipe i android_metadata, koja sadrži opde podatke o bazi, primjerice korišteni

98


jezik). Po spajanju na bazu, mogude je izvršavati i SQL upite što je prikazano upitom SELECT, a izlazak iz aplikacije sqlite3 vrši se naredbom .quit. Svaki upit nad bazom podataka mora završavati sa znakom to?ka-zarez ;.
Time je prikazan proces rada s bazom podataka korištenjem osnovnog (nativnog) pristupa. Navedeni odlomci ne prikazuju ovaj pristup u cijelosti jer nisu kreirane metode za nadogradnju strukture podataka ili ažuriranje podataka niti je implementiran rad sa svim tablicama. Analizom ovakvoga pristupa u radu s bazom podataka možemo uo?iti da zahtjeva pisanje mnogo programskog kôda te da posljedi?no troši i dosta vremena razvojnog tima.

Za pregledniju arhitekturu mobilne aplikacije, smanjenja potrebnog kôda za rad s bazom podataka i njeno u?inkovitije korištenje obi?no se koriste sustavi za objektno-relacijsko mapiranje, ORM. Android ima više razli?itih biblioteka trede strane za ORM, primjerice Sugar ORM, Sprinkles, DB Flow, Active Android, itd. U sljededem poglavlju, prikazuje se Active Android kroz implementaciju istog primjera. Active Android, odabran je jer je prili?no rasprostranjen i jedan od najranijih Android ORM sustava, no svaki od prethodno nabrojanih ima svojih kvaliteta i valja ih razmotriti prilikom odluke o korištenju ORM-a.
4.3.3 ORM – Active Android
Objektno-relacijski maper je sustav koji omoguduje rad s bazom podataka korištenjem objektno- orijentirane paradigme, pri ?emu se odvaja model klasa od sustava za upravljanje bazom podataka. U na?elu, ORM je skup biblioteka koje omataju bazu podataka skupom klasa za jednostavniju primjenu i automatizaciju standardnih operacija (SQL upita) poput kreiranja baze podataka, ?itanja, zapisivanja, pretraživanja i dr.
U prethodnom, nativnom pristupu, kreiranje baze podataka, tablica i postavljanje upita nad istima zahtijevalo je za svaku tablicu posebnu adaptersku klasu koja sadrži sve SQL upite potrebne za rad. Takvim pristupom, programski kôd je zavisan od baze podataka, jer iako je pristup i sam SQL standardiziran, uvijek postoje sitne razlike koje de izazvati pogreške u izvo?enju, ukoliko se mijenja sam sustav za upravljanje bazom podataka. Kod ORM-a, njegova implementacija ?esto sadrži mogudnost odabira više sustava za upravljanje bazom podataka, pa time on predstavlja most izme?u programskog jezika, odnosno objekata iz kôda prema entitetima u bazi podataka. Primjenom ORM-a, zamjena baze podataka zna?ila bi minimalne promjene u programskom kôdu (barem u teoriji, iako nije uvijek slu?aj, a u softverskoj zajednici postoje brojne diskusije na navedenu temu). Slika 63 prikazuje kako ORM mapira tablice iz baze podataka u klase programskog kôda, i obratno.



Slika 63. Mapiranje klasa iz memorije u tablice u bazi podataka
ORM omoguduje dva osnovna pristupa razvoju podatkovnog sloja mobilne aplikacije:
a) Prvo kôd – temeljem kreiranih entitetnih klasa u programskom kôdu, ORM generira bazu podataka. ORM sam brine o tipovima podataka i odnosima izme?u tablica, pa ?ak veze više naprama više iz programskog kôda (gdje je to dozvoljeno), automatski rješava uvo?enjem tablice slabih entiteta. No, trenutna implementacija Active Androida tu funkcionalnost još ne omogu?uje, pa prema slici Slika 63, model klasa odgovara modelu podataka.
b) Prvo baza podataka – ORM se povezuje na postoje?u bazu podataka te generira klase kojima se pristupa do pojedinih tablica. Active Android u trenutnoj implementaciji nema ovu mogu?nost, no mnogi drugi ORM-ovi za druge web ili stolne aplikacije imaju.
4.3.4 Kreiranje baze podataka putem Active Android biblioteke
Za korištenje Active Android biblioteke u build.gradle (Project: Memento) treba dodati referencu na Maven repozitorij, na kojem se biblioteka nalazi:


Nakon se u build.gradle (Module:app) dodaje referenca na samu Active Android biblioteku:


I kona?no, u AndroidManifest.xml dodaju se meta podaci o bazi podataka, odnosno ime i verzija. Kako je ranije ved spomenuto, prilikom bilo kakve promjene nad strukturom baze podataka, verziju je potrebno ru?no uvedati za jedan, kako bi se pokrenula onUpdate metoda. Neposredno nakon oznake koja se odnosi na glavu aktivnost, no prije završetka oznake aplikacije dodati:

100




Baza podataka je spremna za korištenje, što kod Active Androida zna?i da je potrebno kreirati entitetne klase koje de naslijediti Model klasu iz Active Androida, a anotacijama14 @Table i @Column nazna?iti u klasi što je tablica, atribut.
Za entitetne klase, kreirati novi paket, nazvati ga entities, a unutar navedenog treba kreirati tri klase; Recipe, Ingredient i RecipeItem. Klasa Recipe je:


Recipe naslje?uje klasu Model ?ime dobiva karakteristike entiteta, odnosno naslje?uje metode poput save i delete. Anotacijom Table dodanom neposredno prije definicije klase Recipe, daje se uputa Active Androidu da de klasa Recipe biti objektna reprezentacija tablice recipe u bazi podataka. Sli?no tome, anotacijama @Column definiraju se atributi entiteta.
Ono što nedostaje su metode koje bi omogudile dohvadanje svih zapisa iz baze podataka ili odre?enog zapisa prema identifikatoru, što se može napraviti dodavanjem stati?kih metoda:



Kao što je vidljivo, ne koristi se SQL ved se koriste metode iz ORM-a, ?ime je kôd neovisan o sustavu za upravljanje bazom podataka.


Logika izrade klase Ingredient je identi?na:


14 Anotacije su meta-instrukcije koje se dodaju u Java kodu kako bi se pojedinim klasama, metodama ili atributima dodale (anotirale) dodatne karakteristike. Programski gledano, anotacija je programsko su?elje.




Za razliku od entitetnih klasa Recipe i Ingredient, klasa RecipeItem kao atribute koristi baš te složene klase. Kako se radi sa ORM-om, atributi koji se odnose na druge entitetne klase se koriste baš kao i bilo koji drugi atributi, a Active Android de se pobrinuti da se strani klju?evi dobro zapisuju.



Sljededi primjer, kojeg je najbolje izvršiti u glavnoj aktivnosti, inicijalizira Active Android (ActiveAndroid.initialize() treba izvršiti samo jednom). Nakon toga u bazu podataka dodaje se pet sastojaka i dva recepta. Važno je uo?iti da za to SQL uopde nije korišten, a metoda


save koja je naslije?ena iz klase Model Active Androida sadrži kôd za spremanje koji je automatski generiran.


Tako?er, kod dodavanja sastojaka receptu, može se uo?iti kako se ovdje radi sa objektima. Dakle, RecipeItem u konstruktoru kao parametar prima objekt recepta i objekt sastojka koji se receptu pridružuje u odre?enoj koli?ini.
Izvršavanjem navedenog kôda, pomodu adb konzole može se navigirati do novokreirane baze podataka, te postavljanjem upita vidjeti unesene podatke. Pretraživanjem se može vidjeti recept i njegovi sastojci ili obratno, sastojci koji se nalaze na pojedinom receptu.


Sljededim kôdom, koji se može napisati odmah nakon kôda kojim se podaci unose u bazu podataka, ispisuje se sadržaj tablice RecipeItem, tako da se for petljom prolazi kroz sve recepte. Ista petlja ima ugnijež?enu petlju koja zatim za dohvadeni recept, dohvada sastojke iz tablice RecipeItem:


U Logcat konzoli, me?u mnoštvom zapisa pronadi de se i ispis:



Isto kao i ranije kod nativnog pristupa bazi podataka, korištenjem adb-a mogu se provjeriti upisani podaci, kao što je prikazano u sljededem primjeru:



Sqlite3 programom spajamo se na datote?nu bazu podataka cookbook.db koja se kreira uz ved postojedu database.db korištenu kod primjera prethodnog poglavlja. Prema broj?anim komentarima (crveno), slijedi objašnjene za svaku izvršenu naredbu (pojedini upiti su ponovljeni, no sa druga?ijim parametrima kako bi demonstrirao SQL i usporedili rezultati):
1.) Naredba baze podataka za ispis svih tablica.
2.) SQL upit kojim se ispisuje ?itav sadržaj tablice Ingredient. Kao što se vidi, svi sastojci upisani putem Java kôda su sadržani u tablici, bez da je ru?nog pisanja SQL-a.
3.) SQL upit kojim se iz tablice koja sadrži sastojke pojedinih recepata ispisuju svi recepti koji koriste sastojak sa identifikatorom 4, odnosno ispis svih recepata i sastojaka koji koriste kvasac.
4.) SQL upit kojim se ispisuje ?itav sadržaj tablice RecipeItem.
5.) SQL upit za ispis svih recepata i sastojaka koji koriste brašno (sli?no kao 3).
6.) SQL upit koji ispisuje recept sa identifikatorom 1 (bez sastojaka).
7.) SQL upit kojim se ispisuju svi recepti i sastojci koji koriste vodu.
8.) SQL upit koji ispisuje recept sa identifikatorom 2 (bez sastojaka).
9.) Naredba baze podataka za izlaz iz adb programa.


Demonstracijom Active Androida trebalo bi uo?iti razlike sa nativnim pristupom. Active Android pruža odre?enu fleksibilnosti i jednostavnost kod promjena u bazi podataka, a isto tako zna?ajno olakšava rad sa podacima. Iako Active Android nije ORM u punom smislu, do odre?ene mjere uklanja potrebu za primjenom SQL-a i smanjuje broj potrebnih izmjena u kôdu, u slu?aju promjene strukture baze podataka.


4.4 Rad s web servisima
Web servis je naziv za standardiziranu uslugu razmjene podataka izme?u klijenta i poslužitelja na webu. Kako se za prijenos podataka koristi HTTP, podaci koji se razmjenjuju izme?u klijenta i poslužitelja formatirani su u jednom od dva proširiva tekstualna oblika, XML i JSON.
XML (engl. extensible markup language) je format za razmjenu podataka koji je napravljen sa svrhom da bude jednostavan, proširiv, samo-opisujudi i ?itljiv ?ovjeku i stroju [33]. XML pripada SGML skupini jezika koji je definiran standardom ISO 8879. Primjer sli?nog, no strože definiranog jezika iz iste skupine je HTML, danas najrasprostranjeniji jezik za prikaz web stranica. Internet preglednici automatski prevode taj jezik u sadržaj razumljiv ?ovjeku, primjer poziva web servisa koji odgovara sa HTML-om je prikazan na slici (Slika 64 (a)). XML je vrlo sli?an HTML-u, no slabije definiran, odnosno temeljni elementi XML-a, oznake i atributi, nisu definirani standardom, ved posebnom XSD (engl. XML schema definition) datotekom, pisanom u standardiziranom XML formatu. Primjer strukture podataka formatirane u XML obliku prikazuje Slika 64 (b).
JSON (engl. JavaScript Object Notation) kao i XML je format za razmjenu podataka koji je napravljen s idejom da bude jednostavan za ?itanje ljudima i ra?unalima, a temelji se na programskom jeziku JavaScript [34]. Ideja vodilja kôd kreiranja JSON-a bila je smanjenje paketa u kojima se podaci šalju kako bi se ubrzao prijenos podataka. Tako?er, format u kojem su podaci zapisani dozvoljava direktno vezanje na objekte u programskom kôdu. JSON se temelji na parovima klju?-vrijednost, a primjer odgovora web servisa prikazan je na slici (Slika 64 (c)).


(a)(b)(c)Slika 64. Primjeri odgovora web servisa u razli?itim formatima (a) HTML, (b) XML, (c) JSON

a) I dok oba formata imaju svojih prednosti i nedostataka, danas se oba prili?no intenzivno koriste kod web servisa, koji vrlo ?esto imaju mogudnost prezentacije podataka u oba formata. Na taj na?in, sam klijent odabire format koji mu najviše odgovara. Iako ih postoje više, danas su najpopularnija dva pristupa konzumiranja web servisa, SOAP i REST. ).
4.4.1 SOAP
SOAP (engl. simple object access protocol) je protokol koji služi za razmjenu podataka izme?u web servisa, a koristi standardizirane poruke definirane XML-om [35]. Iako kao protokol implementacije naj?ešde koristi HTTP, SOAP je po definiciji neovisan o protokolima niže razine. Na taj na?in, SOAP nije ovisan o operacijskom sustavu, programskim jezicima i tehnologijama. Temeljni element SOAP-a je poruka koja se sastoji od tri osnovna dijela prikazana na slici (Slika 65).

Slika 65. Struktura SOAP proruke


a) SOAP omotnica – je obavezni dio SOAP poruke koja definira njen po?etak i kraj, te identificira poruku.
b) SOAP zaglavlje – je opcionalni dio SOAP poruke koji se koristi za definiranje opcionalnih atributa kod obrade poruke.
c) SOAP tijelo - je obavezni dio SOAP poruke koji sadrži korisni sadržaj, odnosno sam podatak koji klijent i server razmjenjuju.
Uz navedeno, najvažnije karakteristike SOAP-a su:
b) Sigurnost- uz sam SSL protokol (engl. secure socked layer), SOAP omoguduje uvo?enje dodatnih elemenata zaštite (npr. WS-Security) ?ime postiže veda sigurnost i zbog ?ega je ?esto korišten u transakcijama izme?u velikih poduzeda.
c) Atomarne transakcije – što zna?i da SOAP garantira sigurnu ispostavu poruke i ACID transakcije: A – atomarnost poruke (dostavlja sve podatke ili ništa), C – konzistenciju stanja servisa, I – izolacijsko svojstvo koje osigurava konzistenciju paralelne obrade i D – izdržljivost koje garantira postojanost obavljenih transakcija (bez obzira na vanjske elemente).
4.4.2 REST
Za razliku od SOAP-a, REST (engl. representational state transfer) nije protokol ved arhitekturalni stil web servisa koji se temelji na HTTP protokolu vo?en principima skalabilnosti, jednostavnosti, u?inkovitosti, prenosivosti i pouzdanosti [36]. Nakon konzumacije REST servisa, on ne zadržava


stanje, što zna?i da poslužuje podatke klijentu, a potom komunikacija prestaje. Daljnju interakciju inicira klijent kroz univerzalne identifikatore resursa (engl. URI), putem jedne od pet dostupnih HTTP metoda: POST (kreiranje sadržaja), GET (?itanje sadržaja), PUT (modifikacija sadržaja15), PATCH (ažuriranje i modifikacija sadržaja), DELETE (brisanje sadržaja). Web servisi koji su gra?eni REST na?elom, ?esto imaju mogudnost prezentacije sadržaja u bilo kojem formatu (naj?ešde JSON i XML).
Kako REST koristi HTTP kao protokol prijenosa sadržaja, vrlo je jednostavan te ga je mogude konzumirati putem Internet preglednika, a razvoj klijenata i dokumentacije je zna?ajnije jednostavnije. ?este odgovore koje traže klijenti mogude je ?uvati u privremenoj memoriji što zna?ajnije ubrzava rad i skalabilnost.

Kod razvoja Android mobilnih aplikacija, u ovom priru?niku demonstrirati demo korištenje REST servisa, iz razloga što mobilne aplikacije gotovo u potpunosti koriste REST pristup. Tek kod nekih specifi?nih slu?ajeva koristi se SOAP.


4.4.3 Korištenje REST servisa kod Androida
Sli?no kao i kod razvoja mobilnih baza podataka, kod Androida postoje dva razvojna pristupa konzumiranja web servisa. Nativni, podržan samo bibliotekama dostupnima u Androidu, te automatiziran korištenjem bibliotekama trede strane.
Kod nativnog pristupa, potrebni su sljededi elementi [27]:
a) Android servis ili dretva (nit) koji se koristi za slanje i primanje HTTP zahtjeva, tako da ne blokira aplikaciju za vrijeme slanja ili ?ekanja odgovora. Android ne dozvoljava izvo?enje dugotrajnih operacija na glavnoj dretvi, npr. onPostExecute (izvršavanje HTTP POST metode).
b) Klase i metode za slanje i primanje HTTP zahtjeva.
c) Klase i metode za obradu primljenog sadržaja.
Slika 66 prikazuje pojednostavljeni prikaz doga?aja kod primjene osnovnog (nativnog) pristupa web servisima. Desni dio slike prikazuje slu?aj u kojemu se koristi Android pozadinski servis, koji komunicira sa web servisom putem HTTP-a. Može se uo?iti da nakon što stigne odgovor, Android servis aplikacije šalje Broadcast poruku na razini Android operacijskog sustava [27]. Ta poruka sadrži posebni identifikator koji definira tip usluge koji se traži. U ovom slu?aju, ista Android aplikacija koja kreira putem servisa takvu poruku, jedina sadrži Reciever kojim se jedina i javlja na tu poruku. Nadalje, tu de poruku koristiti i dodatnim klasama obraditi njen sadržaj i dobiti odgovor iz od servisa.
Lijeva polovica slike prikazuje istu interakciju, no ovaj puta bez pozadinskog servisa nego sa dretvom. Naime, po kreiranju dretve koja de komunicirati sa web servisom, potrebno je kreirati i slušatelja (engl. listener) doga?aja dolaska podataka. Kada podaci stignu, taj de se doga?aj aktivirati i obraditi poruku. Ovom implementacijom izbjegnuto je korištenje Android OS-a u interakciji s web servisom.




Slika 66. Nativni pristup web servisima (lijevi dio putem dretve, desni dio putem klase Service)
Zbog zavisnosti o servisu, formatu poruke, složenom kôdu i potrebom za poznavanjem detalja HTTP protokola, u ovom priru?niku nedemo prikazivati detalje nativne implementacije korištenja web servisa. Umjesto toga, koristiti demo biblioteke trede strane koje de zna?ajno olakšati primjenu web servisa, i to potrebu za servisom i dretvom, potrebu za obradama doga?aja HTTP protokola i poslužitelja te manualnu obradu dolazne poruke. Biblioteke koje de se koristiti su Retrofit, za rad sa servisima i GSON za obradu dolazne poruke.


4.4.4 Retrofit i GSON
Retrofit je biblioteka trede strane koja kod rada s web servisima omoguduje da se prema metodama web servisa ponašamo kao i bilo kojim drugim Java metodama, kroz implementaciju su?elja koje definiraju rute (putanje) do metoda web servisa [37]. U kombinaciji sa GSON bibliotekom koja JSON objekte serijalizira u Java objekte i obratno, Retrofit zna?ajno smanjuje koli?inu kôda potrebnog za rad sa web servisima, a isto tako samu organizaciju kôda ?ini preglednijom [38].
Slika 67 prikazuje kako metoda Call iz Retrofita poziva web servis temeljem definirane (ranije spomenute) rute. Po dobivanju odgovora, koristi GSON biblioteku koja mehanizmom anotiranja serijalizira JSON objekte u Java objekte temeljem klasa definiranih u projektu. Dakle, odgovori web servisa, trebaju biti opisani Java klasama koje sadrže samo atribute i konstruktor analogan atributima JSON odgovora od web servisa. Takve klase još se nazivaju POJO klase (engl. plain old java object).

Slika 67. Shema primjene kombinacije biblioteka Retrofit i GSON za konzumiranje web servisa


U narednom primjenu, napraviti demo poziv web servisa za dohvadanje vremenske prognoze s otvorenog web servisa OpenWeatherMap.org. Servis prema danim podacima (ime mjesta, šifra mjesta, geografska visina i širina) dohvada prognozu vremena.


Kao prvi korak prema dohvadanju tih podataka, u Android projekt je potrebno dodati reference na Retrofit i GSON biblioteke u build.gradle (Module: app):







Uz navedene biblioteke, uklju?ena je i okhttp biblioteka, putem koje Retrofit više nede biti ovisan o lokalnom HTTP servisu Android operacijskog sustava, ved de koristiti implementaciju trede strane.
Nakon toga, potrebno je analizirati odgovor web servisa, kako bi se mogle napraviti POJO klase. Puni opis aplikacijskih programskih su?elja za korištenje OpenWeatherMap web servisa dostupan je na stranici http://openweathermap.org/api, no za sad promotrimo sam poziv web servisa:
http://api.openweathermap.org/data/2.5/weather?q=Varazdin&appid=SIFRA&units
=metric
Navedeni poziv sastoji se od elemenata prikazanih u tablici (Tablica 15). Uo?ite da je prvi argument metoda ozna?en sa ?, a svaki argument nakon toga je dodan sa znakom & u obliku parova klju?- vrijednost.
Tablica 15. Elementi URI-a za poziv web servisa

httpProtokol za transport podatakaapi.openweathermap.orgKorijenska adresa do servisa (URL)dataPutanja do web aplikacije koja implementira web servis2.5Verzija web aplikacijeweatherNaziv usluge (metode koja se koristi)Argumenti:qUpit lokacije za koju se dohvada prognoza vremenaappidIdentifikator naše aplikacije (potrebno se registrirati za
besplatno korištenje web servisa)unitsJedinice, imperijalne ili metri?ki sustav.

Odgovor web servisa za zadani upit u JSON formatu je:





Za osnovno razumijevanje JSONa potrebno je znati:



Imajudi to na umu, iz navedenog primjera odgovora web servisa, može se uo?iti da se radi o jednom objektu sa 12 korijenskih atributa, redom: coord, weather, base, main, visibility, wind, clouds, dt, sys, id, name i cod. Nadalje, atribut coord kao vrijednost ima novi objekt koji ima dva svojstva, lat i lon. Objekt weather kao vrijednost ima polje sa samo jednim objektom, koji ima ?etiri svojstva id, main, description i icon. main kao vrijednost ima vrijednost sa pet atributa, wind sa dva itd.
Kako bi GSON mogao serijalizirati primljeni objekt u objekt Java klase, potrebno je napraviti istu klasnu strukturu, pri ?emu klasa odgovora ima svih ranije dvanaest navedenih svojstava, svojstvo coord kao atribut sadrži novi objekt, weather polje objekata itd. U kona?nici, bilo bi potrebno sedam klasa: Forecast (sam odgovor sa 12 atributa), Coord, Weather, Main, Wind, Clouds i Sys16. No, ukoliko nas ne zanima ?itav odgovor, mogude je napraviti klase samo za atribute koji su nam od interesa. U ovom slu?aju, nas zanimaju samo konkretni atributi vezani uz prognozu, odnosno atributi sadržani u svojstvu odgovora main. Stoga, bit de potrebne dvije POJO klase kojima demo dodijeliti prefiks Ws (webservice), WsForecast i WsMain. Te dvije klase moraju sadržavati sva svojstva, jednaka kao i njihovi ekvivalenti iz JSON odgovora.


16 Kako su to vrlo ?esto samo trivijalne POJO klase, neki alati omoguduju njihovo generiranje uz predo?enje JSON odgovora.


U projektu, treba kreirati paket i nazvati ga webservice, a unutar njega još jedan paket wsentities, te kreirati klase WsForecast i WsMain, zajedno sa mutatorskim klasama prema JSON odgovoru17.


WsMain (nakon napisanih atributa, koristiti pre?ac za generiranje mutatorskih metoda „Getters and Setters“):







17 Konvencija nad konfiguracijom (engl. Convention over configuration), što zna?i da GSON prema konvenciji traži samo atribute koji postoje, dok druge zanemaruje.
112


WsForecast kod svojstva main kao tip podataka ima definirani objekt klase WsMain, što de GSON povezati sa odgovarajudim JSON objektom odgovora:







Sljededi korak, u paketu webservice treba definirati programsko su?elje koje de sadržavati rute (putanje) do metoda web servisa zajedno sa njihovim parametrima. Trenutno, koristiti demo samo jednu metodu i to za dohvat ranije prikazanog JSON-a. Programsko su?elje nazvati WsCaller:



U navedenom primjeru se vidi da de se u Java kôdu unutar Android aplikacije metoda za poziv web servisa zvati getForecast, a ista sadrži tri anotirana parametra. Anotacije parametara govore za koje argumente web servisa prikazanih u tablici (Tablica 15) de se parametri Java programskog su?elja vezati. Isto tako, ?itava metoda anotirana je putanjom do glavne metode web servisa, zajedno sa definicijom HTTP metode koja de se koristiti kod slanja zahtjeva, u ovom slu?aju to je GET. Metoda getForecast vrada Call objekt sa listom WsForecast objekata.


Preostala implementacija zahtjeva novu klasu ?iji de se objekti koristiti za asinkroni, ne blokirajudi poziv web servisa. Novu klasu nazvati WeatherWebService i smjestiti je unutar paketa webservice. Klasa de imati sljededi sadržaj:




Metoda getWeather treba implementirati sam poziv web servisa i slušatelj doga?aja (engl. listener) koji de se aktivirati kada stigne odgovor i napraviti serijalizaciju odgovora u lokalne POJO klase.


Sadržaj metode getWeather:





Kao što je vidljivo u komentarima navedenog primjera, najprije se instancira objekt odgovora weatherForecast lista, nakon ?ega slijedi kreiranje Retrofit objekta kojemu se kao parametar proslje?uje korijenski URL web servisa te GSON objekt za kasniju serijalizaciju JSON-a. Potom, Retrofit generira implementaciju metoda programskog su?elja WsCaller prema instrukcijama zapisanim u anotacijama. Na kraju, kreira se call objekt nad kojim se metodom enqueue asinkrono poziva web servis. Primjenom anonimne metode definira se pozivna metoda (engl. callback, metoda koja se poziva iniciranjem nekog doga?aja). U našem slu?aju to je dolazak odgovora od web servisa, što za posljedicu može imati dva ishoda, uspjeh (metoda onResponse) ili pogrešku (onFailure). Tako?er, metoda onResponse, provjerava da li je HTTP rezultirao uspjehom ili neuspjehom. Ako su podaci uspješno stigli, u objekt odgovora weatherForecast dodaje se tijelo dohvadene HTTP poruke koja sadrži JSON. Kona?no, nakon svega mogude je ispisati vrijednosti. U slu?aju da poziv web servisa nije uspio, o tom de se ispisati poruka.


Prije nego se navedeni kôd može pokrenuti i testirati, potrebno je u AndroidManifest.xml dodati dozvolu korištenja Interneta, a na odgovarajudoj aktivnosti pokrenuti sam postupak dohvadanja web servisa. Dozvola se dodaje prije oznake application:



A sam poziv servisa iz aktivnosti ?ine dvije, vrlo jednostavne linije kôda:


A to de u Logcat konzoli Android Studia rezultirati sa:



Što se obzirom na temperaturu u uredu autora ovog priru?nika ?ini kao to?an odgovor za kraj mjeseca srpnja :).



4.5 Pitanja za provjeru znanja
1. Koje mogudnosti za pohranu podataka nudi Android?
2. Što su klju?-vrijednost parovi?
3. Pojasnite razliku izme?u unutarnje i vanjske memorije.
4. Koja je putanja u datote?nom sustavu Androida do datoteka neke aplikacije?
5. Što je Android Debug Bridge?
6. ?emu služe normalne forme?
7. Kako se rješava problem veze M:N?
8. Što je omoguduje ORM sustav?
9. Samostalno definirajte bazu podataka s minimalno dva glavna entiteta za neki vama dobro poznat sustav.
10. Na koji na?in Android pokrede ažuriranje strukture tablice u bazi podataka?
11. Gdje se u Android projektu postavlja naziv baze podataka?
12. ?emu služe web servisi?
13. U ?emu biblioteka Retrofit olakšava rad s web servisima?
14. Što je GSON?
15. Pojasnite razliku izme?u SOAP i REST web servisa.
16. Što su POJO klase i ?emu služe?



4.6 Resursi za samostalan rad
* Robert Manger: Baze podataka - Drugo izdanje
Sveu?ilište u Zagrebu, Prirodoslovno matemati?ki fakultet, Matemati?ki odsjek, 2011
* Mladen Vedriš, Uvod u baze podataka
Te?ajevi srca, Sveu?ilište u Zagrebu, Sveu?ilišni ra?unski centar
* Ostale baze podataka, LevelDB, Couchbase Lite, BerkeleyDB, Realm
* Ostali ORM sustavi, SugarORM, Sprinkles, DBFlow
* Android aplikacije za u?enje SQL-a: Practice and Learn SQL, Learn SQL https://play.google.com/store/apps/details?id=com.knowledify.sqlush&hl=en https://play.google.com/store/apps/details?id=com.sololearn.sql&hl=en



5 PRIMJER RAZVOJA MOBILNE APLIKACIJE

Ovo poglavlje gradi na teorijskim osnovama prikazanim u svim prethodnim poglavljima, te na prakti?an i razumljiv na?in, metodom direktnog usmjeravanja vodi kroz cjelokupni proces razvoja mobilne aplikacije Memento. Cilj poglavlja je kroz prakti?an primjer prikazati koncepte razvoja mobilne aplikacije koja omoguduje korisniku evidenciju i kategorizaciju osobnih nastavnih, vannastavnih i privatnih obveza te pregled školskih vijesti koje se dohvadaju sa mrežnog servisa. Poglavlje razra?uje ideju Memento aplikacije, prikazuje kreiranje projekta, izradu programske logike i pogleda, te rad s lokalnim i udaljenim podacima.



SADRŽAJ POGLAVLJA
Memento	120
Kreiranje projekta	121
Izrada pogleda	124
Izrada entitetnih klasa	142
Unos i prikaz podataka – rad s dijalozima i fragmentima pogleda	148
Mobilna baza podataka	154
Korištenje web servisa	169
Dodatni resursi	180


5.1 Memento
Pojam memento dolazi s latinskog jezika i zna?i prisjedati se, odnosno pamtiti što je prikladan naziv za mobilnu aplikaciju ?iji se razvoj prati kroz ovo poglavlje. Naime, trenutno poglavlje daje potpuni pregled, od po?etka do kraja razvoja mobilne aplikacije koja omoguduje unos i pohranu osobnih zadataka prema razli?itima kategorijama te pradenje ispunjenosti istih. Nadalje, ona omoguduje svakom u?eniku da za svoju školu dobiva trenutno aktualne novosti. Kroz ovaj proces razvoja biti de govora o kreiranju po?etnog projekta, izradi Android pogleda, izradi entitetnih klasa, unosu i prikazu podataka, radu s dijalozima te radu s mobilnom bazom podataka i web servisima. Slika 68 prikazuje izgled, odnosno navigacijske putanje kroz Memento.

Slika 68. Mogu?e navigacijske putanje kroz mobilnu aplikaciju Memento


5.2 Kreiranje projekta
Prvi korak razvoja svake mobilne aplikacije je kreiranje projekta i odabir po?etnih postavki. Nakon pokretanja Android Studija potrebno je u „File“ odabrati opciju „New, New Project…“, nakon ?ega se inicijalizira dijalog koji korisnika vodi kroz kreiranje projekta.
Kao što se vidi na slici Slika 69, potrebno je navesti naziv aplikacije (engl. Application name), naziv tvrtke odnosno organizacije kojoj razvojni inženjer pripada (Company Domain), što ujedno definira i naziv korijenskog paketa mobilne aplikacije. Opcionalno, korisnik može odabrati lokaciju projekta na koju de se fizi?ki smjestiti svi artefakti projekta (tekstualne datoteke, izvršne datoteke, slike itd.). Podatke je potrebno popuniti prema sadržaju tablice (Tablica 16), nakon ?ega treba odabrati opciju
„Next“.

Tablica 16. Po?etni podaci o projektu

KonceptVrijednostApplication name:MementoCompany domain:heureka.hrProject location:<particija>:\Heureka\Memento
Slika 69. Kreiranje projekta, dijalog za definiranje naziva projekta


U sljededem dijalogu odabire se ure?aj za kojeg je mobilna aplikacija predvi?ena kao i najmanja verzija razvojnog paketa (engl. SDK – software development kit), što je prikazano na slici. Odabrati opciju „Phone and Tablet“, a za minimalnu verziju razvojnog paketa odabrati „API17: Android 4.2 (Jelly Bean)“ što bi prema prikazanom trebalo podržavati nešto više oko 87% ure?aja na tržištu. Po uspješnom odabiru treba nastaviti s kreiranjem projekta pritiskom na „Next“.



Slika 70. Odabir razvojnog paketa


Sljededi dijalog omoguduje korisniku odabir prve aktivnosti koje de kreirati AndroidStudio nakon završetka projekta kreiranja novog projekta. Me?u navedenim opcijama, kao na slici (Slika 71) odabrati opciju „Empty Activity“, što de kreirati praznu aktivnost bez bilo kakvih elemenata grafi?kog korisni?kog su?elja (engl. GUI, graphical user interface).


Slika 71. Odabir vrste po?etne aktivnosti


Posljednji dijalog u procesu kreiranja projekta traži korisnika unos naziva po?etne aktivnosti te pripadajudeg pogleda, odnosno grafi?ke reprezentacije. Prema tablici (Tablica 17) popuniti „Activity Name“ i „Layout Name“ što daje sadržaj prikazan na slici (Slika 72). Nakon unosa odabrati opciju
„Finish“.
Tablica 17. Kreiranje projekta, odabir imena glavne aktivnosti

VrstaNazivActivity name:MainActivityLayout name:activity_main
Slika 72. Odabir naziva glavne aktivnosti
Odabirom opcije „Finish“ proces kreiranja novog projekta je završen, a rezultat je vidljiv na slici (Slika 73), razvojno okruženje sa prikazom strukture projekta te kôdom po?etne aktivnosti MainActivity.java.



Slika 73. Uspješno kreiran projekt

5.3 Izrada pogleda
Kako de mobilna aplikacija, odnosno glavni pogled (activity_main.xml) sadržavati gumb koji lebdi nad sadržajem fragmenta (engl. FAB, floating action button) korijenski grafi?ki element pogleda treba biti CoordinatorLayout, koji omoguduje koordinaciju podelemenata specifi?nog tipa, odnosno animiranih grafi?kih elemenata iz “Material” specifkacije [39] [40].
5.3.1 Priprema dizajna glavne aktivnosti za tabove
Unutar prethodnog pogleda potrebno je dodati tri podelementa, AppBarLayout, TabLayout i ViewPager. AppBarLayout je pogled koji dopunjuje klasi?ni horizontalni izbornik uobi?ajeno na vrhu Android mobilne aplikacije sa dodatnim funkcionalnostima poput animiranog pomicanja sadržaja [41]. Kako de Memento sadržavati 3 horizontalno postavljena fragmenta kojima se pristupa pomicanjem ulijevo ili udesno, koristi se TabLayout za prikaz naziva tabova18 te pripadajudeg grafi?kog elementa koji prikazuje trenutnu poziciju te ViewPager koji omoguduje horizontalne tranzicije me?u fragmentima (koji predstavljaju sadržaj tabova) [42] [43].
U build.gradle (Module:app) dodati zavisnosti vezane uz komponente Material dizajna, što je potrebno za izmjenu zadane alatne trake tako da umjesto naslova mobilne aplikacije samo tabove:




18 U ovom priru?niku, umjesto rije?i „kartica“ za prikaz horizontalno strani?enog izbornika koristimo anglizam tab.
124


activity_main.xml:

Radi testiranja, u procesu razvoja preporu?ljivo je ?esto (odnosno nakon dodavanja funkcionalnosti ili izmjena) pokrenuti aplikaciju da se vide promjene i eventualno uo?e pogreške. Pokretanjem Mementa u trenutnom stadiju razvoja dobiva se rezultat prikazan na slici (Slika 74), pri ?emu je tekst koji prikazuje korištene poglede ozna?en crvenom bojom.




Slika 74. Izgled glavne aktivnosti nakon dodavanja AppBarLayout-a, TabLayout-a i ViewPager-a
Kako je vidljivo iz prethodne slike (Slika 74), još uvijek nije uklonjen naslov aplikacije. Da bi se to postiglo, potrebno je kreirati novi dizajn, koji se sastoji od stila i boja, definiranih redom u styles.xml i colors.xml.


U styles.xml definirati stil po imenu „MyMaterialTheme“, definirati da se ne prikazuje naslov te definirati osnovne boje u mobilnoj aplikaciji:


Dodati boje koje nedostaju u colors.xml:




A da bi promjene bile vidljive, u AndroidManifest.xml datoteci potrebno je specificirati korištenu temu izmjenom svojstva android:theme u:
android:theme="@style/MyMaterialTheme"	


Ponovno pokretanje Mementa prikazano je na slici (Slika 75). Uo?ljivo je da je uklonjen naslov aplikacije, TabLayout nije popunjen jer još nema dodanih tabova, a sadržaj ViewPagera je tako?er prazan. Sljededi korak je dodavanje tabova, njihovih naslova te ikona. Memento prikazuje tri taba, a) tab za prikaz unesenih zadataka koji nisu obavljeni, b) tab za prikaz uspješno obavljenih zadataka i c) tab za prikaz aktualnih novosti škole.


Slika 75. Rezultat promjene teme dizajna


5.3.2 Uvoz potrebnih ikona u projekt
Naslovi pojedinih tabova te njihovih ikona de biti postavljeni programski, što zna?i da je grafi?ke elemente potrebno dohvatiti u programskom kôdu, a ne u XML-u pogleda. Za pojednostavljenje korištenja grafi?kih elemenata u kôdu u ovom projektu koristi se biblioteka trede strane, ButterKnife koju je potrebno dodati u projekt u build.gradle (Module:app):


Sljedede što je potrebno jest u AndroidStudio projekt u?itati ikone za prikaz na tabovima. Desnim klikom na /res projektnog stabla odabrati opciju „New, Image asset…“ nakon ?ega se otvara dijalog prikazan na slici (Slika 76).

Slika 76. Dodavanje vektorskog resursa (slike) u projekt
U prethodnom dijalogu, iz padajudeg izbornika treba odabrati „Launcher icons“, a ostatak popuniti prema tablici (Tablica 18).
Tablica 18. Postavke za uvoz nove slike

KonceptVrijednostName:ic_assigmentsAsset Type:activity_mainPath:Putanja do datotekeScaling:Shrink to fitShape:NoneEffect:None

Sve ostale postavke ostaviti na zadane vrijednosti te odabrati opciju „Next“ i nakon toga „Finish“. Unutar direktorija res/mipmap sada je vidljiva upravo dodana ikona.
Na jednaki na?in kao i za ic_assigments ikonu koja de biti vezana uz tab zadataka u tijeku, potrebno je dodati još dvije ikone, ic_assigments_done i ic_news, za završene zadatke te za novosti dohvadene s web servisa što de biti vidljivo u stablu projekta kao što je prikazano na slici (Slika 77).



Slika 77. Prikaz dodanih ikona u strukturi projekta
5.3.3 Programsko dodavanje tabova i ikona
U MainActivity.java potrebno je dohvatiti TabLayout i ViewPager neposredno prije onCreate metode jednako kao i dohvatiti ikone iz repozitorija resursa projekta sljededim kôdom (kombinacijom Alt+Enter dodati zavisnosti koje nedostaju):



Nakon OnCreate metode dodati još dvije metode setupTabIcons i setupViewPager. Prva je zadužena za postavljanje ikona prema poziciji dodanih tabova dok je druga nešto kasnije služiti popunjavanju sadržaja pojedinih viewPager elemenata (sadržaj tabova):


I kona?no, u onCreate metodi potrebno je napraviti inicijalizaciju ButterKnife biblioteke, popuniti sadržaj tabova, asocirati ViewPager i TabLayout te definirati da za vrijeme izvo?enja ViewPager u memoriji ?uva 3 taba.


Unutar metode onCreate dodati:





Trenutno nije mogude pokretati aplikaciju jer najprije treba kreirati pogled (View) za svaki Tab te implementirati podsustav za upravljanje Tabovima.
5.3.4 RecyclerView, prvi dio – priprema
RecyclerView pogled de se koristiti za prikaz sadržaja liste zadataka ili dohvadenih vijesti. Taj pogled poseban je zbog toga što prikazuje samo ograni?eni set velikog skupa podataka te samostalno radi kasno u?itavanje vidljivih podataka (engl. Lazy Load) [44]. Vrlo ?esto, zbog bolje preglednosti u kombinaciji sa RecyclerView-om koristi se i CardView, koji elementima liste dodaje pozadinu te mogudnost zaokruženih rubova [45].
Za navedene poglede potrebno je dodati zavisnosti u build.gradle(Module:app) koji de prikazivati liste aktivnosti:



Obzirom da ViewPager podatke prikazuje korištenjem Adapter-a, odnosno mehanizma kojim se podaci vežu za grafi?ke elemente pogleda, potrebno je dodati FragmentStatePagerAdapter klasu u projekt [46] [47]. Ta klasa asocira ViewPager sa Fragmentima ?ime jedan fragment odgovara jednoj stranici, odnosno tabu, a isto tako dinami?ki popunjava pojedine stranice sadržajem u vremenu izvo?enja (tako?er LazyLoad).
Ovakav adapter u Memento projektu naziva se MainPagerAdapter, te je za dodavanje istog potrebno napraviti novi paket desnim klikom na korijenski paket projekta i odabrati „New“,
„Package“. Unutar navedenog paketa kreirati MainPagerAdapter.java klasu desnim klikom na novokreirani paket te odabirom „New“, „Java Class“.
Neposredno nakon toga, proširiti klasu super klasom FragmentStatePagerAdapter nakon ?ega de AndroidStudio ponuditi opciju auto-generiranja ne implementiranih metoda. Te metode, mogude je implementirati klikom na ikonu žarulje (vidi Slika 78) koja se pojavi na toj liniji kôda te odabrati opciju „Implement methods“ ili krade kombinacijom tipaka Alt+Enter.



Slika 78. Automatsko generiranje ne implementiranih naslije?enih metoda
Nakon te opcije, potrebno je implementirati dodane metode, getItem, getCount, addFragment i getPageTitle, te dvije liste. mFragmentList koja de sadržavati listu Fragmenata (koje prikazuju sadržaj taba) te listu naslova tabova, mFragmentTitleList.


MainPagerAdapter.java:



Sljededi korak je kreirati tri fragmenta za prikaz zadataka i vijesti te njihovih pripadajudih pogleda. Za grupiranje fragmenata koji de se prikazivati u tabovima kreirati novi paket naziva tab. fragments unutar glavnog paketa, a unutar istog kreirati tri Java klase proširene Fragment klasom (iz android.support.v4.app). Klase redom nazvati:
ActiveTasksFragment.java,
CompleteTasksFragment.java i NewsFragment.java, što daje rezultat prikazan na slici (Slika 79).



Slika 79. Fragmenti mobilne aplikacije Memento
Za svaki kreirani fragment, desnim klikom na paket /res „New“, „Resource File“ dodati poglede: fragment_active_tasks.xml, fragment_complete_tasks.xml i fragment_news.xml, što de dati rezultat prikazan na slici .

Slika 80. Pogledi asocirani s ranije dodanim fragmentima
Svakom od ranije kreiranih fragmenata, pridružiti odgovarajudi pogled putem preopteredenja metode
onCreateView. Za ActiveTasksFragment kôd je sljededi:




Isto je potrebno napraviti za preostala dva fragmenta, nakon ?ega je u MainActivity mogude dodati fragmente u ViewPager te inicijalizirati prikaz tabova. Za to je potrebno dopuniti ranije dodanu metodu setupViewPager:


Nakon ?ega je Memento mogude pokrenuti i vidjeti kreirane tabove što je prikazano na slici (Slika 81).

Slika 81. Memento nakon dodavanja tabova i odgovaraju?ih fragmenata


5.3.5 Postavke jezika i eksternalizacija tekstova
U kôdu metode setupViewPager je uo?ljivo da tabovi koji su dodani u listu trenutno imaju stati?ki definirane tekstove naslova, što nije dobar pristup programiranju jer se povedava broj to?aka koje je u kasnijem održavanju potencijalno potrebno mijenjati. Primjerice, što kada bi Memento trebao podržavati nekoliko razli?itih svjetskih jezika, koji bi se tekst tada unosio?
Sredom, u razvoju Android aplikacija takav se problem rješava vrlo elegantno, korištenjem strings.xml datoteke koja se nalazi unutar /res/values paketa, a namijenjena je tome da sadrži sve tekstove koje aplikacija koristi. Dodatno, svi su tekstovi na jednom mjestu, jednostavno se dohvadaju iz programskog kôda te ih je mogude prevoditi.
Potrebno je otvoriti navedenu datoteku i dodati sve tekstove koje Memento koristi, na engleskom jeziku:



Ovisno o postavkama Android ure?aja, odnosno odabranom zadanom jeziku sustava, aplikacija može u?itavati strings.xml datoteku prema „Locale“ kvalifikatoru. Pomodu kvalifikatora, u Android mobilnim aplikacijama specificira se pojedina?na konfiguracija razli?itih resursa (slika, tekstova itd.) [48].
Kako bi se dodao prijevod mobilne aplikacije na hrvatski jezik prema ranije definiranim tekstovima, desnim klikom na /res odabrati opciju „New“, „Android resource file“ nakon ?ega se otvara dijalog prikazan na slici (Slika 82).
Pod opcijom „File name:“ potrebno je upisati strings, kao „Resource type:“ odabrati Values, a pod
„Available qualifiers“ odabrati „Locale“ nakon ?ega treba pritisnuti gumb „ >>“ (ozna?en crvenom bojom na slici (Slika 82)).



Slika 82. Odabir kvalifikatora za prijevod mobilne aplikacije


Nakon toga, pojavit de se dodatne opcije pod „Chosen qualifiers“ gdje treba odabrati „HR:Croatia“ što de otvoriti dodatne opcije „Language“ i „Specific Region Only“ prikazane na slici (Slika 83), prema kojoj je potrebno popuniti ostatak dijaloga i na kraju odabrati opciju OK.
Za dodavanje novog prijevoda datoteke strings.xml postupak je jednaki, samo je potrebno odabrati drugi jezik. U kôdu koji slijedi koristiti de se tekstovi iz datoteke strings.xml, a ?iji je prijevod vidljiv nakon promjene jezika Android sustava na ure?aju (naj?ešde u glavnom izborniku, pod sustavskim postavkama opcija „Language & input“).

Slika 83. Odabir jezika i regije za „Location“ kvalifikator


U strukturi projekta, datoteka strings.xml se sada prikazuje kao direktorij, gdje je glavna strings.xml datoteka za engleski jezik, a svaka druga koja je dodana putem opcije „Location“ kvalifikatora je ozna?ena sa skradenim zapisom kvalifikatora u zagradama, što je prikazano na slici (Slika 84).


Slika 84. Uspješno dodani prijevod strings.xml datoteke za hrvatski jezik
Za prevo?enje, potrebno je odabrati hrvatsku verziju strings.xml datoteke, u nju zalijepiti sadržaj zadane verzije datoteke i upisati prijevod. U Java kôdu tekstovi se u?itavaju prema nazivu, dok je strings.xml datoteka automatski odabrana prema postavkama sustava.
strings.xml (hr):



I kona?no, da bi promjene bile uo?ljive, potrebno je u Java kôdu dinami?ki ?itati tekstove. Trenutno, jedino mjesto na kojem je to mogude jest u MainActivity.java za naslove tabova:





Aplikaciju je sada mogude pokrenuti, a promjene se mogu uo?iti samo promjenom jezika Android sustava, kao što pokazuje slika (Slika 85). Prvi dio (1) pokazuje trenutni izgled Mementa u slu?aju kada je hrvatski jezik zadani jezik Android sustava. U drugom dijelu slike (2) promijenjen zadani jezik je promijenjen u engleski, nakon ?ega je Memento ponovno pokrenut. Sada je vidljivo (3) da se koristi engleska verzija strings.xml datoteke.



(1)(2)(3)Slika 85. Promjena jezika Android sustava mijenja zadanu strings.xml datoteku
5.3.6 RecyclerView, drugi dio – adapteri
Svaki pogled od tri ranije kreirana temeljna fragmenta sadržavat de listu objekata, odnosno popis zadataka ili popis vijesti. Kako bi se lista iz programskog kôda prikazala na listi grafi?kog korisni?kog su?elja, koristi se ranije spominjan RecyclerView kojeg je potrebno dodati u pogled fragment_active_tasks.xml:




Obzirom da FAB koristi sliku, potrebno je dodati istu u res/drawable na sli?an na?in kao i ranije, uz razliku da se ovaj put iz padajudeg izbornika odabere „Action bar and tab icons“. Nakon pokretanja aplikacije, FAB se nalazi u donjem desnom kutu, kako je prikazano na slici (Slika 86). Ista slika ujedno pokazuje grafi?ke elemente koji trenutno nisu vidljivi.

Slika 86. Po?etni prikaz nakon dodavanja FAB-a i prikaz okvira pojedinih pogleda
CoordinatorLayout se u ovom slu?aju koristi za prikaz FAB-a i LinearView koji de sve elemente liste sortirati jedan do drugog, horizontalno ili vertikalno, ovisno o odabiru. Jedini podelement trenutno de biti RecyclerView koji de sadržavati listu zadataka Item 1, Item 2, … , Item n (ili u slu?aju za Novosti listu vijesti).


Jedan element liste, na slici (Slika 86) ozna?en kao „Item“, potrebno je upisati pogledom u XML-u, te ga novim Adapter-om vezati za RecyclerView. Unutar /res/layout napraviti novu datoteku naziva task_item.xml za opis izgleda jednog retka RecyclerView-a, odnosno zadatka:
<?xml version="1.0" encoding="utf-8"?>
<android.support.v7.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/cv" android:layout_marginBottom="5dp" android:clickable="true" android:focusable="true"
android:foreground="?android:attr/selectableItemBackground">

<LinearLayout
android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal">

<LinearLayout
android:layout_width="8dp" android:layout_height="match_parent" android:id="@+id/lv_category" android:orientation="horizontal" android:background="@android:color/holo_blue_dark">
</LinearLayout>
<LinearLayout
android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" android:padding="5dp">

<TextView
android:id="@+id/tv_rv_name" android:layout_width="wrap_content" android:layout_height="wrap_content" tools:text="Football on Sunday" style="@style/Base.TextAppearance.AppCompat.Medium"/>

<TextView
android:id="@+id/tv_rv_deadline" android:layout_width="wrap_content" android:layout_height="wrap_content" tools:text="28.1.2015" style="@style/Base.TextAppearance.AppCompat.Small"/>

</LinearLayout>
</LinearLayout>

</android.support.v7.widget.CardView>


Slika 87 vizualizira navedeni XML kôd s naglašenim korištenim grafi?kim elementima, LinearLayout koji elemente smješta horizontalno, to su novi LinearLayout za prikaz boje odabrane kategorije te još jedan LinearLayout koji svoje elemente smješta vertikalno. Ti elementi su TextView pogledi koji služe prikazu naslova zadatka i vremenu kada se održava.




Slika 87. Grafi?ka reprezentacija XML kôda za opis jednog elementa RecyclerView liste za prikaz zadataka
Posljednji korak prije nego što je mogude pokrenuti mobilnu aplikaciju je povezati RecyclerView iz pogleda sa listom u kôdu, odnosno kreirati RecyclerView.Adapter koji task_item.xml pridružuje k fragment_active_tasks.xml.
Unutar postojedeg paketa adapters dodati novu klasu i nazvati je ActiveTasksRecyclerViewAdapter.java koja služi povezivanju liste zadataka dohvadenih iz lokalne baze podataka listi prikazanoj na ekranu. Uz to, treba napraviti novi paket naziva viewholders unutar kojeg je potrebno kreirati klasu TaskViewHolder.java. ViewHolder klasa predstavlja logiku upravljanja elementima liste, odnosno obra?uje doga?aje i radi sa grafi?kom reprezentacijom jednog elementa RecyclerView-a [32], koji je u ovom slu?aju task_item.xml.
Klasu TaskViewHolder proširit klasom RecyclerView.ViewHolder:



Nadalje, ViewHolder se obi?no veže za entitetne klase koje opisuju objekte prikazane u RecyclerView listi. Kako trenutno Memento nema nikakvih podataka ni takvih klasa, prije daljnjeg razvoj potrebno je kreirati entitetne klase, odnosno klase koje de opisivati zadatke i novosti, a ?iji de objekti kasnije biti spremani u bazu podataka.




5.4 Izrada entitetnih klasa
Za entitetne klase treba napraviti novi paket i nazvati ga entities, a unutar istog kreirati tri klase, koje reprezentiraju tri glavna entiteta koja Memento koristi; zadatak, kategorija zadatka i vijest. Kako de zadatak i kategorija zadatka biti zapisani u lokalnoj bazi podataka njihove de klase imati prefiks Db, a klasa za vijesti koje se u?itavaju putem web servisa de imati prefiks Ws. Dakle, kreirati DbCategory.java, DbTask.java i WsNewItem.java.
DbCategory.java sadrži dva atributa, za naziv kategorije i kôd boje:


Korištenjem AndroidStudio alata, kreirati mutatorske metode i konstruktor. Na bijeli prostor u podru?ju za pisanje kôda desnim klikom odabrati opciju „Generate“ (ili krade Alt+Insert), nakon ?ega se pojavljuje kontekstualni izbornik (Slika 88-1), unutar kojeg treba ozna?iti sve atribute (Slika 88-2).


(1)(2)Slika 88. Generiranje mutatorskih metoda

Na gotovo identi?an na?in se dodaje konstruktor, no na kontekstualnom izborniku prikazanom na Slika 88-1 ovaj puta odabrati opciju „Constructor“, a kao parametre ozna?iti svojstva name i color, što de rezultirati sa:




Isto je potrebno napraviti za klasu DbTask ?iji konstruktor treba primati parametre name, dueDate i category:


I na kraju klasa WsNewsItem.java:







Kako trenutno lokalna baza podataka još nije napravljena, potrebno je napraviti demo, odnosno testne podatke koji de se prikazivati u listama. Za tu svrhu, jednostavno kreirati novu klasu nazvanu MockDataLoader unutar novog paketa kojeg treba nazvati helpers.
MockDataLoader.java:



Da bi se ti podaci prikazali, potrebno je dovršiti TaskViewHolder klasu proširenjem koje povezuje kôd sa elementima grafi?kog korisni?kog su?elja, a putem konstruktora dobiva referencu na odgovarajudi RecyclerView te popis elemenata, odnosno zadataka za prikaz. TaskViewHolder postaje:

Tako?er, treba završiti ActiveTasksRecyclerViewAdapter koji de koristiti instancu klase
TaskViewHolder i pomodu nje postaviti vrijednosti atributa za prikaz:




Posljednji korak prije testiranja prikaza jest u ActiveTasksFragment fragmentu dohvatiti
RecyclerView i prosljediti mu demo podatke za prikaz:


Memento je spreman za testiranje prikaza demo podataka. Pokretanje mobilne aplikacije rezultira ekranom koji prikazuje tri unesena demo podatka prikazana na slici (Slika 89).




Slika 89. Prikaz demo podataka


5.5 Unos i prikaz podataka – rad s dijalozima i fragmentima pogleda
Kako bi se korisnicima mobilne aplikacije Memento omogudilo unošenje podataka, potrebno je kreirati dijalog koji de sadržavati polja za unos naziva zadatka, vremena i datuma te odabira kategorije. Dijalog se aktivira pritiskom na FAB.
Prvi  korak  za  postizanje  tog  cilja  jest  kreirati  novu  task_dialog.xml datoteku  u
/res/layouts direktoriju koja opisuje dizajn dijaloga:
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical"
android:layout_width="match_parent" android:layout_height="wrap_content" android:padding="15dp">

<TextView
android:layout_width="wrap_content" android:layout_height="wrap_content" android:textAppearance="?android:attr/textAppearanceSmall" android:text="@string/dialog_title" android:id="@+id/dialogTaskName" />

<EditText
android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/dialogEditTaskName" />

<TextView
android:layout_width="wrap_content" android:layout_height="wrap_content" android:textAppearance="?android:attr/textAppearanceSmall" android:text="@string/dialog_date" android:id="@+id/dialogTaskDate" />
<EditText
android:layout_width="match_parent" android:layout_height="wrap_content" android:inputType="date" android:ems="10" android:id="@+id/dialogEditDate" />

<TextView
android:layout_width="wrap_content" android:layout_height="wrap_content" android:textAppearance="?android:attr/textAppearanceSmall" android:text="@string/dialog_time" android:id="@+id/dialogTaskTime" />

<EditText
android:layout_width="match_parent" android:layout_height="wrap_content" android:inputType="time" android:ems="10" android:id="@+id/dialogEditTime" android:layout_gravity="right" />

<TextView
android:layout_width="wrap_content" android:layout_height="wrap_content" android:textAppearance="?android:attr/textAppearanceSmall" android:text="@string/dialog_category" android:id="@+id/dialogTaskCategory" />

148




Grafi?ka reprezentacija navedenog kôda prikazana je na slici (Slika 90). Koriste se tri TextView pogleda koji samo navode sadržaj koji korisnik unosi, tri EditText pogleda u koje se zapisuje korisnikov odabir i Spinner koji omoguduje odabir kategorije iz padajudeg izbornika.

Slika 90. Vizualizacija task_dialog.xml kôda s naglašenim grafi?kim elementima
Kako bi se prikazao kreirani dijalog pritiskom na FAB, u klasi ActiveTaskFragment treba dodati metodu koju ButterKnife aktivira prilikom onClick doga?aja:

Pokretanjem Mementa i pritiskom na FAB, otvara se dijalog, no kako trenutno Spinner nema asociranih podataka, nije mogude odabrati kategoriju. Rezultat pokretanja vidljiv je na slici (Slika 91).




Slika 91. Dijalog za dodavanje novog zadatka (bez dodanih kategorija)
Nije poželjno da korisnik samostalno unosi vrijeme i datum zbog mogudnosti unosa razli?itih formatiranja podataka, zbog ?ega de se uz EditText poglede asocirane uz datum i vrijeme aktivirati posebni dijalozi Android sustava koji služe odabiru vremenskih podataka. Za to je potrebno dodati novu klasu u paket helpers naziva DialogHelper.java i ona de biti odgovorna za prikaz dijaloga za unos datuma i vremena, za asociranje Spinner-a sa podacima te za spremanje unosa korisnika, najprije samo u privremenu memoriju, a kasnije i u bazu podataka. Sadržaj klase je:





Za prikaz zadanih dijaloga Android sustava koji omoguduju unos datuma i vremena u to?no definiranom formatu (npr. mm/dd/yyyy – HH:mm) potrebno je pomodu ButterKnife biblioteke reagirati na onFocusChange doga?aj za navedene EditText poglede. Isto tako nakon prikaza pojedinog dijaloga za odabir datuma ili vremena, potrebno je dohvatiti unos korisnika. U tu svrhu potrebno je dodati dvije metode koje reagiraju na OnFocusChange doga?aj te dvije metode koje reagiraju na doga?aj završetka unosa podataka korisnika. Na kraj klase DialogHelper.java dodati:
// prikaz dijaloga za odabir vremena
@OnFocusChange(R.id.dialogEditTime)
public void onEditTimeClick(View view, boolean hasFocus){
if(!hasFocus) return;
TimePickerDialog timePickerDialog = new TimePickerDialog(context,
onTimeSetListener,
              selectedDate.get(Calendar.HOUR_OF_DAY), selectedDate.get(Calendar.MINUTE), true);
timePickerDialog.show();
}

// prikaz dijaloga za odabir datuma
@OnFocusChange(R.id.dialogEditDate)
public void onEditDateClick(View view, boolean hasFocus){
if(!hasFocus) return;
DatePickerDialog datePickerDialog = new DatePickerDialog(context,
onDateSetListener,
              selectedDate.get(Calendar.YEAR), selectedDate.get(Calendar.MONTH), selectedDate.get(Calendar.DAY_OF_MONTH));
datePickerDialog.show();
}

// dohva?anje odabranog vremena TimePickerDialog.OnTimeSetListener onTimeSetListener = new TimePickerDialog.OnTimeSetListener() {
@Override
public void onTimeSet(TimePicker view, int hourOfDay, int minute) { selectedDate.set(Calendar.HOUR_OF_DAY, hourOfDay); selectedDate.set(Calendar.MINUTE, minute);

SimpleDateFormat df = new SimpleDateFormat("HH:mm");
editTime.setText(df.format(selectedDate.getTime()));
}
};

// dohva?anje odabranog datuma DatePickerDialog.OnDateSetListener onDateSetListener = new DatePickerDialog.OnDateSetListener() {

151





I na kraju je potrebno dodati instancu klase DialogHelper u ActiveTasksFragment klasu koja de se kasnije koristiti za iniciranje postupka pohrane podataka. U klasu ActiveTasksFragment, odnosno metodu onFabClicked dodati podebljanu liniju kôda:


Memento je sada mogude testirati na na?in da se ponovno pritisne FAB i odabere EditText za unos datuma, što de aktivirati zadani prozor Android sustava kao što je prikazano na slici (Slika 92). Uz to ovaj put je i Spinner popunjen demo podacima.




Slika 92. Zadani dijalog Androida za odabir datuma


5.6 Mobilna baza podataka
Za olakšano korištenje baze podataka dobra je praksa primijeniti neku biblioteku trede strane jer bez toga je korištenje SQLite baze podataka koju nudi Android sustav dosta neprakti?no i složeno. U ovom projektu koristi se ActiveAndroid, za što je potrebno u build.gradle (Project: Memento) dodati Maven repozitorij:


Nakon ?ega je u build.gradle (Module:app) dodati zavisnost prema ActiveAndroid biblioteci:


Za dovršetak procesa dodavanja baze podataka u AndroidManifest.xml potrebno je dodati meta podatke o bazi podataka, odnosno njeno ime i verziju. Nakon svake promjene strukture baze podataka, odnosno entitetnih klasa verziju treba ru?no povedati za jedan. Neposredno nakon taga koji se odnosi na glavu aktivnost, no prije završetka taga aplikacije dodati:



Nakon ovog koraka, baza podataka je spremna za korištenje.
Kako bi ranije dodane klase, postale entitetne klase koje se mogu spremati i ?itati iz baze podataka Mementa potrebno je proširiti klasom Model iz ActiveAndroid biblioteke, klasi dodati anotaciju koja definira naziv pripadajude tablice, a atributima dodati antoacije koje definiraju nazive pripadajudih atributa. Za klasu DbCategory proširenje izgleda ovako:




Klasa DbTask postaje:



I kona?no, dodati inicijalizaciju ActiveAndroid biblioteke u onCreate metodu glavne aktivnosti,
MainActivity:



Nakon pokretanja Mementa, korištenjem adb-a mogude je navigirati do baze podataka, te koristiti
Sqlite3 za izvršavanje kao što prikazuje slika (Slika 93).




Slika 93. Postavljanje SQL upita direktno na bazi podataka mobilnog ure?aja
Kako je vidljivo na slici (Slika 93), trenutno nema podataka, stoga potrebno je izmijeniti klasu MockDataLoader tako da koristi bazu podataka i popuni je demo podacima. No prije toga klasama DbTask i DbCategory treba dodati metode kojima de se dohvadati njihovi podaci iz baze podataka. Za DbCategory to de biti metoda getAll koja dohvada sve kategorije i getCategoryByName koja dohvada kategoriju prema zadanom nazivu:



Za klasu DbTask to de biti metoda getAll koja de dohvatiti sve završene ili nezavršene zadatke, ovisno o zadanom parametru:



Da bi klasa MockDataLoader koristila bazu podataka potrebno je napraviti listu objekata klasa sa Db prefiksom, nakon ?ega se nad svim objektima poziva metoda save iz superklase Model ActiveAndroid-a:


U klasi ActiveTasksFragment, treba ažurirati metodu onViewCreated kako bi ona ?itala podatke iz baze podataka:



U klasi DialogHelper, izmijeniti metodu populateSpinner da bi prikazivala podatke iz baze podataka:




U klasi MainActivity, za svrhe testiranja, u onCreate metodi pozvati spremanje demo podataka ukoliko je baza podataka prazna sa sljededim kôdom:


Kako de u kona?noj verziji korisnik popunjavati bazu podataka osobnim zadacima, ovaj kôd se u kasnijoj fazi, nakon testiranja rada sa bazom podataka može obrisati.
Memento se sada može pokrenuti, ?ime se dobivaju podaci iz baze podataka:

Slika 94. Zadaci u?itani iz mobilne baze podataka


Sli?no kao ranije, putem adb-a je mogude upitima nad bazom podataka provjeriti unesene podatke te njima manipulirati direktno iz ljuske Android operacijskog sustava, što je prikazano na slici (Slika 95).

Slika 95. Pregled unesenih podataka putem ljuske Android operacijskog sustava

Kako trenutno završeni zadaci nisu vidljivi na tabu „Završeno“, potrebno je na vrlo sli?an na?in kao i ranije za aktivne zadatke, ažurirati fragment za prikaz završenih zadataka. U ovom slu?aju, pogled fragment_complete_tasks.xml za razliku od fragment_active_tasks.xml ne sadrži FAB, ved samo RecyclerView drugog naziva:



Dok je kôd klase CompleteTasksFragment, sli?an kôdu klasi ActiveTasksFragment, uz drugi parametar za metodu DbTask.getAll(). Ovoga puta parametar je 1 i ozna?ava dohvadanje završenih zadataka. Klasi CompleteTasksFragment potrebno je dodati zatamnjene linije kôda:





Memento je spreman za testiranje, a nakon pokretanja, navigiranjem na sljededi tab „Završeno“, prikazuju se i završeni zadaci dohvadeni iz baze podataka. Rezultat je vidljiv na slici (Slika 96).


Slika 96. Prikaz završenih aktivnosti na tabu „Završeno“


5.6.1 Unos, pohrana i prikaz podataka
Umjesto da se prikazuju demo podaci koji su u svrhu testiranja umjetno dodani u bazu podataka, potrebno je proširiti trenutnu implementaciju mobilne aplikacije kako bi se omogudio zapis podataka korisnika.
Prvi korak k tome je dodavanje save metode u DialogHelper klasu koja de u novu instancu klase DbTask zapisati podatke koje korisnik unese putem dijaloga, a nakon toga nad tim objektom izvršiti metodu save ActiveAndroida. Na kraj klase DbHelper dodati metodu save sadržaja:


Isto tako, potrebno je proširiti onFabClicked metodu iz klase ActiveTasksFragment kako bi uhvatila doga?aj zatvaranja dijaloga i putem instance objekta DialogHelper inicirala upravo dodanu metodu save. Sadržaj metode onFabClicked:


zamijeniti sa:


Memento je spreman za pokretanje. Aktivacijom dijaloga za unos podataka pritiskom na FAB, u dijalogu treba unijeti novi zadatak „First database task“ 8.8.2016 u podne pod kategorijom Books. Slika 97 prikazuje rezultat uspješnog dodavanja.




Slika 97. Prikaz novoga zadatka unesenog putem dijaloga „First database task“


Trenutno dodane aktivnosti nije mogude brisati ili ozna?iti kao završenima, stoga je potrebno dodati novi dijalog koji de korisniku to omoguditi. Novi dijalog aktivirati de se doga?ajem „produženog pritiska“ (engl. long click). Kako se radi o pritisku na element liste RecyclerView pogleda, taj doga?aj je potrebno obraditi u pripadajudoj ViewHolder klasi. U ovom slu?aju radi se o TaskViewHolder-u.
Prvi korak prema obradi spomenutog doga?aja je proširenje klase TaskViewHolder su?eljem
View.OnLongClickListener:



Nakon ?ega je potrebno generirati metode ?iju implementaciju nalaže programsko su?elje (kradi na?in implementacije je ved spomenut; Alt+Enter), što rezultira klasom metodom onLongClick:



Unutar navedene metode implementira se reakcija na doga?aj nakon što korisnik pritisne i nastavi neko vrijeme držati prst na ekranu, odnosno nad nekim zadatkom. U ovom slu?aju, korisniku de se prikazati dijalog sa tri opcije: a) opcija kojom se zadatak ozna?i kao završeni, b) opcija kojom se zadatak obriše i c) opcija kojom se dijalog otkaže.
dijaloga i obrada opcije brisanja (dodati unutar onLongClick metode, prije return
(BUTTON_NEUTRAL, lijevi gumb).



Odmah nakon prethodnog kôda, potrebno je definirati ponašanje prilikom ozna?avanja zadatka kao završenog (BUTTON_POSITIVE, srednji gumb):



I zadnja opcija (BUTTON_NEGATIVE, srednji gumb) je otkazivanje dijaloga:


?ime je metoda onLongClick završena (i ona vrada false). Jedino što preostaje jest prijaviti trenutnu klasu TaskViewHolder kao sluša?a doga?aja onLongClick unutar konstruktora:



Nakon pokretanja Mementa te dužim pritiskom na neki od zadataka, aktivira se dijalog prikazan na slici (Slika 98).




Slika 98. Dijalog koji omogu?uje brisanje zadatka i ozna?avanje zadatka kao završenog
Nastavno na prethodnu radnju, ako se ranije dodani zadatak „First database task“ ozna?i kao završen odabirom opcije „Završeno“, on se uklanja s liste. No, navigiranjem do taba „Završeno“ može se uo?iti da nije prikazan, što je ilustrirano na slici (Slika 99).




	

(1)(2)Slika 99. Nakon ozna?avanja zadatka kao završenog, tab Zavrešeno ne osvježava listu

Rješenje navedenog problema je da prilikom pomicanja tabova, ViewPager kontrola inicira osvježavanje fragmenta za prikaz završenih zadataka. Za to je u klasi MainActivity, odnosno metodi setupViewPager potrebno dodati sluša? doga?aja koji reagira na primjenu stranice. Na kraj metode setupViewPager dodati addOnPageChangeListener:





Metoda onPageSelected treba inicirati osvježavanje podataka iz baze podataka prikazanih na fragmentu. Iako trenutno postoje samo dva takva fragmenta, kako bi u bududnosti uz mogude nadogradnje, a i sada bio jednostavniji pristup osvježavanju podataka, potrebno je napraviti programsko su?elje. Takvo programsko su?elje de sadržavati metodu koja inicira osvježavanje nad svim klasama koje ga implementiraju. Tako?er, na taj na?in mogude je prodi listom svih fragmenata i ukoliko je promatrani fragment instanca tog su?elja, pozvati metodu za osvježavanje.


U ovom slu?aju, klase ActiveTasksFragment i CompleteTasksFragment de implementirati su?elje DataFragment koje je potrebno kreirati unutar helpers paketa. Desnim klikom na paket, odabrati opciju „New“, „Java Class“, nakon ?ega u dijalogu opciju „Kind“ odabrati „Interface“, kao što je prikazano na slici. DataFragment de implementirati svi fragmenti koji koriste bazu podataka.

Slika 100. Kreiranje programskog su?elja
Su?elje DataFragment sadrži prototip samo jedne metode, ?ija implementacija se mora pobrinuti za dohvadanje odgovarajudih podataka:


Klasa CompleteTasksFragment, de dohvatiti i prikazati zadatke koji su završeni, a programski kôd klase ActiveTaskFragments de dohvatiti i prikazati završene zadatke. Najprije, klasu CompleteTasksFragments treba proširiti klasom Fragment te njome implementirati DataFragment programsko su?elje:



Nakon ?ega je potrebno dodati nedostajudu metodu reloadData (Alt+Enter) ?iji kôd je:



Na isti na?in, su?elje treba implementirati u klasi ActiveTasksFragment, no ovoga puta u implementaciji, odnosno kod poziva getAll metode proslje?uje se drugi parametar:


Za završetak implementacija osvježavanja sadržaja fragmenata koji prikazuju podatke iz mobilne baze podataka  u  klasi  MainActivity,  metodi  setupViewPager na  mjestu  komentara
„implementacija osvježavanja lista“, dodati kôd koji prolazi kroz sve tabove, odnosno fragmente, a nad onima koji implementiraju programsko su?elje za osvježavanje podataka, izvršiti metodu reloadData:



Mobilna aplikacija spremna je za testiranje. Pokrenuti aplikaciju i dodati novi zadatak naslovljen „Test refresh“ u bilo koje vrijeme i u bilo koju kategoriju, te ga potom ozna?iti kao završenog. Nakon otvaranja drugog taba „Završeno“ upravo ozna?eni zadatak „Test refesh“ de se pojaviti na listi, kao što je prikazano na slici (Slika 101).
Uz ozna?avanje završenosti pojedinih zadataka, može se testirati i brisanje zadataka.


  

Slika 101. Osvježavanjem podatkovnih fragmenata završeni zadaci se ispravno prikazuju




5.7 Korištenje web servisa
Web aplikacija koja omoguduje unos vijesti koje se kasnije putem REST web servisa dohvadaju u Memento mobilnoj aplikaciji prikazana je na slici (Slika 102). Ona predstavlja samo demo sustav putem kojeg se unosi naslov, datum, poruka vijesti te povezana slika te se zapisuje u bazu podataka na poslužitelju. Isto tako, ona sadrži REST web servis putem kojeg je te vijesti mogude dohvatiti u JSON obliku u mobilnoj aplikaciji.

Slika 102. Korisni?ko su?elje jednostavne web aplikacije za unos novosti, s implementacijom REST web servisa


Struktura odgovora je prikazana u sljededem paragrafu. Kao što je vidljivo, sastoji se od dva osnovna atributa, count koji sadrži vrijednost broja dohvadenih rezultata (odnosno novosti), te atribut results koji nosi sadržaj pojedinih vijesti. Jedna vijest sastoji se od ranije spomenutih, name (naziva novosti), text (sadržaja vijesti), date (vremena objave), te image_path (što je tekst koji predstavlja putanju do slike na serveru, umjesto da je slika upisana direktno u bazu podataka).




Iste atribute treba sadržavati i lokalna klasa u koju de se zapisivati rezultati odgovora web servisa, odnosno prema kojoj de se obraditi JSON odgovor. Klasa WsNewsItem ved sadrži sve potrebne elemente.
5.7.1 Priprema za ispis podataka
Prije samog po?etka rada sa web servisom, potrebno je pripremiti NewsFragment na na?in da se kreira novi RecyclerView, odgovarajudi adapter te opiše element liste. Obzirom na to prvi korak je dodati novi prikaz u res/layout direktorij koji de opisivati izgled jedne dohvadene vijesti i nazvati ga news_item.xml:
<?xml version="1.0" encoding="utf-8"?>
<android.support.v7.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/cv_news" android:layout_marginBottom="5dp" android:clickable="true" android:focusable="true"
android:foreground="?android:attr/selectableItemBackground">

<LinearLayout
android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" android:padding="5dp" android:weightSum="1">

<ImageView
android:layout_width="64dp" android:layout_height="64dp" android:id="@+id/rv_ni_image" android:paddingLeft="5dp" />
<LinearLayout
android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:paddingLeft="5dp">
<TextView
android:layout_width="wrap_content" android:layout_height="wrap_content"

170





Kako de se vijesti dohvatiti samo kada korisnik to zatraži, fragment_news.xml de sadržavati i FAB koji de inicirati poziv web servisa i prikaz odgovora. Stoga, u projekt je potrebno dodati ikonu koju de FAB prikazivati. Kao i ranije, desnim klikom na /res odabrati opciju „New“, „Image asset“. U prikazanom dijalogu odabrati „Launcher icons“, Asset Type: „Image“, a nakon toga pronadi ikonu za osvježavanje. Naziv ikone treba postaviti na ic_refresh. Pod Shape kao i ranije odabrati „None“, nakon ?ega odabrati opciju „Next“ i na kraju „Save“. Vezani dijalog prikazan je na slici (Slika 103).


Slika 103. Dodavanje ikone za osvježavanje
Nakon  prethodnog  koraka,  mogude  je  proširiti  fragment_news.xml dodavanjem
RecyclerView-a koji de prikazivati novosti te FAB-om za iniciranje web servisa sljededim kôdom:





Kao i ranije, za RecyclerView potrebno je kreirati novi adapter te ViewHolder. U paketu adapters stoga treba kreirati klasu NewsRecyclerViewAdapter, a u paket viewholders dodati klasu NewsViewHolder.
Klasu NewsViewHolder treba proširiti klasom RecyclerView.ViewHolder te povezati elemente grafi?kog korisni?kog su?elja s kôdom putem ButterKnife anotacija:


NewsRecyclerViewAdapter klasa se proširuje klasom RecyclerView. Adapter<NewsViewHolder>, nakon ?ega se nudi opcija automatskog dodavanja ne- implementiranih metoda koji treba prihvatiti (klikom na ikonu žarulje ili kombinacijom na tipkovnici Alt+Enter). To de dati sljededi rezultat:




Prije nego što je mogude potpuno implementirati generirane metode, potrebno je dodati referencu na novu biblioteku trede strane, Picasso koja de olakšati rad sa slikama dohvadenim putem web servisa. U build.gradle (Module:app) dodati:


A za NewsRecyclerViewAdapter dodati sli?an kôd kao i za zadatke. Potrebna je lista trenutnih vijesti, metoda za povezivanje sa odgovarajudim ViewHolderom onCreateViewHolder, te najvažnije, grafi?kim elementima pridružiti naslov, datum i sliku u metodi onBindViewHolder. Sljededi kôd prikazuje implementaciju NewsRecyclerViewAdapter-a:


5.7.2 Implementacija infrastrukture za rad sa web servisima
Za rad sa web servisima koriste se dvije temeljne biblioteke trede strane, Retrofit i GSON [37] [38]. Retrofit je HTTP klijent koji omoguduje definiranje ruta do web servisa te sigurno asinkrono pozivanje istih. U kombinaciji sa bibliotekom GSON za serijalizaciju JSON formatiranih podataka omoguduje vrlo elegantno korištenje REST web servisa, na na?in da olakšava definiranje putanja do web servisa, ?itanje rezultata web servisa i upravljanje HTTP komunikacijom bez potrebe za direktnom implementacijom višenitnog rada.
Za korištenje navedenih biblioteka u build.gradle (Module:app)je potrebno dodati njih te njihove zavisnosti:


Memento de ?itavo vrijeme pristupati slikama dohvadenima sa web servisa, pa kako ne bi ?itavo vrijeme bilo potrebe za upisivanjem duge putanje do lokacije slika, u strings.xml dodati putanju, koja de se kasnije koristiti u programskom kôdu:



Sljedede što je potrebno jest dodati infrastrukturu za rad sa web servisima. Za tu svrhu, kreirati novi paket i nazvati ga webservice, a unutar istog kreirati dvije klase i jedno su?elje; klasa WsDataLoader de pozivati web servis, klasa WsResponse opisuje izgled odgovora koji de se prilagoditi lokalnoj klasi WsNewsItem i kona?no su?elje WsCaller sadrži putanju i naziv metode web servisa koji se poziva.


WsResponse:


Važno je uo?iti da je sadržaj ove klase jednak odgovoru s web servisa, a koristan sadržaj koji se prikazuje na fragmentu vijesti zapisan je u obliku liste WsNewsItem elemenata. Prilagodbu odgovora, odnosno serijalizaciju radi GSON biblioteka. Jako je važno da atributi klase WsResponse odgovaraju atributima sirovog JSON odgovora, a atributi klase WsNewsItem odgovaraju atributima results JSON odgovora jer u suprotnom serijalizaciju treba napraviti samostalno.
WsCaller sadrži programsko su?elje koje koristi Retrofit biblioteka. Tim su?eljem pomodu anotacije @POST koja odgovara POST poruci HTTP protokola definirana je ruta do web servisa koji ispisuje sve poruke. Od strane servera, ta metoda definirana je datotekom json.php (iako je ?ešde definirana samom lokacijom, bez ekstenzije datoteke), a od strane mobilne aplikacije Memento, metoda je definirana nazivom getAllNews, što de Retrofit zapisati u klasu WsResponse.
WsCaller:



Kona?no, najsloženija klasa je WsDataLoader. Koja sadrži samo dvije lokalne varijable, BASE_URL
i result te dvije metode loadDataFromWebService i getFetchedNewsArray.
Varijabla BASE_URL sadrži putanju do korijena web servisa, a u varijablu result se zapisuje odgovor s web servisa, ?im stigne. Naime, ovdje se koristi asinkroni pristup, što zna?i da nakon poziva web servisa, odnosno dugotrajne usluge, aplikacija nije blokirana.
Metoda loadDataFromWebService priprema GSON instancu, definira format datuma te ju pridružuje instanci Retrofita. Isto tako, poziva web servis te postavlja sluša? doga?aja koji se okida nakon što stigne odgovor, odnosno metoda onReponse koja de u tijelu odgovora sadržavati i podatke, naravno ako je uspješna.
Metoda getFetchedNewsArray vrada trenutno zapisane podatke u lokalnoj varijabli result, koji se zapisuju u onResponse metodi.


WsDataLoader:





Nakon što korisnik na fragmentu za prikaz vijesti pritisne FAB potrebno je pozvati web servis, dakle klasu NewsFragment treba proširiti tako da se najprije poveže sa odgovarajudim RecyclerView- om:



I na kraju, potrebno je kreirati instancu WsDataLoader klase, kojom de se pozvati web servis, te implementirati poziv pritiskom na FAB putem ButterKnife biblioteke. U NewsFragment dodati zatamnjene linije kôda:
public class NewsFragment extends Fragment {

@Bind(R.id.rv_news_items) RecyclerView recyclerView;
	WsDataLoader dl;
	ProgressDialog progress;


//WsDataLoader klasi prosljedi
@Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
View rootView = inflater.inflate(R.layout.fragment_news, container, false);
ButterKnife.bind(this, rootView);
	dl = new WsDataLoader(); return rootView;
}

@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
super.onViewCreated(view, savedInstanceState);

recyclerView.setHasFixedSize(true);
LinearLayoutManager llm = new LinearLayoutManager(getActivity());

ArrayList<WsNewsItem> items = new ArrayList<>();
recyclerView.setLayoutManager(llm);

	if (dl.getFetchedNewsArray() != null) {
	recyclerView.setAdapter(new
NewsRecyclerViewAdapter(dl.getFetchedNewsArray(), getContext()));
	}
}

	// nakon pritiska FAB-a podigni dialog za u?itavanje s porukom
	// instanci WsDataLoader-a prosljedi referencu na sebe (za pristup metodi showLoadedData)
	@OnClick(R.id.button)
	public void clicked(View v) {
	dl.loadDataFromWebService(this);
	progress = ProgressDialog.show(getActivity(), getString(R.string.loading), getString(R.string.loading_message), true);
	}

	// postavi podatke (poziva se iz WsDataLoaderKlase)
	public void showLoadedData(ArrayList<WsNewsItem> newsItems) {
	recyclerView.setAdapter(new NewsRecyclerViewAdapter(newsItems, getContext()));
	progress.dismiss();

	}
}


A kako bi se NewsFragmentu dojavilo da su podaci stigli, WsDataLoader ved ima instancu fragmenta, samo što još preostaje je pozvati metodu kojom se prikazuju dohvadene novosti. Kod WsDataLoader.java na mjesto "JAVITI POZIVATELJU DA SU PODACI STIGLI... " : postaviti poziv metode za u?itavanje podataka:



I za kraj, u AndroidManifest.xml potrebno je dodati, odnosno zatražiti korisnika za dozvolu korištenja Interneta prilikom instalacije. Prije taga application dodati:


Memento je spreman za pokretanja i testiranje. Navigacijom do taba „Novosti“ te pritiskom na FAB, novosti su uspješno dohvadeni, a rezultat je prikazan na slici (Slika 104).

Slika 104. Pregled novosti dohva?enih putem web servisa


?ime je demo verzija aplikacije završena te je otvorena za daljnje nadogradnje i promjene.


5.8 Pitanja za provjeru znanja
1. Za koje sve platforme je mogude razvijati Android aplikacije putem Android Studija?
2. Što je API level?
3. Koliko datoteka obi?no vežemo uz Android aktivnosti?
4. U kojoj se datoteci definiraju ovisnosti o vanjskim bibliotekama?
5. Unutar kojeg direktorija u strukturu Android aplikacije se nalaze XML datoteke sa postavkama, dizajnom, grafi?kim korisni?kim su?eljima, mjerama itd.?
6. Zašto Android Studio prilikom uvoza slike uvijek kreira više instanci?
7. Zašto se koriste Java paketi?
8. Što se omoguduje kvalifikatorima XML datoteka?
9. ?emu služi RecyclerView?
10. Putem koje temeljne klase se dohvadaju resursi Android aplikacije?
11. Što je FAB?
12. Koja je razlika izme?u TextView i TextEdit?
13. Na koji se na?in prevodi korisni?ko su?elje Android aplikacije na druge jezike?
14. Pojasnite pojam doga?aja u radu s Android korisni?kim su?eljem i pojasnite ?emu služi biblioteka Butterknife.
15. Što je Spinner?
16. Pojasnite što su dijalozi.
17. Pojasnite i skicirajte sve elemente potrebne za rad sa RecyclerView-om.
18. ?emu služi programsko su?elje, u kontekstu doga?aja?
19. Što je XML i pojasnite njegovu strukturu?
20. Što je JSON i pojasnite njegovu strukturu?
21. Pojasnite ?emu služe „rute“ kod Retrofit biblioteke.
22. Pojasnite što je Intent?
23. Objasnite razliku izme?u aktivnosti i fragmenta.
24. Zašto je važan dizajn grafi?kog korisni?kog su?elja kod razvoja mobilnih aplikacija?
25. Komentirajte primjenu biblioteka trede strane naspram razvoja vlastite biblioteke.

5.9 Resursi za samostalan rad
* Google Developers, službena web stranica https://developer.android.com/training/index.html
* Online te?ajevi:
Udacity Android Basics Nanodegree by Google, Android Developer Nanodegree by Google https://www.udacity.com/courses/android


* Kilobolt online, Uvod u razvoj igara s Androidom
www.kilobolt.com/game-development-tutorial.html
* YouTube kanal „AndroidDevelopers“,
https://www.youtube.com/user/androiddevelopers
* YouTube video „Android Programming Tutorial 2015 | The Complete Tutorial to Learn Android https://www.youtube.com/watch?v=FUbcoQ-8kRQ



RJE?NIK STRU?NIH POJMOVA

Arhitekturni dizajn (eng. architectural design): Niz aktivnosti koje se provode u svrhu definiranja arhitekture programskog proizvoda. Te aktivnosti su popradene korištenjem odgovarajudih alata za izradu odgovarajudih dijagrama. Rezultat arhitekturnog dizajna su osnovne komponente sustava, njihove uloge i me?usobne veze.
Dizajn programskog proizvoda (eng. software dedign): Niz aktivnosti koje se provode u svrhu definiranja unutarnje strukture, funkcionalnosti i ponašanja dijela programskog proizvoda (modula) ili programskog proizvoda u cjelini. Te aktivnosti su popradenje korištenjem odgovarajudih alata za izradu dijagrama i ostale dokumentacije. Rezultat faze dizajna programskog proizvoda su detaljno razra?ene specifikacije funkcionalnosti, ponašanja i strukture svih gradbenih dijelova ra?unalnog programa.
Generalizacija: Predstavlja proces grupiranja klasa objekata po promatranim zajedni?kim i/ili istovjetnim odlikama. Generalizacijom se klase objekata grupiraju, a potom opisuju pomodu nadklasa.
Integrirano razvojno okruženje (eng. Integrated Development Environmet): Predstavlja skup alata za provedbu svih aktivnosti u procesu razvoja, testiranja i objave programskih proizvoda. Napredna razvojna okruženja višestruko ubrzavaju proces razvoja.
Internet stvari (eng. Internet of Things): Predstavlja mrežu sa?injenu od fizi?kih objekata (stvari, ure?aja) stalno spojenih na Internet s kojeg mogu primati i slati podatke. Naj?ešde se koristi kako bi se opisalo skup fizi?kih ure?aja koji imaju mogudnost prikupljati podatke (pomodu senzora) i slati ih u centralnu bazu ili pak prikazati rezultat njihove obrade.
Internet svega (eng. Internet of Everything): Predstavlja mrežu sa?injenu od fizi?kih i nefizi?kih objekata (stvari, ure?aja, usluga, ljudi, ra?unalnih agenata, ugra?enih ure?aja….) stalno spojenih na Internet s kojeg mogu primati i slati podatke. Ostale karakteristike su sli?ne konceptu Internet stvari.
Klasa objekata: Predstavlja skup jedinki (entiteta) iz realnog svijeta koje imaju istovrsna svojstva i ponašanja. Na primjer: svi ljudi mogu biti opisani klasom „?ovjek“, dok sve životinje mogu biti opisane klasom „Životinja“. Ipak, i ljudi i neke životinje mogu imati istovjetna svojstva i ponašanja, što tako?er možemo opisati klasom „Sisavac“.
Klju?na funkcionalnost (eng. key feature): Predstavlja osnovnu funkcionalnost mobilne aplikacije oko koje se definiraju sve dodatne funkcionalnosti. Primjeri osnovnih funkcionalnosti mogu biti evidencija osobne potrošnje ili podsjetnik za neobavljene zadatke.
Metodika razvoja programskog proizvoda (eng. Software Development Methodology): predstavlja sistematiziran pristup u provedbi procesa razvoja programskog proizvoda. Metodika definira klju?ne faze i aktivnosti razvoja, klju?ne uloge i njihove odgovornosti te klju?ne artefakte (ulaze i izlaze) iz definiranih aktivnosti.
Mobilna aplikacija (eng. mobile application): Programski proizvod izra?en za bilo koju vrstu mobilnog ure?aja (pametnog telefona, tableta, nosivog ure?aja i sli?no, ure?aja proširene stvarnosti…) koji ima korisni?ko su?elje. Mobilne aplikacije ne uklju?uju programske proizvode izra?ene za ugra?ene ure?aje.


Naslje?ivanje (eng. Inheritance): Jedan od osnovnih objektno orijentiranih koncepata koji omoguduje specijaliziranim klasama naslijediti svojstva i metode generalizirane (nadre?ene) klase. U ispravnom objektno orijentiranom dizajnu jedna specijalizirana klasa može direktno naslijediti samo jednu nadklasu.
Objekt: Predstavlja pojavu (entitet) iz stvarnog svijeta. Objekt je instanca (jedinka) odre?ene klase objekata. Na primjer: iz klase objekata „?ovjek“ možemo instancirati objekte kao što su „Marta“,
„Igor“, „Emanuel“ ili „Tomislav“.
Objektno orijentirani dizajn (eng. Object oriented design - OOD): Predstavlja proces dizajna programskog proizvoda temeljenog na objektu kao osnovnom konceptu. Neki od alata korištenih u OOD-u su dijagram klasa koji prikazuje klase objekata i njihove me?usobne veze, dijagram objekata koji prikazuje veze izme?u objekata, to jest instanci klasa, dijagram paketa koji prikazuje klase grupirane u pakete i veze izme?u paketa, dijagram slijeda, komunikacije i druge koji prikazuju interakciju izme?u objekata i druge.
Objektno orijentirano programiranje (eng. Object oriented programming - OOP): Predstavlja proces implementacije programskog proizvoda primjenom objektno orijentiranih koncepata. OOP je slijedi nakon OOD-a, a osnovni koncepti koji se pri tome primjenjuju su objekt, naslje?ivanje, u?ahurivanje i polimorfizam.
Pametni telefon (eng. smart phone, smarthpone): Mobilni telefon koji osim osnovnih funkcionalnosti uspostave telefonskog poziva, može izvršavati ra?unalni softver, te može autonomno prikupljati i obra?ivati podatke, a rezultate obrade pohraniti, dijeliti ili dati korisniku na uvid.
Pametni ure?aj (eng. smart device): Bilo koji ure?aj koji autonomno prikuplja i obra?uje podatke, te ih pohranjuje, dijeli ili daje korisniku na uvid. Primjeri pametnih ure?aja mogu biti mobilni telefoni, satovi, narukvice, nao?ale ili pak oprema za sport, zabavu, u?enje i sli?no.
Polimorfizam / višeobli?je (eng. Polymorphism): Kao jedan od osnovnih objektno orijentiranih koncepata omoguduje korištenje metoda naslije?ene nadklase ali i promijenjenih metoda u specifi?noj klasi. Isti objekt može imati više oblika, od kojih se svaki može koristiti uz naglasak na promjeni tipa objekta.
Povezani ure?aj (eng. connected device): Ure?aj koji se povremeno ili trajno povezuje na Internet ili drugu mrežu. Ovi ure?aji mogu komunicirati sa poslužiteljima (serverima) putem interneta, ali, ovisno o modelu, mogu biti i direktno povezani i/ili izmjenjivati podatke.
Proces razvoja programskog proizvoda (eng. Software development process): Predstavlja proces ili niz aktivnosti koji pretvara korisni?ke zahtjeve u programski proizvod
Proširena stvarnost (eng. augmented reality): Zajedni?ki naziv za skup tehnologija koje se koriste u svrhu kombiniranja elemente realne stvarnosti (slika, tekst, zvuk, video…) kako bi ih se nadopunilo i nadopunjene prezentiralo korisniku. Prezentacija se obi?no vrši kroz specifi?an medij kao što su posebne nao?ale.
Razvoj mobilnog softvera / razvoj mobilnih aplikacija (eng. mobile software development): Predstavlja skup aktivnosti koje provode ?lanovi projektnog tima u svrhu osmišljavanja, izrade, puštanja u rad te održavanja programskog proizvoda. Razvoj možemo promatrati kroz sljedede osnovne faze: razrada projektne ideje i definiranje funkcionalnosti, dizajn izgleda proizvoda, dizajn arhitekture i strukture proizvoda, izrada (programiranje), testiranje, puštanje u rad i održavanje. Sve

RJE?NIK STRU?NIH POJMOVA

navedene faze uklju?uju izradu dokumentacije te provedbu metodi?kog (strukturiranog) pristupa u njihovoj provedbi.
Refaktoriranje kôda: Predstavlja aktivnost promjene programskog kôda bez promjene funkcionalnosti. Naj?ešde se provodi kako bi se programski kôd o?istio, optimizirao, u?inio jednostavnijim za ?itanje i nadogradnju.
Set za razvoj aplikacija (eng. Software Development Kit - SDK): Predstavlja set klasa i osnovnih alata ciljano kreiranih za razvoj odre?enih aplikacija. Na primjer Android SDK donosi sve osnovne klase i alate koji u suradnji sa integriranim razvojnim okruženjem ?ine minimum potreban za razvoj Android aplikacija.
Specijalizacija: Predstavlja proces izdvajanja specifi?nih (razli?itih) klasa objekata po promatranim odlikama iz generalizirane nadklase koja sadrži zajedni?ka svojstva. Specijalizirana klasa naslje?uje sva svojstva i metode nadklase, a potom ih može ili ne mora izmijeniti ili nadopuniti.
Strukturalni dizajn / dizajn strukture (eng. structural design): vidi Dizajn programskog proizvoda.
SWEBOK (eng. Software Engineering Body of Knowledge): me?unarodni ISO/IEC standard koji predstavlja globalno prihvadeni korpus znanja (eng. body of knowledge) u podru?ju softverskog inženjerstva. Kreiran je suradnjom više stru?nih udruženja i predstavnika industrije te je objavljen pod okriljem IEEE organizacije. Trenutno se priprema nova verzija ovog dokumenta.
U?ahurivanje (eng. Encapsulation): Kao jedan od osnovnih objektno orijentiranih koncepata predstavlja mogudnost objekta da objedini podatke (o objektu) i metode izmjene tih podataka (ponašanje objekta). U?ahurivanje omoguduje skrivanje podataka i implementaciju metoda od drugih objekata, ali i pristup isklju?ivo pomodu unaprijed definiranog su?elja (javnih svojstava ili metoda).
Ugra?eni ure?aj (eng. embedded device): Ure?aj bez korisni?kog su?elja koji naj?ešde ima vlastiti mikroprocesor, te ima ulogu prikupljati, obra?ivati i distribuirati podatke unutar vedeg sustava u koji je ugra?en.
Virtualna stvarnost (eng. Virtual reality): Zajedni?ki naziv za skup tehnologija koje se koriste u svrhu zamjene elemenata realne stvarnosti (sliku, tekst, zvuk, video…) koji potom kroz specifi?an medij prezentiraju korisniku. Na primjer, nosedi posebne nao?ale korisnik može „oko sebe“ vidjeti grad u kojem se fizi?ki ne nalazi.
Vode?a funkcionalnost (eng. Kill feature): Predstavlja najvažniju funkcionalnost mobilnog programskog proizvoda koju nemaju drugi proizvodi na tržištu. Oko ove funkcionalnosti, koja u direktnom prijevodu s engleskog jezika zna?i „funkcionalnost koja ubija“, se obi?no gradi marketinški plan i plan promocije proizvoda kako bi se naglasila njegova najvažnija prednost u odnosu na ostale proizvode.




ADB – Most za ispravljanje pogrešaka u aplikacijama za Android (eng. Android Debug Bridge) API – Aplikacijskom programibilno su?elje (eng. Application Programming Interface)
ART – Izvršne datoteke za Android (eng. Android Runtime) AVD – Virtualni ure?aj za Android (eng. Android Virtual Device)
IDE – Integrirano razvojno okruženje (eng. Integrated Development Environment) IKT – Informacijko-komunikacijske tehnologije
IoT – Internet stvari (eng. Internet of Things)
IoE – Internet svega (eng. Internet of Everything) IT – Informacijske tehnologije
NFC – Kratkodometna beži?na komunikacija (eng. Near Field Communication) OCR – Opti?ko prepoznavanje znakova (eng. Optical Character Recognition) OO – Objektno orijentirano
OOD – Objektno orijentirani dizajn
OOP – Objektno orijentirano programiranje
SDK – Set za razvoj aplikacija (eng. Software Development Kit)
SDLC – Životni ciklus razvoja sustava (eng. Systems Development Life Cycle)
SWEBOK – Korpus znanja iz softverskog inženjerstva (eng. Software Engineering Body of Knowledge) XML – Proširivi opisni jezik (eng. Extensible Markup Language)




[1] “IEEE Standard Glossary of Software Engineering Terminology (610.12-1990)“, IEEE Std 610.121990, 1990.
[2] “Guide to the software engineering body of knowledge (SWEBOK V3) - Software engineering models and methods (Chapter 10 - Unpublished - In Review)“, Technical report, 2012.
[3] Centers for Medicare and Medicaid Services (CMS), Office of information Services, “Selecting a development approach”. 2008.
[4] G. Elliott, Global business information technology: an integrated systems approach. Harlow, England; New York: Pearson Addison Wesley, 2004.
[5] “Guide to the software engineering body of knowledge 2004 version: SWEBOK”, Los Alamitos, CA, Technical report ISO/IEC TR 19759, 2004.
[6] K. Schwaber and J. Sutherland, “The Scrum Guide - The definitive guide to Scrum: The rules of the game”. Scrum.org, 2011.
[7] D. Wells, “Extreme Programming: A Gentle Introduction“, 2009. [Online]. Dostupno na: http://www.extremeprogramming.org/. [Accessed: 22-Apr-2016].
[8] J. Sutherland, “Jeff Sutherland’s Scrum Handbook”, Scrum Training Institute Press, 2010.
[9] C. Murphy, “Adaptive Project Management Using Scrum”, Methods Tools, vol. 12, no. 4, pp. 10–22, 2004.
[10] Y. D. Liang, Introduction to JAVA Programming - Comprehensive Version, 9. izdanje. Boston: Pearson, 2013.
[11] IEEE Computer Society, IEEE Standard for Floating-Point Arithmetic. New York, NY, USA: IEEE, 2008.
[12] C. Lin, “Floating Point”. University of Maryland, 2003.
[13] H. Schmidt, IEEE 754 Converter. Bonn, Germany.
[14] B. Kurniawan, “Introduction to OOP in VB.NET“, Windowsdevcenter.com, 2002. .
[15] M. Mullin, Object Oriented Program Design. Massachusetts: Addison-Wesley, 1989.
[16] I. Pokec, “Usporedba razvojnih okruženja za razvoj android mobilnih aplikacija“, Diplomski rad, Sveu?ilište u Zagrebu, Fakultet organizacije i informatike Varaždin, Varaždin, Hrvatska, 2016.
[17] Google Inc. “Android Studio - The Official IDE for Android“, Android Developers, 2016. [Online]. Dostupno na: https://developer.android.com/studio/index.html.
[18] Google Inc. “Platform Architecture“, Android Developers, 2016. [Online]. Dostupno na: https://developer.android.com/guide/platform/index.html.
[19] Google Inc. “Activities“, Android Developers API Guides, 2016. [Online]. Dostupno na: https://developer.android.com/guide/components/activities.html.
[20] Google Inc. “Managing the Activity Lifecycle“, Android Developers Training, 2016. [Online]. Dostupno na: https://developer.android.com/training/basics/activity-lifecycle/index.html.
[21] Google Inc. “App Manifest”, Android Developers API Guides, 2016. [Online]. Dostupno na: https://developer.android.com/guide/topics/manifest/manifest-intro.html.
[22] Gradle Inc. “Gradle Build Tool - Polyglot build automation system”, Gradle.org, 2016. [Online]. Dostupno na: https://gradle.org/.
[23] T. Berglund and M. McCullough, Building and testing with Gradle. Sebastopol, CA: O’Reilly Media, Inc, 2011.
[24] M. McCullough and T. Berglund, Gradle beyond the basics: [customizing next-generation builds]. Beijing: O’Reilly, 2013.
[25] K. Kousen, Gradle recipes for Android: master the new build system for Android. 2016.
[26] Google Inc. “Storage Options“, Android Developers API Guides, 2016. [Online]. Dostupno na: https://developer.android.com/guide/topics/data/data-storage.html.
[27] Z. R. Mednieks, Ed., Programming Android, 1st ed. Sebastopol, Calif: O’Reilly, 2011.

RAZVOJ MOBILNIH APLIKACIJA - PRIRU?NIK ZA 4. RAZRED GIMNAZIJE

[28] Google Inc. “Settings”, Android Developers API Guides, 2016. [Online]. Dostupno na: https://developer.android.com/guide/topics/ui/settings.html.
[29] D. R. Hipp, “About SQLite“, SQLite.org, 2016. [Online]. Dostupno na: https://www.sqlite.org/about.html.
[30] R. Manger, Baze podataka, 1. izdanje. Element d.o.o, 2012.
[31] C. J. Date, An introduction to database systems, 8. izdanje. Boston: Pearson/Addison Wesley, 2004.
[32] Google Inc. “Saving Data in SQL Databases“, Android Developers Training, 2016. [Online]. Dostupno na: https://developer.android.com/training/basics/data-storage/databases.html.
[33] T. Bray, J. Paoli, C. M. Sperberg-McQueen, E. Maler, and F. Yergeau, Eds., Extensible Markup Language (XML) 1.0, 5. izdanje. W3C Consortium, 2008.
[34] ECMA International, Standard ECMA-404 The Json Data Interchange Format, 1. izdanje. Geneva: ECMA International, 2013.
[35] T. W3C XML Protocol Working Group, SOAP Specifications. W3 Consortium, 2007.
[36] D. Booth, H. Haas, F. McCabe, E. Newcomer, M. Champion, C. Ferris, and D. Orchard, Eds., Web Services Architecture. W3 Consortium, 2004.
[37] I. Square, “Retrofit - A type-safe HTTP client for Android and Java“, 2013. [Online]. Dostupno na: http://square.github.io/retrofit/.
[38] ..., “Gson Git - A Java serialization/deserialization library that can convert Java Objects into JSON and back“, Github.com, 2016. [Online]. Dostupno na: https://github.com/google/gson.
[39] Google Inc. “Klasa CoordinatorLayout”, Android Developers, 2016. [Online]. Dostupno na: https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout. html.
[40] Google Inc. “Material Design - Introduction”, Material Design, 2016. [Online]. Dostupno na: https://material.google.com/.
[41] Google Inc. “Klasa AppBarLayout“, Android Developers, 2016. [Online]. Dostupno na: https://developer.android.com/reference/android/support/design/widget/AppBarLayout.html
[42] Google Inc. “Klasa TabLayout“, Android Developers, 2016. [Online]. Dostupno na: https://developer.android.com/reference/android/support/design/widget/TabLayout.html.
[43] Google Inc. “Using ViewPager for Screen Slides“, Android Developers Training, 2016. [Online]. Dostupno na: https://developer.android.com/training/animation/screen-slide.html.
[44] Google Inc. “Klasa RecyclerView“, Android Developers, 2016. [Online]. Dostupno na: https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html.
[45] Google Inc. “Creating Lists and Cards - Create Cards”, Android Developers Training, 2016. [Online]. Dostupno na: https://developer.android.com/training/material/lists- cards.html#CardView.
[46] Google Inc. “Adapter Interface”, Android Developers, 2016. [Online]. Dostupno na: https://developer.android.com/reference/android/widget/Adapter.html.
[47] Google Inc. “Apstraktna klasa FragmentStatePagerAdapter“, Android Developers, 2016. [Online]. Dostupno na: https://developer.android.com/reference/android/support/v13/app/FragmentStatePagerAda pter.html.
[48] Google Inc. “Providing Resources“, Android Developers API Guides, 2016. [Online]. Dostupno na: https://developer.android.com/guide/topics/resources/providing-resources.html.




























































































































































































































































































































































































































































































































































































































































































































































